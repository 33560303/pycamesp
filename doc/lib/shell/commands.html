<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lib.shell.commands API documentation</title>
<meta name="description" content="Class defining a minimalist shell, directly executable on the board.
We modify directories, list, delete, move files, edit files ..
The commands are
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.shell.commands</code></h1>
</header>
<section id="section-intro">
<p>Class defining a minimalist shell, directly executable on the board.
We modify directories, list, delete, move files, edit files ..
The commands are :
- cd
: change directory
- pwd
: current directory
- cat
: display the content of file
- cls
: clear screen
- mkdir
: create directory
- mv
: move file
- rmdir
: remove directory
- cp
: copy file
- rm
: remove file
- ls
: list file
- ll
: list file long
- date
: get the system date or synchronize with Ntp
- setdate
: set date and time
- uptime
: the amount of time system is running
- find
: find a file
- run
: execute python script
- download
: transfer files from device to computer (only available with camflasher)
- upload
: transfer files from computer to device (only available with camflasher)
- edit
: edit a text file
- exit
: exit of shell
- gc
: garbage collection
- grep
: grep text in many files
- mount
: mount sd card
- umount
: umount sd card
- temperature : device temperature
- meminfo
: memory informations
- flashinfo
: flash informations
- sysinfo
: system informations
- deepsleep
: deepsleep of board
- ping
: ping host
- reboot
: reboot board
- help
: list all command available
- man
: manual of one command
- df
: display free disk space
- ip2host
: convert ip address in hostname
- host2ip
: convert hostname in ip address
- eval
: evaluation python string
- exec
: execute python string
- dump
: display hexadecimal dump of the content of file</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
# pylint:disable=too-many-lines
# pylint:disable=consider-using-f-string
# pylint:disable=unspecified-encoding
&#34;&#34;&#34; Class defining a minimalist shell, directly executable on the board.
We modify directories, list, delete, move files, edit files ..
The commands are :
- cd          : change directory
- pwd         : current directory
- cat         : display the content of file
- cls         : clear screen
- mkdir       : create directory
- mv          : move file
- rmdir       : remove directory
- cp          : copy file
- rm          : remove file
- ls          : list file
- ll          : list file long
- date        : get the system date or synchronize with Ntp
- setdate     : set date and time
- uptime      : the amount of time system is running
- find        : find a file
- run         : execute python script
- download    : transfer files from device to computer (only available with camflasher)
- upload      : transfer files from computer to device (only available with camflasher)
- edit        : edit a text file
- exit        : exit of shell
- gc          : garbage collection
- grep        : grep text in many files
- mount       : mount sd card
- umount      : umount sd card
- temperature : device temperature
- meminfo     : memory informations
- flashinfo   : flash informations
- sysinfo     : system informations
- deepsleep   : deepsleep of board
- ping        : ping host
- reboot      : reboot board
- help        : list all command available
- man         : manual of one command
- df          : display free disk space
- ip2host     : convert ip address in hostname
- host2ip     : convert hostname in ip address
- eval        : evaluation python string
- exec        : execute python string
- dump        : display hexadecimal dump of the content of file
&#34;&#34;&#34;
# pylint:disable=wrong-import-position
import sys
import io
import os
import uos
import machine
import tools.useful
import tools.logger
import tools.sdcard
import tools.filesystem
import tools.exchange
import tools.info
import tools.strings
import tools.terminal
import tools.watchdog
import tools.lang
import tools.date
import tools.console
import tools.system

shell_commands = None

def get_screen_size():
        &#34;&#34;&#34; Return the screen size and check if output redirected &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        if tools.console.Console.is_redirected() is False:
                height, width = tools.terminal.get_screen_size()
        else:
                height, width = tools.terminal.MAXINT, 80
        return height, width

def cd(directory = &#34;/&#34;):
        &#34;&#34;&#34; Change directory &#34;&#34;&#34;
        try:
                uos.chdir(tools.filesystem.normpath(directory))
        except:
                if directory != &#34;.&#34;:
                        tools.console.Console.print(&#34;No such file or directory &#39;%s&#39;&#34;%directory)

def pwd():
        &#34;&#34;&#34; Display the current directory &#34;&#34;&#34;
        tools.console.Console.print(&#34;%s&#34;%uos.getcwd())

def mkdir(directory, recursive=False, quiet=False):
        &#34;&#34;&#34; Make directory &#34;&#34;&#34;
        try:
                if quiet is False:
                        tools.console.Console.print(&#34;mkdir &#39;%s&#39;&#34;%directory)
                tools.filesystem.makedir(tools.filesystem.normpath(directory), recursive)
        except:
                tools.console.Console.print(&#34;Cannot mkdir &#39;%s&#39;&#34;%directory)

def removedir(directory, force=False, quiet=False, simulate=False, ignore_error=False):
        &#34;&#34;&#34; Remove directory &#34;&#34;&#34;
        try:
                if tools.filesystem.exists(directory+&#34;/.DS_Store&#34;):
                        rmfile(directory+&#34;/.DS_Store&#34;, quiet, force, simulate)
                if (tools.filesystem.ismicropython() or force) and simulate is False:
                        uos.rmdir(directory)
                if quiet is False:
                        tools.console.Console.print(&#34;rmdir &#39;%s&#39;&#34;%(directory))
        except:
                if ignore_error is False:
                        tools.console.Console.print(&#34;rmdir &#39;%s&#39; not removed&#34;%(directory))

def rmdir(directory, recursive=False, force=False, quiet=False, simulate=False, ignore_error=False):
        &#34;&#34;&#34; Remove directory &#34;&#34;&#34;
        directory = tools.filesystem.normpath(directory)
        if recursive is False:
                removedir(directory, force=force, quiet=quiet, simulate=simulate, ignore_error=ignore_error)
        else:
                directories = [directory]
                d = directory
                while 1:
                        parts = tools.filesystem.split(d)
                        if parts[1] == &#34;&#34; or parts[0] == &#34;&#34;:
                                break
                        directories.append(parts[0])
                        d = parts[0]
                if &#34;/&#34; in directories:
                        directories.remove(&#34;/&#34;)
                if tools.sdcard.SdCard.get_mountpoint() in directories:
                        directories.remove(tools.sdcard.SdCard.get_mountpoint())
                for d in directories:
                        if tools.filesystem.exists(d) and d != &#34;.&#34;:
                                removedir(d, force=force, quiet=quiet, simulate=simulate, ignore_error=ignore_error)

def mv(source, destination):
        &#34;&#34;&#34; Move or rename file &#34;&#34;&#34;
        try:
                uos.rename(tools.filesystem.normpath(source),tools.filesystem.normpath(destination))
        except:
                tools.console.Console.print(&#34;Cannot mv &#39;%s&#39;-&gt;&#39;%s&#39;&#34;%(source,destination))

def copyfile(src,dst,quiet):
        &#34;&#34;&#34; Copy file &#34;&#34;&#34;
        dst = dst.replace(&#34;//&#34;,&#34;/&#34;)
        dst = dst.replace(&#34;//&#34;,&#34;/&#34;)
        dstdir, dstfile = tools.filesystem.split(dst)
        try:
                if not tools.filesystem.exists(dstdir):
                        if dstdir != &#34;.&#34; and dstdir != &#34;&#34;:
                                mkdir(dstdir, recursive=True, quiet=quiet)
                src_file = open(src, &#39;rb&#39;)
                dst_file = open(dst, &#39;wb&#39;)
                if quiet is False:
                        tools.console.Console.print(&#34;cp &#39;%s&#39; -&gt; &#39;%s&#39;&#34;%(src,dst))
                while True:
                        buf = src_file.read(256)
                        if len(buf) &gt; 0:
                                dst_file.write(buf)
                        if len(buf) &lt; 256:
                                break
                src_file.close()
                dst_file.close()
        except:
                tools.console.Console.print(&#34;Cannot cp &#39;%s&#39; -&gt; &#39;%s&#39;&#34;%(src, dst))

def cp(source, destination, recursive=False, quiet=False):
        &#34;&#34;&#34; Copy file command &#34;&#34;&#34;
        source = tools.filesystem.normpath(source)
        destination = tools.filesystem.normpath(destination)
        if tools.filesystem.isfile(source):
                copyfile(source,destination,quiet)
        else:
                if tools.filesystem.isdir(source):
                        path = source
                        pattern = &#34;*&#34;
                else:
                        path, pattern = tools.filesystem.split(source)

                _, filenames = tools.filesystem.scandir(path, pattern, recursive)

                for src in filenames:
                        dst = destination + &#34;/&#34; + src[len(path):]
                        copyfile(src,dst,quiet)

def rmfile(filename, quiet=False, force=False, simulate=False):
        &#34;&#34;&#34; Remove file &#34;&#34;&#34;
        try:
                if (tools.filesystem.ismicropython() or force) and simulate is False:
                        uos.remove(tools.filesystem.normpath(filename))
                if quiet is False:
                        tools.console.Console.print(&#34;rm &#39;%s&#39;&#34;%(filename))
        except:
                tools.console.Console.print(&#34;rm &#39;%s&#39; not removed&#34;%(filename))

def rm(file, recursive=False, quiet=False, force=False, simulate=False):
        &#34;&#34;&#34; Remove file command &#34;&#34;&#34;
        file = tools.filesystem.normpath(file)
        filenames   = []
        directories = []

        if tools.filesystem.isfile(file):
                path = file
                rmfile(file, force=force, quiet=quiet, simulate=simulate)
        else:
                if tools.filesystem.isdir(file):
                        if recursive:
                                directories.append(file)
                                path = file
                                pattern = &#34;*&#34;
                        else:
                                path = None
                                pattern = None
                else:
                        path, pattern = tools.filesystem.split(file)

                if path is None:
                        tools.console.Console.print(&#34;Cannot rm &#39;%s&#39;&#34;%file)
                else:
                        dirs, filenames = tools.filesystem.scandir(path, pattern, recursive)
                        directories += dirs

                        for filename in filenames:
                                rmfile(filename, force=force, quiet=quiet, simulate=simulate)

                        if recursive:
                                directories.sort()
                                directories.reverse()

                                for directory in directories:
                                        rmdir(directory, recursive=recursive, force=force, quiet=quiet, simulate=simulate, ignore_error=True)

class LsDisplayer:
        &#34;&#34;&#34; Ls displayer class &#34;&#34;&#34;
        def __init__(self, path, showdir, long):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.height, self.width = get_screen_size()
                self.count = 1
                self.long = long
                self.path = path
                self.showdir = showdir

        def purge_path(self, path):
                &#34;&#34;&#34; Purge the path for the display &#34;&#34;&#34;
                path = path.encode(&#34;utf8&#34;)
                path = tools.filesystem.normpath(path)
                prefix = tools.filesystem.prefix([path, self.path.encode(&#34;utf8&#34;)])
                return path[len(prefix):].lstrip(b&#34;/&#34;)

        def show(self, path):
                &#34;&#34;&#34; Show the information of a file or directory &#34;&#34;&#34;
                fileinfo = tools.filesystem.fileinfo(path)
                file_date = fileinfo[8]
                size = fileinfo[6]

                # If directory
                if fileinfo[0] &amp; 0x4000 == 0x4000:
                        if self.showdir:
                                if self.long:
                                        message = b&#34;%s %s [%s]&#34;%(tools.date.date_to_bytes(file_date),b&#34; &#34;*7,self.purge_path(path))
                                else:
                                        message = b&#34;[%s]&#34;%self.purge_path(path)
                                self.count = print_part(message, self.width, self.height, self.count)
                else:
                        if self.long:
                                fileinfo = tools.filesystem.fileinfo(path)
                                file_date = fileinfo[8]
                                size = fileinfo[6]
                                message = b&#34;%s %s %s&#34;%(tools.date.date_to_bytes(file_date),tools.strings.size_to_bytes(size),self.purge_path(path))
                        else:
                                message = self.purge_path(path)
                        self.count = print_part(message, self.width, self.height, self.count)

        def show_dir(self, state):
                &#34;&#34;&#34; Indicates if the directory must show &#34;&#34;&#34;
                self.showdir = state

def ls(file=&#34;&#34;, recursive=False, long=False):
        &#34;&#34;&#34; List files command &#34;&#34;&#34;
        searchfile(file, recursive, LsDisplayer(uos.getcwd(), True, long))

def ll(file=&#34;&#34;, recursive=False):
        &#34;&#34;&#34; List files long command &#34;&#34;&#34;
        searchfile(file, recursive, LsDisplayer(uos.getcwd(), True, True))

def searchfile(file, recursive, obj = None):
        &#34;&#34;&#34; Search file &#34;&#34;&#34;
        file = tools.filesystem.normpath(file)
        p = tools.filesystem.abspath(uos.getcwd(), file)
        filenames = []
        try:
                if file == &#34;&#34;:
                        _,filenames = tools.filesystem.scandir(uos.getcwd(), &#34;*&#34;, recursive, obj)
                elif tools.filesystem.isfile(p):
                        if obj is not None:
                                obj.show_dir(False)
                                obj.show(p)
                        filenames = [p]
                elif tools.filesystem.isdir(p):
                        _, filenames = tools.filesystem.scandir(p, &#34;*&#34;, recursive, obj)
                else:
                        path, pattern = tools.filesystem.split(p)
                        if obj is not None:
                                obj.show_dir(False)
                        _, filenames = tools.filesystem.scandir(path, pattern, recursive, obj)
        except Exception as err:
                tools.console.Console.print(err)
        if len(filenames) == 0 and file != &#34;&#34; and file != &#34;.&#34;:
                tools.console.Console.print(&#34;%s : No such file or directory&#34;%file)
        return filenames

def find(file):
        &#34;&#34;&#34; Find a file in directories &#34;&#34;&#34;
        filenames = searchfile(file, True)
        for filename in filenames:
                tools.console.Console.print(filename)

def print_part(message, width, height, count):
        &#34;&#34;&#34; Print a part of text &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        if isinstance(message , bytes):
                message = message.decode(&#34;utf8&#34;)
        if count is not None and count &gt;= height:
                tools.console.Console.print(message,end=&#34;&#34;)
                if tools.console.Console.is_redirected() is False:
                        key = tools.terminal.getch()
                else:
                        key = &#34; &#34;
                count = 1
                if key in [&#34;x&#34;,&#34;X&#34;,&#34;q&#34;,&#34;Q&#34;,&#34;\x1B&#34;]:
                        return None
                tools.console.Console.print(&#34;\n&#34;, end=&#34;&#34;)
        else:
                if count is None:
                        count = 1
                else:
                        count += 1
                tools.console.Console.print(message)
        return count

def grep(file, text, recursive=False, ignorecase=False, regexp=False):
        &#34;&#34;&#34; Grep command &#34;&#34;&#34;
        from re import search
        file = tools.filesystem.normpath(file)
        def __search(text, content, ignorecase, regexp):
                if ignorecase:
                        content  = content.lower()
                        text = text.lower()
                if regexp:
                        if search(text, content):
                                return True
                else:
                        if content.find(text) != -1:
                                return True
                return False

        def __grep(text, filename, ignorecase, regexp, width, height, count):
                lineNumber = 1
                with open(filename,&#34;r&#34;, encoding=&#34;latin-1&#34;) as f:
                        while 1:
                                line = f.readline()
                                if line:
                                        if __search(text, line, ignorecase, regexp):
                                                line = line.replace(&#34;\t&#34;,&#34;    &#34;)
                                                message = &#34;%s:%d:%s&#34;%(filename, lineNumber, line)
                                                message = message.rstrip()[:width]
                                                count = print_part(message, width, height, count)
                                                if count is None:
                                                        tools.console.Console.print(&#34;&#34;)
                                                        return None
                                        lineNumber += 1
                                else:
                                        break
                return count

        if tools.filesystem.isfile(file):
                filenames = [file]
        else:
                path, pattern = tools.filesystem.split(file)
                _, filenames = tools.filesystem.scandir(path, pattern, recursive)

        height, width = get_screen_size()
        count = 1
        for filename in filenames:
                count = __grep(text, filename, ignorecase, regexp, width, height, count)
                if count is None:
                        break

def ping(host):
        &#34;&#34;&#34; Ping host &#34;&#34;&#34;
        try:
                from server.ping import ping as ping_
                ping_(host, count=4, timeout=1)
        except:
                tools.console.Console.print(&#34;Not available&#34;)

def ip2host(ip_address):
        &#34;&#34;&#34; Convert ip to hostname &#34;&#34;&#34;
        try:
                import wifi.station
                _, _, _, dns = wifi.station.Station.get_info()
                from server.dnsclient import resolve_hostname
                tools.console.Console.print(resolve_hostname(dns, ip_address))
        except:
                tools.console.Console.print(&#34;Not available&#34;)

def host2ip(hostname):
        &#34;&#34;&#34; Convert hostname to ip &#34;&#34;&#34;
        try:
                import wifi.station
                _, _, _, dns = wifi.station.Station.get_info()
                from server.dnsclient import resolve_ip_address
                tools.console.Console.print(resolve_ip_address(dns, hostname))
        except:
                tools.console.Console.print(&#34;Not available&#34;)

def mountsd(mountpoint=&#34;/sd&#34;):
        &#34;&#34;&#34; Mount command &#34;&#34;&#34;
        try:
                tools.sdcard.SdCard.mount(mountpoint)
                tools.console.Console.print(&#34;Sd mounted on &#39;%s&#39;&#34;%mountpoint)
        except:
                tools.console.Console.print(&#34;Cannot mount sd on &#39;%s&#39;&#34;%mountpoint)

def umountsd(mountpoint=&#34;/sd&#34;):
        &#34;&#34;&#34; Umount command &#34;&#34;&#34;
        try:
                tools.sdcard.SdCard.umount(mountpoint)
                tools.console.Console.print(&#34;Sd umounted from &#39;%s&#39;&#34;%mountpoint)
        except:
                tools.console.Console.print(&#34;Cannot umount sd from &#39;%s&#39;&#34;%mountpoint)

def date_time(update=False, offsetUTC=+1, noDst=False):
        &#34;&#34;&#34; Get or set date &#34;&#34;&#34;
        try:
                from server.timesetting import set_date
                if update:
                        if noDst:
                                dst = False
                        else:
                                dst = True
                        set_date(offsetUTC, dst)
                del sys.modules[&#34;server.timesetting&#34;]
        except:
                pass
        tools.console.Console.print(tools.date.date_to_string())

def setdate(datetime=&#34;&#34;):
        &#34;&#34;&#34; Set date and time &#34;&#34;&#34;
        import re
        file_date=re.compile(&#34;[/: ]&#34;)
        failed = False
        try:
                spls = file_date.split(datetime)

                lst = []
                if len(spls) &gt; 1:
                        for spl in spls:
                                if len(spl) &gt; 0:
                                        try:
                                                r = spl.lstrip(&#34;0&#34;)
                                                if len(r) == 0:
                                                        lst.append(0)
                                                else:
                                                        lst.append(eval(r))
                                        except:
                                                failed = True
                                                break
                        if len(lst) == 6:
                                # pylint: disable=unbalanced-tuple-unpacking
                                year,month,day,hour,minute,second = lst
                                machine.RTC().datetime((year, month, day, 0, hour, minute, second, 0))
                        else:
                                failed = True
                else:
                        failed = True
        except Exception as err:
                failed = True
                tools.logger.syslog(err)

        if failed is True:
                tools.console.Console.print(&#39;Expected format &#34;YYYY/MM/DD hh:mm:ss&#34;&#39;)

def formatsd(fstype=&#34;FAT&#34;):
        &#34;&#34;&#34; Format sd card &#34;&#34;&#34;
        if fstype in [&#34;FAT&#34;,&#34;LFS&#34;]:
                if tools.sdcard.SdCard.is_mounted() is False:
                        res = input(&#34;All data will be lost on Sd card ? proceed with format (y/n) :&#34;)
                        if res in [&#34;y&#34;,&#34;Y&#34;]:
                                if tools.sdcard.SdCard.formatsd() is True:
                                        tools.console.Console.print(&#34;Formatting terminated&#34;)
                                else:
                                        tools.console.Console.print(&#34;Formatting failed&#34;)
                else:
                        tools.console.Console.print(&#34;Sd card is mounted, a reboot required&#34;)
        else:
                tools.console.Console.print(&#34;Filesystem supported : FAT or LFS&#34;)

def reboot():
        &#34;&#34;&#34; Reboot command &#34;&#34;&#34;
        try:
                tools.system.reboot(&#34;Reboot device with command&#34;)
        except:
                machine.deepsleep(1000)

def deepsleep(seconds=60):
        &#34;&#34;&#34; Deep sleep command &#34;&#34;&#34;
        machine.deepsleep(int(seconds)*1000)

def ligthsleep(seconds=60):
        &#34;&#34;&#34; Light sleep command &#34;&#34;&#34;
        machine.lightsleep(int(seconds)*1000)

edit_class = None
def edit(file, no_color=False, read_only=False):
        &#34;&#34;&#34; Edit command &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        global edit_class
        if tools.console.Console.is_redirected() is False:
                if edit_class is None:
                        try:
                                from shell.editor import Editor
                        except:
                                from editor import Editor
                        edit_class = Editor
                edit_class(file, no_color=no_color, read_only=read_only)

def cat(file):
        &#34;&#34;&#34; Cat command &#34;&#34;&#34;
        try:
                f = open(file, &#34;r&#34;)
                height, width = get_screen_size()
                count = 1
                while 1:
                        line = f.readline()
                        if not line:
                                break
                        message = line.replace(&#34;\t&#34;,&#34;    &#34;).rstrip()[:width]
                        count = print_part(message, width, height, count)
                        if count is None:
                                break
                f.close()
        except:
                tools.console.Console.print(&#34;Cannot cat &#39;%s&#39;&#34;%(file))

def df(mountpoint = None):
        &#34;&#34;&#34; Display free disk space &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(tools.info.flashinfo(mountpoint=mountpoint)))

def gc():
        &#34;&#34;&#34; Garbage collector command &#34;&#34;&#34;
        from gc import collect
        collect()

def uptime():
        &#34;&#34;&#34; Tell how long the system has been running &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(tools.info.uptime()))

def man(command):
        &#34;&#34;&#34; Man command &#34;&#34;&#34;
        tools.console.Console.print(man_one(command))

def man_one(command_name):
        &#34;&#34;&#34; Manual of one command &#34;&#34;&#34;
        try:
                command_name, command_function, command_params, command_flags = get_command(command_name)
                text = &#34;  &#34; + command_name + &#34; &#34;
                for param in command_params:
                        text += param + &#34; &#34;
                text += &#34;\n&#34;
                for flag,flagName,val in command_flags:
                        text += &#34;    %s : %s\n&#34;%(flag,flagName)
                result = text[:-1]
        except:
                result = &#34;Unknown command &#39;%s&#39;&#34;%command_name
        return result

# pylint: disable=redefined-builtin
def help():
        &#34;&#34;&#34; Help command &#34;&#34;&#34;
        height, width = get_screen_size()
        count = 1
        cmds = list(shell_commands.keys())
        cmds.sort()
        for command in cmds:
                lines = man_one(command)
                lines = &#34;-&#34;*30+&#34;\n&#34; + lines
                for line in lines.split(&#34;\n&#34;):
                        count = print_part(line, width, height, count)
                        if count is None:
                                return

def eval_(string):
        &#34;&#34;&#34; Evaluate content of string &#34;&#34;&#34;
        tools.console.Console.print(eval(string))

def exec_(string):
        &#34;&#34;&#34; Execute content of string &#34;&#34;&#34;
        exec(string)

shell_exited = False
def exit():
        &#34;&#34;&#34; Exit shell command &#34;&#34;&#34;
        global shell_exited
        shell_exited = True

def dump_(filename):
        &#34;&#34;&#34; dump file content &#34;&#34;&#34;
        height, width = get_screen_size()
        if tools.console.Console.is_redirected() is False:
                width = (width - 12)//4
        else:
                width = 16
        offset = 0
        file = open(filename, &#34;rb&#34;)
        data = b&#39; &#39;
        count = 1
        while True:
                line = io.BytesIO()
                line.write(b&#39;%08X  &#39; % offset)
                data = file.read(width)
                if len(data) &lt;= 0:
                        break
                tools.strings.dump_line (data, line, width)
                offset += width
                count = print_part(line.getvalue(), width, height, count)
                if count is None:
                        break

def cls():
        &#34;&#34;&#34; clear screen &#34;&#34;&#34;
        tools.console.Console.print(&#34;\x1B[2J\x1B[0;0f&#34;, end=&#34;&#34;)

def check_cam_flasher():
        &#34;&#34;&#34; Check if the terminal is CamFlasher &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        if tools.console.Console.is_redirected() is False:
                # Request terminal device attribut
                sys.stdout.write(b&#34;\x1B[0c&#34;)

                # Wait terminal device attribut response
                response = tools.terminal.getch(duration=1000)

                # If CamFlasher detected
                if response == &#34;\x1B[?3;2c&#34;:
                        return True
        return False

def upload(file=&#34;&#34;, recursive=False):
        &#34;&#34;&#34; Upload file from computer to device &#34;&#34;&#34;
        if check_cam_flasher():
                tools.console.Console.print(&#34;Upload to device start&#34;)
                try:
                        command = tools.exchange.UploadCommand(uos.getcwd())
                        command.write(file, recursive, sys.stdin.buffer, sys.stdout.buffer)
                        result = True
                        while result:
                                file_reader = tools.exchange.FileReader()
                                result = file_reader.read(uos.getcwd(), sys.stdin.buffer, sys.stdout.buffer)
                                tools.watchdog.WatchDog.feed()
                        tools.console.Console.print(&#34;Upload end&#34;)
                except Exception as err:
                        tools.logger.syslog(err, display=False)
                        tools.console.Console.print(&#34;Upload failed&#34;)
        else:
                tools.console.Console.print(&#34;CamFlasher application required for this command&#34;)

class Exporter:
        &#34;&#34;&#34; Exporter file to camflasher &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;

        def send_file(self, path):
                &#34;&#34;&#34; Send the file &#34;&#34;&#34;
                result = True
                fileinfo = tools.filesystem.fileinfo(path)

                # If a file
                if fileinfo[0] &amp; 0x4000 != 0x4000:
                        file_write = tools.exchange.FileWriter()
                        if tools.filesystem.exists(path):
                                sys.stdout.buffer.write(&#34;à¿Š&#34;.encode(&#34;utf8&#34;))
                                result = file_write.write(path, sys.stdin.buffer, sys.stdout.buffer)
                                tools.watchdog.WatchDog.feed()
                return result

        def show(self, path):
                &#34;&#34;&#34; Show the information of a file or directory &#34;&#34;&#34;
                for _ in range(3):
                        # If the send successful exit, else retry three time
                        if self.send_file(path) is True:
                                break

        def show_dir(self, state):
                &#34;&#34;&#34; Indicates if the directory must show &#34;&#34;&#34;

def download(file=&#34;&#34;, recursive=False):
        &#34;&#34;&#34; Download file from device to computer &#34;&#34;&#34;
        if check_cam_flasher():
                tools.console.Console.print(&#34;Download from device start&#34;)
                try:
                        searchfile(file, recursive, Exporter())
                        tools.console.Console.print (&#34;Download end&#34;)
                except Exception as err:
                        tools.logger.syslog(err, display=False)
                        tools.console.Console.print(&#34;Download failed&#34;)
        else:
                tools.console.Console.print(&#34;CamFlasher application required for this command&#34;)

def temperature():
        &#34;&#34;&#34; Get the internal temperature &#34;&#34;&#34;
        celcius, farenheit = tools.info.temperature()
        tools.console.Console.print(&#34;%.2fÂ°C, %dÂ°F&#34;%(celcius, farenheit))

def meminfo():
        &#34;&#34;&#34; Get memory informations &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(b&#34;%s : %s&#34;%(tools.lang.memory_label, tools.info.meminfo())))

def flashinfo(mountpoint=None):
        &#34;&#34;&#34; Get flash informations &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(b&#34;%s : %s&#34;%(tools.lang.flash_info, tools.info.flashinfo(mountpoint=mountpoint))))

def sysinfo():
        &#34;&#34;&#34; Get system informations &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(tools.info.sysinfo()))

def vtcolors():
        &#34;&#34;&#34; Show all VT100 colors &#34;&#34;&#34;
        res = b&#39;\x1B[4m4 bits colors\x1B[m\n&#39;
        for i in range(16):
                if i % 8 == 0:
                        res += b&#34;\n  &#34;
                if i &lt; 9:
                        forecolor = 15
                else:
                        forecolor = 0
                res += b&#34;\x1B[38;5;%dm\x1B[48;5;%dm %2d \x1B[0m&#34;%(forecolor, i,i)
        res += b&#39;\n\n\x1B[4m8 bits colors\x1B[m\n&#39;
        j = 0
        for i in range(16,256):
                if j % 12== 0:
                        res += b&#34;\n  &#34;
                backcolor = i
                if j % 36 &lt; 36//2:
                        forecolor = 15
                else:
                        forecolor = 0
                res += b&#34;\x1B[38;5;%dm\x1B[48;5;%dm %3d \x1B[0m&#34;%(forecolor,backcolor,i)
                j += 1
        res += b&#39;\n\n\x1B[4mModifiers\x1B[m\n\n&#39;

        for i,j in [(0,&#34;reset/normal&#34;),(1,b&#34;bold&#34;),(3,b&#34;italic&#34;),(4,b&#34;underline&#34;),(7,b&#34;reverse&#34;)]:
                res += b&#34;  %d : \x1B[%dm%s\x1B[0m\n&#34;%(i,i,j)
        res += b&#39;\n\x1B[4mExamples\x1B[m\n\n&#39;
        res += b&#39;  &gt;&gt;&gt; print(&#34;\\033[\033[1m1\033[m;\033[7m7\033[mmBold reverse\\033[0m&#34;)\n&#39;
        res += b&#34;  \033[1;7mBold reverse\033[0m&#34;
        res += b&#34;\n\n&#34;
        res += b&#39;  &gt;&gt;&gt; print(&#34;\033[38;5;15m\033[48;5;1m\\033[48;5;1m\033[m\033[38;5;13m\\033[38;5;13m\033[mHello\\033[m&#34;)\n&#39;
        res += b&#34;  \033[48;5;1m\033[38;5;13mHello\033[m\n&#34;

        tools.console.Console.print(res.decode(&#34;utf8&#34;))

def get_command(command_name):
        &#34;&#34;&#34; Get a command callback according to the command name &#34;&#34;&#34;
        try:
                # pylint:disable=global-variable-not-assigned
                global shell_commands
                command = shell_commands[command_name]
                command_function = command[0]
                command_params = []
                command_flags  = []
                for item in command[1:]:
                        if type(item) == type(&#34;&#34;):
                                command_params.append(item)
                        if type(item) == type((0,)):
                                command_flags.append(item)
        except  Exception as err:
                # pylint: disable=raise-missing-from
                raise RuntimeError(&#34;Command not found &#39;%s&#39;&#34;%command_name)
        return command_name, command_function, command_params, command_flags

def exec_command(args):
        &#34;&#34;&#34; Execute command &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        command_name = &#34;&#34;
        command_function = None
        command_params = []
        command_flags = []
        output_redirection = None
        output_filename = None
        try:
                if len(args) &gt;= 1:
                        paramsCount = 0
                        flags   = {}
                        for arg in args:
                                arg = arg.strip()
                                if len(arg) &gt; 0:
                                        if command_name == &#34;&#34;:
                                                command_name, command_function, command_params, command_flags = get_command(arg)
                                        else:
                                                if len(arg) &gt;= 2 and arg[:2] == &#34;--&#34;:
                                                        for commandFlag in command_flags:
                                                                if arg.strip()[2:] == commandFlag[1].strip():
                                                                        flags[commandFlag[1]] = commandFlag[2]
                                                                        break
                                                        else:
                                                                raise RuntimeError(&#34;Illegal option &#39;%s&#39;&#34;%arg)
                                                elif arg[0] == &#34;-&#34;:
                                                        for commandFlag in command_flags:
                                                                if arg.strip() == commandFlag[0].strip():
                                                                        flags[commandFlag[1]] = commandFlag[2]
                                                                        break
                                                        else:
                                                                raise RuntimeError(&#34;Illegal option &#39;%s&#39;&#34;%arg)
                                                elif arg[0] == &#34;&gt;&#34;:
                                                        output_redirection = True
                                                else:
                                                        if output_redirection is None:
                                                                if paramsCount &gt;= len(command_params):
                                                                        raise RuntimeError(&#34;Too many parameters on &#39;%s&#39;&#34;%command_name)
                                                                else:
                                                                        flags[command_params[paramsCount]] = arg
                                                                        paramsCount += 1
                                                        elif output_redirection is True:
                                                                output_filename = arg

        except Exception as err:
                tools.console.Console.print(err)
                return
        tools.console.Console.close()
        try:
                if command_name.strip() != &#34;&#34;:
                        if output_filename is not None:
                                try:
                                        tools.console.Console.open(output_filename)
                                except:
                                        pass
                        command_function(**flags)
        except TypeError as err:
                tools.logger.syslog(err, display=False)
                tools.console.Console.print(&#34;Missing parameters for &#39;%s&#39;&#34;%command_name)
        except KeyboardInterrupt as err:
                tools.logger.syslog(err)
                tools.console.Console.print(&#34; [Canceled]&#34;)
        except Exception as err:
                tools.logger.syslog(err)
        finally:
                tools.console.Console.close()

def parse_command_line(commandLine):
        &#34;&#34;&#34; Parse command line &#34;&#34;&#34;
        commands_ = []
        args = []
        quote = None
        arg = &#34;&#34;
        for char in commandLine:
                if char == &#39;&#34;&#39; or char == &#34;&#39;&#34;:
                        if quote is not None:
                                if quote == char:
                                        args.append(arg)
                                        arg = &#34;&#34;
                                        quote = None
                                else:
                                        arg += char
                        else:
                                quote = char
                elif char == &#34; &#34;:
                        if quote is not None:
                                arg += char
                        else:
                                args.append(arg)
                                arg = &#34;&#34;
                elif char == &#34;;&#34;:
                        if quote is not None:
                                arg += char
                        else:
                                if len(arg) &gt; 0:
                                        args.append(arg)
                                commands_.append(args)
                                arg = &#34;&#34;
                                args = []
                else:
                        arg += char
        if len(arg) &gt; 0:
                args.append(arg)
        if len(args) &gt; 0:
                commands_.append(args)

        for command in commands_:
                exec_command(command)

def commands(path=None, throw=False):
        &#34;&#34;&#34; Start the shell &#34;&#34;&#34;
        global shell_exited, shell_commands
        current_dir = uos.getcwd()

        create_shell_commands()

        if path is not None:
                uos.chdir(path)

        shell_exited = False
        while shell_exited is False:
                try:
                        commandLine = &#34;&#34;
                        commandLine = input(&#34;%s=&gt; &#34;%os.getcwd())
                        tools.watchdog.WatchDog.feed()
                except EOFError:
                        tools.console.Console.print(&#34;&#34;)
                        break
                except KeyboardInterrupt:
                        tools.console.Console.print(&#34;Ctr-C detected, use &#39;exit&#39; to restart server or &#39;quit&#39; to get python prompt&#34;)

                if commandLine.strip() == &#34;quit&#34;:
                        if throw is True:
                                raise KeyboardInterrupt()
                        else:
                                break
                parse_command_line(commandLine)

        shell_commands = None
        uos.chdir(current_dir)

def create_shell_commands():
        &#34;&#34;&#34; Return the shell commands &#34;&#34;&#34;
        global shell_commands
        shell_commands = \
        {
                &#34;cd&#34;         :[cd              ,&#34;directory&#34;            ],
                &#34;pwd&#34;        :[pwd                                     ],
                &#34;cat&#34;        :[cat             ,&#34;file&#34;                 ],
                &#34;cls&#34;        :[cls                                     ],
                &#34;mkdir&#34;      :[mkdir           ,&#34;directory&#34;,             (&#34;-r&#34;,&#34;recursive&#34;,True)],
                &#34;mv&#34;         :[mv              ,&#34;source&#34;,&#34;destination&#34; ],
                &#34;rmdir&#34;      :[rmdir           ,&#34;directory&#34;,             (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-f&#34;,&#34;force&#34;,True),(&#34;-q&#34;,&#34;quiet&#34;,True),(&#34;-s&#34;,&#34;simulate&#34;,True)],
                &#34;cp&#34;         :[cp              ,&#34;source&#34;,&#34;destination&#34;,  (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-q&#34;,&#34;quiet&#34;,True)],
                &#34;rm&#34;         :[rm              ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-f&#34;,&#34;force&#34;,True),(&#34;-s&#34;,&#34;simulate&#34;,True)],
                &#34;ls&#34;         :[ls              ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-l&#34;,&#34;long&#34;,True)],
                &#34;ll&#34;         :[ll              ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True)],
                &#34;date&#34;       :[date_time       ,&#34;offsetUTC&#34; ,            (&#34;-u&#34;,&#34;update&#34;,True),   (&#34;-n&#34;,&#34;noDst&#34;,True)],
                &#34;setdate&#34;    :[setdate         ,&#34;datetime&#34;             ],
                &#34;uptime&#34;     :[uptime                                  ],
                &#34;find&#34;       :[find            ,&#34;file&#34;                 ],
                &#34;run&#34;        :[tools.useful.run      ,&#34;filename&#34;             ],
                &#34;download&#34;   :[download        ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True)],
                &#34;upload&#34;     :[upload          ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True)],
                &#34;edit&#34;       :[edit            ,&#34;file&#34;,                  (&#34;-n&#34;,&#34;no_color&#34;,True),(&#34;-r&#34;,&#34;read_only&#34;,True)],
                &#34;exit&#34;       :[exit                                    ],
                &#34;gc&#34;         :[gc                                      ],
                &#34;grep&#34;       :[grep            ,&#34;text&#34;,&#34;file&#34;,           (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-i&#34;,&#34;ignorecase&#34;,True),(&#34;-e&#34;,&#34;regexp&#34;,True)],
                &#34;mount&#34;      :[mountsd         ,&#34;mountpoint&#34;           ],
                &#34;umount&#34;     :[umountsd        ,&#34;mountpoint&#34;           ],
                &#34;temperature&#34;:[temperature                             ],
                &#34;meminfo&#34;    :[meminfo                                 ],
                &#34;flashinfo&#34;  :[flashinfo                               ],
                &#34;sysinfo&#34;    :[sysinfo                                 ],
                &#34;deepsleep&#34;  :[deepsleep       ,&#34;seconds&#34;              ],
                &#34;lightsleep&#34; :[ligthsleep      ,&#34;seconds&#34;              ],
                &#34;ping&#34;       :[ping            ,&#34;host&#34;                 ],
                &#34;reboot&#34;     :[reboot                                  ],
                &#34;help&#34;       :[help                                    ],
                &#34;man&#34;        :[man             ,&#34;command&#34;              ],
                &#34;memdump&#34;    :[tools.info.memdump                            ],
                &#34;df&#34;         :[df              ,&#34;mountpoint&#34;           ],
                &#34;ip2host&#34;    :[ip2host         ,&#34;ip_address&#34;           ],
                &#34;host2ip&#34;    :[host2ip         ,&#34;hostname&#34;             ],
                &#34;eval&#34;       :[eval_           ,&#34;string&#34;               ],
                &#34;exec&#34;       :[exec_           ,&#34;string&#34;               ],
                &#34;dump&#34;       :[dump_           ,&#34;filename&#34;             ],
                &#34;formatsd&#34;   :[formatsd        ,&#34;fstype&#34;               ],
                &#34;vtcolors&#34;   :[vtcolors                                ],
        }

if __name__ == &#34;__main__&#34;:
        tools.sh(sys.argv[1])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lib.shell.commands.cat"><code class="name flex">
<span>def <span class="ident">cat</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>Cat command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cat(file):
        &#34;&#34;&#34; Cat command &#34;&#34;&#34;
        try:
                f = open(file, &#34;r&#34;)
                height, width = get_screen_size()
                count = 1
                while 1:
                        line = f.readline()
                        if not line:
                                break
                        message = line.replace(&#34;\t&#34;,&#34;    &#34;).rstrip()[:width]
                        count = print_part(message, width, height, count)
                        if count is None:
                                break
                f.close()
        except:
                tools.console.Console.print(&#34;Cannot cat &#39;%s&#39;&#34;%(file))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.cd"><code class="name flex">
<span>def <span class="ident">cd</span></span>(<span>directory='/')</span>
</code></dt>
<dd>
<div class="desc"><p>Change directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cd(directory = &#34;/&#34;):
        &#34;&#34;&#34; Change directory &#34;&#34;&#34;
        try:
                uos.chdir(tools.filesystem.normpath(directory))
        except:
                if directory != &#34;.&#34;:
                        tools.console.Console.print(&#34;No such file or directory &#39;%s&#39;&#34;%directory)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.check_cam_flasher"><code class="name flex">
<span>def <span class="ident">check_cam_flasher</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the terminal is CamFlasher</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_cam_flasher():
        &#34;&#34;&#34; Check if the terminal is CamFlasher &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        if tools.console.Console.is_redirected() is False:
                # Request terminal device attribut
                sys.stdout.write(b&#34;\x1B[0c&#34;)

                # Wait terminal device attribut response
                response = tools.terminal.getch(duration=1000)

                # If CamFlasher detected
                if response == &#34;\x1B[?3;2c&#34;:
                        return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.cls"><code class="name flex">
<span>def <span class="ident">cls</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>clear screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cls():
        &#34;&#34;&#34; clear screen &#34;&#34;&#34;
        tools.console.Console.print(&#34;\x1B[2J\x1B[0;0f&#34;, end=&#34;&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.commands"><code class="name flex">
<span>def <span class="ident">commands</span></span>(<span>path=None, throw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the shell</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commands(path=None, throw=False):
        &#34;&#34;&#34; Start the shell &#34;&#34;&#34;
        global shell_exited, shell_commands
        current_dir = uos.getcwd()

        create_shell_commands()

        if path is not None:
                uos.chdir(path)

        shell_exited = False
        while shell_exited is False:
                try:
                        commandLine = &#34;&#34;
                        commandLine = input(&#34;%s=&gt; &#34;%os.getcwd())
                        tools.watchdog.WatchDog.feed()
                except EOFError:
                        tools.console.Console.print(&#34;&#34;)
                        break
                except KeyboardInterrupt:
                        tools.console.Console.print(&#34;Ctr-C detected, use &#39;exit&#39; to restart server or &#39;quit&#39; to get python prompt&#34;)

                if commandLine.strip() == &#34;quit&#34;:
                        if throw is True:
                                raise KeyboardInterrupt()
                        else:
                                break
                parse_command_line(commandLine)

        shell_commands = None
        uos.chdir(current_dir)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.copyfile"><code class="name flex">
<span>def <span class="ident">copyfile</span></span>(<span>src, dst, quiet)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copyfile(src,dst,quiet):
        &#34;&#34;&#34; Copy file &#34;&#34;&#34;
        dst = dst.replace(&#34;//&#34;,&#34;/&#34;)
        dst = dst.replace(&#34;//&#34;,&#34;/&#34;)
        dstdir, dstfile = tools.filesystem.split(dst)
        try:
                if not tools.filesystem.exists(dstdir):
                        if dstdir != &#34;.&#34; and dstdir != &#34;&#34;:
                                mkdir(dstdir, recursive=True, quiet=quiet)
                src_file = open(src, &#39;rb&#39;)
                dst_file = open(dst, &#39;wb&#39;)
                if quiet is False:
                        tools.console.Console.print(&#34;cp &#39;%s&#39; -&gt; &#39;%s&#39;&#34;%(src,dst))
                while True:
                        buf = src_file.read(256)
                        if len(buf) &gt; 0:
                                dst_file.write(buf)
                        if len(buf) &lt; 256:
                                break
                src_file.close()
                dst_file.close()
        except:
                tools.console.Console.print(&#34;Cannot cp &#39;%s&#39; -&gt; &#39;%s&#39;&#34;%(src, dst))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.cp"><code class="name flex">
<span>def <span class="ident">cp</span></span>(<span>source, destination, recursive=False, quiet=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy file command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cp(source, destination, recursive=False, quiet=False):
        &#34;&#34;&#34; Copy file command &#34;&#34;&#34;
        source = tools.filesystem.normpath(source)
        destination = tools.filesystem.normpath(destination)
        if tools.filesystem.isfile(source):
                copyfile(source,destination,quiet)
        else:
                if tools.filesystem.isdir(source):
                        path = source
                        pattern = &#34;*&#34;
                else:
                        path, pattern = tools.filesystem.split(source)

                _, filenames = tools.filesystem.scandir(path, pattern, recursive)

                for src in filenames:
                        dst = destination + &#34;/&#34; + src[len(path):]
                        copyfile(src,dst,quiet)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.create_shell_commands"><code class="name flex">
<span>def <span class="ident">create_shell_commands</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the shell commands</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_shell_commands():
        &#34;&#34;&#34; Return the shell commands &#34;&#34;&#34;
        global shell_commands
        shell_commands = \
        {
                &#34;cd&#34;         :[cd              ,&#34;directory&#34;            ],
                &#34;pwd&#34;        :[pwd                                     ],
                &#34;cat&#34;        :[cat             ,&#34;file&#34;                 ],
                &#34;cls&#34;        :[cls                                     ],
                &#34;mkdir&#34;      :[mkdir           ,&#34;directory&#34;,             (&#34;-r&#34;,&#34;recursive&#34;,True)],
                &#34;mv&#34;         :[mv              ,&#34;source&#34;,&#34;destination&#34; ],
                &#34;rmdir&#34;      :[rmdir           ,&#34;directory&#34;,             (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-f&#34;,&#34;force&#34;,True),(&#34;-q&#34;,&#34;quiet&#34;,True),(&#34;-s&#34;,&#34;simulate&#34;,True)],
                &#34;cp&#34;         :[cp              ,&#34;source&#34;,&#34;destination&#34;,  (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-q&#34;,&#34;quiet&#34;,True)],
                &#34;rm&#34;         :[rm              ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-f&#34;,&#34;force&#34;,True),(&#34;-s&#34;,&#34;simulate&#34;,True)],
                &#34;ls&#34;         :[ls              ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-l&#34;,&#34;long&#34;,True)],
                &#34;ll&#34;         :[ll              ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True)],
                &#34;date&#34;       :[date_time       ,&#34;offsetUTC&#34; ,            (&#34;-u&#34;,&#34;update&#34;,True),   (&#34;-n&#34;,&#34;noDst&#34;,True)],
                &#34;setdate&#34;    :[setdate         ,&#34;datetime&#34;             ],
                &#34;uptime&#34;     :[uptime                                  ],
                &#34;find&#34;       :[find            ,&#34;file&#34;                 ],
                &#34;run&#34;        :[tools.useful.run      ,&#34;filename&#34;             ],
                &#34;download&#34;   :[download        ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True)],
                &#34;upload&#34;     :[upload          ,&#34;file&#34;,                  (&#34;-r&#34;,&#34;recursive&#34;,True)],
                &#34;edit&#34;       :[edit            ,&#34;file&#34;,                  (&#34;-n&#34;,&#34;no_color&#34;,True),(&#34;-r&#34;,&#34;read_only&#34;,True)],
                &#34;exit&#34;       :[exit                                    ],
                &#34;gc&#34;         :[gc                                      ],
                &#34;grep&#34;       :[grep            ,&#34;text&#34;,&#34;file&#34;,           (&#34;-r&#34;,&#34;recursive&#34;,True),(&#34;-i&#34;,&#34;ignorecase&#34;,True),(&#34;-e&#34;,&#34;regexp&#34;,True)],
                &#34;mount&#34;      :[mountsd         ,&#34;mountpoint&#34;           ],
                &#34;umount&#34;     :[umountsd        ,&#34;mountpoint&#34;           ],
                &#34;temperature&#34;:[temperature                             ],
                &#34;meminfo&#34;    :[meminfo                                 ],
                &#34;flashinfo&#34;  :[flashinfo                               ],
                &#34;sysinfo&#34;    :[sysinfo                                 ],
                &#34;deepsleep&#34;  :[deepsleep       ,&#34;seconds&#34;              ],
                &#34;lightsleep&#34; :[ligthsleep      ,&#34;seconds&#34;              ],
                &#34;ping&#34;       :[ping            ,&#34;host&#34;                 ],
                &#34;reboot&#34;     :[reboot                                  ],
                &#34;help&#34;       :[help                                    ],
                &#34;man&#34;        :[man             ,&#34;command&#34;              ],
                &#34;memdump&#34;    :[tools.info.memdump                            ],
                &#34;df&#34;         :[df              ,&#34;mountpoint&#34;           ],
                &#34;ip2host&#34;    :[ip2host         ,&#34;ip_address&#34;           ],
                &#34;host2ip&#34;    :[host2ip         ,&#34;hostname&#34;             ],
                &#34;eval&#34;       :[eval_           ,&#34;string&#34;               ],
                &#34;exec&#34;       :[exec_           ,&#34;string&#34;               ],
                &#34;dump&#34;       :[dump_           ,&#34;filename&#34;             ],
                &#34;formatsd&#34;   :[formatsd        ,&#34;fstype&#34;               ],
                &#34;vtcolors&#34;   :[vtcolors                                ],
        }</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.date_time"><code class="name flex">
<span>def <span class="ident">date_time</span></span>(<span>update=False, offsetUTC=1, noDst=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get or set date</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_time(update=False, offsetUTC=+1, noDst=False):
        &#34;&#34;&#34; Get or set date &#34;&#34;&#34;
        try:
                from server.timesetting import set_date
                if update:
                        if noDst:
                                dst = False
                        else:
                                dst = True
                        set_date(offsetUTC, dst)
                del sys.modules[&#34;server.timesetting&#34;]
        except:
                pass
        tools.console.Console.print(tools.date.date_to_string())</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.deepsleep"><code class="name flex">
<span>def <span class="ident">deepsleep</span></span>(<span>seconds=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Deep sleep command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deepsleep(seconds=60):
        &#34;&#34;&#34; Deep sleep command &#34;&#34;&#34;
        machine.deepsleep(int(seconds)*1000)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.df"><code class="name flex">
<span>def <span class="ident">df</span></span>(<span>mountpoint=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Display free disk space</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def df(mountpoint = None):
        &#34;&#34;&#34; Display free disk space &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(tools.info.flashinfo(mountpoint=mountpoint)))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>file='', recursive=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Download file from device to computer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(file=&#34;&#34;, recursive=False):
        &#34;&#34;&#34; Download file from device to computer &#34;&#34;&#34;
        if check_cam_flasher():
                tools.console.Console.print(&#34;Download from device start&#34;)
                try:
                        searchfile(file, recursive, Exporter())
                        tools.console.Console.print (&#34;Download end&#34;)
                except Exception as err:
                        tools.logger.syslog(err, display=False)
                        tools.console.Console.print(&#34;Download failed&#34;)
        else:
                tools.console.Console.print(&#34;CamFlasher application required for this command&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.dump_"><code class="name flex">
<span>def <span class="ident">dump_</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>dump file content</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_(filename):
        &#34;&#34;&#34; dump file content &#34;&#34;&#34;
        height, width = get_screen_size()
        if tools.console.Console.is_redirected() is False:
                width = (width - 12)//4
        else:
                width = 16
        offset = 0
        file = open(filename, &#34;rb&#34;)
        data = b&#39; &#39;
        count = 1
        while True:
                line = io.BytesIO()
                line.write(b&#39;%08X  &#39; % offset)
                data = file.read(width)
                if len(data) &lt;= 0:
                        break
                tools.strings.dump_line (data, line, width)
                offset += width
                count = print_part(line.getvalue(), width, height, count)
                if count is None:
                        break</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.edit"><code class="name flex">
<span>def <span class="ident">edit</span></span>(<span>file, no_color=False, read_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Edit command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit(file, no_color=False, read_only=False):
        &#34;&#34;&#34; Edit command &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        global edit_class
        if tools.console.Console.is_redirected() is False:
                if edit_class is None:
                        try:
                                from shell.editor import Editor
                        except:
                                from editor import Editor
                        edit_class = Editor
                edit_class(file, no_color=no_color, read_only=read_only)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.eval_"><code class="name flex">
<span>def <span class="ident">eval_</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate content of string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_(string):
        &#34;&#34;&#34; Evaluate content of string &#34;&#34;&#34;
        tools.console.Console.print(eval(string))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.exec_"><code class="name flex">
<span>def <span class="ident">exec_</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute content of string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exec_(string):
        &#34;&#34;&#34; Execute content of string &#34;&#34;&#34;
        exec(string)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.exec_command"><code class="name flex">
<span>def <span class="ident">exec_command</span></span>(<span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exec_command(args):
        &#34;&#34;&#34; Execute command &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        command_name = &#34;&#34;
        command_function = None
        command_params = []
        command_flags = []
        output_redirection = None
        output_filename = None
        try:
                if len(args) &gt;= 1:
                        paramsCount = 0
                        flags   = {}
                        for arg in args:
                                arg = arg.strip()
                                if len(arg) &gt; 0:
                                        if command_name == &#34;&#34;:
                                                command_name, command_function, command_params, command_flags = get_command(arg)
                                        else:
                                                if len(arg) &gt;= 2 and arg[:2] == &#34;--&#34;:
                                                        for commandFlag in command_flags:
                                                                if arg.strip()[2:] == commandFlag[1].strip():
                                                                        flags[commandFlag[1]] = commandFlag[2]
                                                                        break
                                                        else:
                                                                raise RuntimeError(&#34;Illegal option &#39;%s&#39;&#34;%arg)
                                                elif arg[0] == &#34;-&#34;:
                                                        for commandFlag in command_flags:
                                                                if arg.strip() == commandFlag[0].strip():
                                                                        flags[commandFlag[1]] = commandFlag[2]
                                                                        break
                                                        else:
                                                                raise RuntimeError(&#34;Illegal option &#39;%s&#39;&#34;%arg)
                                                elif arg[0] == &#34;&gt;&#34;:
                                                        output_redirection = True
                                                else:
                                                        if output_redirection is None:
                                                                if paramsCount &gt;= len(command_params):
                                                                        raise RuntimeError(&#34;Too many parameters on &#39;%s&#39;&#34;%command_name)
                                                                else:
                                                                        flags[command_params[paramsCount]] = arg
                                                                        paramsCount += 1
                                                        elif output_redirection is True:
                                                                output_filename = arg

        except Exception as err:
                tools.console.Console.print(err)
                return
        tools.console.Console.close()
        try:
                if command_name.strip() != &#34;&#34;:
                        if output_filename is not None:
                                try:
                                        tools.console.Console.open(output_filename)
                                except:
                                        pass
                        command_function(**flags)
        except TypeError as err:
                tools.logger.syslog(err, display=False)
                tools.console.Console.print(&#34;Missing parameters for &#39;%s&#39;&#34;%command_name)
        except KeyboardInterrupt as err:
                tools.logger.syslog(err)
                tools.console.Console.print(&#34; [Canceled]&#34;)
        except Exception as err:
                tools.logger.syslog(err)
        finally:
                tools.console.Console.close()</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit shell command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit():
        &#34;&#34;&#34; Exit shell command &#34;&#34;&#34;
        global shell_exited
        shell_exited = True</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>file)</span>
</code></dt>
<dd>
<div class="desc"><p>Find a file in directories</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(file):
        &#34;&#34;&#34; Find a file in directories &#34;&#34;&#34;
        filenames = searchfile(file, True)
        for filename in filenames:
                tools.console.Console.print(filename)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.flashinfo"><code class="name flex">
<span>def <span class="ident">flashinfo</span></span>(<span>mountpoint=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get flash informations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flashinfo(mountpoint=None):
        &#34;&#34;&#34; Get flash informations &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(b&#34;%s : %s&#34;%(tools.lang.flash_info, tools.info.flashinfo(mountpoint=mountpoint))))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.formatsd"><code class="name flex">
<span>def <span class="ident">formatsd</span></span>(<span>fstype='FAT')</span>
</code></dt>
<dd>
<div class="desc"><p>Format sd card</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def formatsd(fstype=&#34;FAT&#34;):
        &#34;&#34;&#34; Format sd card &#34;&#34;&#34;
        if fstype in [&#34;FAT&#34;,&#34;LFS&#34;]:
                if tools.sdcard.SdCard.is_mounted() is False:
                        res = input(&#34;All data will be lost on Sd card ? proceed with format (y/n) :&#34;)
                        if res in [&#34;y&#34;,&#34;Y&#34;]:
                                if tools.sdcard.SdCard.formatsd() is True:
                                        tools.console.Console.print(&#34;Formatting terminated&#34;)
                                else:
                                        tools.console.Console.print(&#34;Formatting failed&#34;)
                else:
                        tools.console.Console.print(&#34;Sd card is mounted, a reboot required&#34;)
        else:
                tools.console.Console.print(&#34;Filesystem supported : FAT or LFS&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.gc"><code class="name flex">
<span>def <span class="ident">gc</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Garbage collector command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gc():
        &#34;&#34;&#34; Garbage collector command &#34;&#34;&#34;
        from gc import collect
        collect()</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.get_command"><code class="name flex">
<span>def <span class="ident">get_command</span></span>(<span>command_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a command callback according to the command name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_command(command_name):
        &#34;&#34;&#34; Get a command callback according to the command name &#34;&#34;&#34;
        try:
                # pylint:disable=global-variable-not-assigned
                global shell_commands
                command = shell_commands[command_name]
                command_function = command[0]
                command_params = []
                command_flags  = []
                for item in command[1:]:
                        if type(item) == type(&#34;&#34;):
                                command_params.append(item)
                        if type(item) == type((0,)):
                                command_flags.append(item)
        except  Exception as err:
                # pylint: disable=raise-missing-from
                raise RuntimeError(&#34;Command not found &#39;%s&#39;&#34;%command_name)
        return command_name, command_function, command_params, command_flags</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.get_screen_size"><code class="name flex">
<span>def <span class="ident">get_screen_size</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the screen size and check if output redirected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screen_size():
        &#34;&#34;&#34; Return the screen size and check if output redirected &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        if tools.console.Console.is_redirected() is False:
                height, width = tools.terminal.get_screen_size()
        else:
                height, width = tools.terminal.MAXINT, 80
        return height, width</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.grep"><code class="name flex">
<span>def <span class="ident">grep</span></span>(<span>file, text, recursive=False, ignorecase=False, regexp=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Grep command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grep(file, text, recursive=False, ignorecase=False, regexp=False):
        &#34;&#34;&#34; Grep command &#34;&#34;&#34;
        from re import search
        file = tools.filesystem.normpath(file)
        def __search(text, content, ignorecase, regexp):
                if ignorecase:
                        content  = content.lower()
                        text = text.lower()
                if regexp:
                        if search(text, content):
                                return True
                else:
                        if content.find(text) != -1:
                                return True
                return False

        def __grep(text, filename, ignorecase, regexp, width, height, count):
                lineNumber = 1
                with open(filename,&#34;r&#34;, encoding=&#34;latin-1&#34;) as f:
                        while 1:
                                line = f.readline()
                                if line:
                                        if __search(text, line, ignorecase, regexp):
                                                line = line.replace(&#34;\t&#34;,&#34;    &#34;)
                                                message = &#34;%s:%d:%s&#34;%(filename, lineNumber, line)
                                                message = message.rstrip()[:width]
                                                count = print_part(message, width, height, count)
                                                if count is None:
                                                        tools.console.Console.print(&#34;&#34;)
                                                        return None
                                        lineNumber += 1
                                else:
                                        break
                return count

        if tools.filesystem.isfile(file):
                filenames = [file]
        else:
                path, pattern = tools.filesystem.split(file)
                _, filenames = tools.filesystem.scandir(path, pattern, recursive)

        height, width = get_screen_size()
        count = 1
        for filename in filenames:
                count = __grep(text, filename, ignorecase, regexp, width, height, count)
                if count is None:
                        break</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.help"><code class="name flex">
<span>def <span class="ident">help</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Help command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def help():
        &#34;&#34;&#34; Help command &#34;&#34;&#34;
        height, width = get_screen_size()
        count = 1
        cmds = list(shell_commands.keys())
        cmds.sort()
        for command in cmds:
                lines = man_one(command)
                lines = &#34;-&#34;*30+&#34;\n&#34; + lines
                for line in lines.split(&#34;\n&#34;):
                        count = print_part(line, width, height, count)
                        if count is None:
                                return</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.host2ip"><code class="name flex">
<span>def <span class="ident">host2ip</span></span>(<span>hostname)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert hostname to ip</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def host2ip(hostname):
        &#34;&#34;&#34; Convert hostname to ip &#34;&#34;&#34;
        try:
                import wifi.station
                _, _, _, dns = wifi.station.Station.get_info()
                from server.dnsclient import resolve_ip_address
                tools.console.Console.print(resolve_ip_address(dns, hostname))
        except:
                tools.console.Console.print(&#34;Not available&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.ip2host"><code class="name flex">
<span>def <span class="ident">ip2host</span></span>(<span>ip_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert ip to hostname</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ip2host(ip_address):
        &#34;&#34;&#34; Convert ip to hostname &#34;&#34;&#34;
        try:
                import wifi.station
                _, _, _, dns = wifi.station.Station.get_info()
                from server.dnsclient import resolve_hostname
                tools.console.Console.print(resolve_hostname(dns, ip_address))
        except:
                tools.console.Console.print(&#34;Not available&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.ligthsleep"><code class="name flex">
<span>def <span class="ident">ligthsleep</span></span>(<span>seconds=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Light sleep command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ligthsleep(seconds=60):
        &#34;&#34;&#34; Light sleep command &#34;&#34;&#34;
        machine.lightsleep(int(seconds)*1000)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.ll"><code class="name flex">
<span>def <span class="ident">ll</span></span>(<span>file='', recursive=False)</span>
</code></dt>
<dd>
<div class="desc"><p>List files long command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ll(file=&#34;&#34;, recursive=False):
        &#34;&#34;&#34; List files long command &#34;&#34;&#34;
        searchfile(file, recursive, LsDisplayer(uos.getcwd(), True, True))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.ls"><code class="name flex">
<span>def <span class="ident">ls</span></span>(<span>file='', recursive=False, long=False)</span>
</code></dt>
<dd>
<div class="desc"><p>List files command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ls(file=&#34;&#34;, recursive=False, long=False):
        &#34;&#34;&#34; List files command &#34;&#34;&#34;
        searchfile(file, recursive, LsDisplayer(uos.getcwd(), True, long))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.man"><code class="name flex">
<span>def <span class="ident">man</span></span>(<span>command)</span>
</code></dt>
<dd>
<div class="desc"><p>Man command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def man(command):
        &#34;&#34;&#34; Man command &#34;&#34;&#34;
        tools.console.Console.print(man_one(command))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.man_one"><code class="name flex">
<span>def <span class="ident">man_one</span></span>(<span>command_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Manual of one command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def man_one(command_name):
        &#34;&#34;&#34; Manual of one command &#34;&#34;&#34;
        try:
                command_name, command_function, command_params, command_flags = get_command(command_name)
                text = &#34;  &#34; + command_name + &#34; &#34;
                for param in command_params:
                        text += param + &#34; &#34;
                text += &#34;\n&#34;
                for flag,flagName,val in command_flags:
                        text += &#34;    %s : %s\n&#34;%(flag,flagName)
                result = text[:-1]
        except:
                result = &#34;Unknown command &#39;%s&#39;&#34;%command_name
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.meminfo"><code class="name flex">
<span>def <span class="ident">meminfo</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get memory informations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meminfo():
        &#34;&#34;&#34; Get memory informations &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(b&#34;%s : %s&#34;%(tools.lang.memory_label, tools.info.meminfo())))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.mkdir"><code class="name flex">
<span>def <span class="ident">mkdir</span></span>(<span>directory, recursive=False, quiet=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Make directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mkdir(directory, recursive=False, quiet=False):
        &#34;&#34;&#34; Make directory &#34;&#34;&#34;
        try:
                if quiet is False:
                        tools.console.Console.print(&#34;mkdir &#39;%s&#39;&#34;%directory)
                tools.filesystem.makedir(tools.filesystem.normpath(directory), recursive)
        except:
                tools.console.Console.print(&#34;Cannot mkdir &#39;%s&#39;&#34;%directory)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.mountsd"><code class="name flex">
<span>def <span class="ident">mountsd</span></span>(<span>mountpoint='/sd')</span>
</code></dt>
<dd>
<div class="desc"><p>Mount command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mountsd(mountpoint=&#34;/sd&#34;):
        &#34;&#34;&#34; Mount command &#34;&#34;&#34;
        try:
                tools.sdcard.SdCard.mount(mountpoint)
                tools.console.Console.print(&#34;Sd mounted on &#39;%s&#39;&#34;%mountpoint)
        except:
                tools.console.Console.print(&#34;Cannot mount sd on &#39;%s&#39;&#34;%mountpoint)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.mv"><code class="name flex">
<span>def <span class="ident">mv</span></span>(<span>source, destination)</span>
</code></dt>
<dd>
<div class="desc"><p>Move or rename file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mv(source, destination):
        &#34;&#34;&#34; Move or rename file &#34;&#34;&#34;
        try:
                uos.rename(tools.filesystem.normpath(source),tools.filesystem.normpath(destination))
        except:
                tools.console.Console.print(&#34;Cannot mv &#39;%s&#39;-&gt;&#39;%s&#39;&#34;%(source,destination))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.parse_command_line"><code class="name flex">
<span>def <span class="ident">parse_command_line</span></span>(<span>commandLine)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse command line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_command_line(commandLine):
        &#34;&#34;&#34; Parse command line &#34;&#34;&#34;
        commands_ = []
        args = []
        quote = None
        arg = &#34;&#34;
        for char in commandLine:
                if char == &#39;&#34;&#39; or char == &#34;&#39;&#34;:
                        if quote is not None:
                                if quote == char:
                                        args.append(arg)
                                        arg = &#34;&#34;
                                        quote = None
                                else:
                                        arg += char
                        else:
                                quote = char
                elif char == &#34; &#34;:
                        if quote is not None:
                                arg += char
                        else:
                                args.append(arg)
                                arg = &#34;&#34;
                elif char == &#34;;&#34;:
                        if quote is not None:
                                arg += char
                        else:
                                if len(arg) &gt; 0:
                                        args.append(arg)
                                commands_.append(args)
                                arg = &#34;&#34;
                                args = []
                else:
                        arg += char
        if len(arg) &gt; 0:
                args.append(arg)
        if len(args) &gt; 0:
                commands_.append(args)

        for command in commands_:
                exec_command(command)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>host)</span>
</code></dt>
<dd>
<div class="desc"><p>Ping host</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(host):
        &#34;&#34;&#34; Ping host &#34;&#34;&#34;
        try:
                from server.ping import ping as ping_
                ping_(host, count=4, timeout=1)
        except:
                tools.console.Console.print(&#34;Not available&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.print_part"><code class="name flex">
<span>def <span class="ident">print_part</span></span>(<span>message, width, height, count)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a part of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_part(message, width, height, count):
        &#34;&#34;&#34; Print a part of text &#34;&#34;&#34;
        # pylint:disable=global-variable-not-assigned
        if isinstance(message , bytes):
                message = message.decode(&#34;utf8&#34;)
        if count is not None and count &gt;= height:
                tools.console.Console.print(message,end=&#34;&#34;)
                if tools.console.Console.is_redirected() is False:
                        key = tools.terminal.getch()
                else:
                        key = &#34; &#34;
                count = 1
                if key in [&#34;x&#34;,&#34;X&#34;,&#34;q&#34;,&#34;Q&#34;,&#34;\x1B&#34;]:
                        return None
                tools.console.Console.print(&#34;\n&#34;, end=&#34;&#34;)
        else:
                if count is None:
                        count = 1
                else:
                        count += 1
                tools.console.Console.print(message)
        return count</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.pwd"><code class="name flex">
<span>def <span class="ident">pwd</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the current directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pwd():
        &#34;&#34;&#34; Display the current directory &#34;&#34;&#34;
        tools.console.Console.print(&#34;%s&#34;%uos.getcwd())</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.reboot"><code class="name flex">
<span>def <span class="ident">reboot</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Reboot command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reboot():
        &#34;&#34;&#34; Reboot command &#34;&#34;&#34;
        try:
                tools.system.reboot(&#34;Reboot device with command&#34;)
        except:
                machine.deepsleep(1000)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.removedir"><code class="name flex">
<span>def <span class="ident">removedir</span></span>(<span>directory, force=False, quiet=False, simulate=False, ignore_error=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removedir(directory, force=False, quiet=False, simulate=False, ignore_error=False):
        &#34;&#34;&#34; Remove directory &#34;&#34;&#34;
        try:
                if tools.filesystem.exists(directory+&#34;/.DS_Store&#34;):
                        rmfile(directory+&#34;/.DS_Store&#34;, quiet, force, simulate)
                if (tools.filesystem.ismicropython() or force) and simulate is False:
                        uos.rmdir(directory)
                if quiet is False:
                        tools.console.Console.print(&#34;rmdir &#39;%s&#39;&#34;%(directory))
        except:
                if ignore_error is False:
                        tools.console.Console.print(&#34;rmdir &#39;%s&#39; not removed&#34;%(directory))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.rm"><code class="name flex">
<span>def <span class="ident">rm</span></span>(<span>file, recursive=False, quiet=False, force=False, simulate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove file command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm(file, recursive=False, quiet=False, force=False, simulate=False):
        &#34;&#34;&#34; Remove file command &#34;&#34;&#34;
        file = tools.filesystem.normpath(file)
        filenames   = []
        directories = []

        if tools.filesystem.isfile(file):
                path = file
                rmfile(file, force=force, quiet=quiet, simulate=simulate)
        else:
                if tools.filesystem.isdir(file):
                        if recursive:
                                directories.append(file)
                                path = file
                                pattern = &#34;*&#34;
                        else:
                                path = None
                                pattern = None
                else:
                        path, pattern = tools.filesystem.split(file)

                if path is None:
                        tools.console.Console.print(&#34;Cannot rm &#39;%s&#39;&#34;%file)
                else:
                        dirs, filenames = tools.filesystem.scandir(path, pattern, recursive)
                        directories += dirs

                        for filename in filenames:
                                rmfile(filename, force=force, quiet=quiet, simulate=simulate)

                        if recursive:
                                directories.sort()
                                directories.reverse()

                                for directory in directories:
                                        rmdir(directory, recursive=recursive, force=force, quiet=quiet, simulate=simulate, ignore_error=True)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.rmdir"><code class="name flex">
<span>def <span class="ident">rmdir</span></span>(<span>directory, recursive=False, force=False, quiet=False, simulate=False, ignore_error=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmdir(directory, recursive=False, force=False, quiet=False, simulate=False, ignore_error=False):
        &#34;&#34;&#34; Remove directory &#34;&#34;&#34;
        directory = tools.filesystem.normpath(directory)
        if recursive is False:
                removedir(directory, force=force, quiet=quiet, simulate=simulate, ignore_error=ignore_error)
        else:
                directories = [directory]
                d = directory
                while 1:
                        parts = tools.filesystem.split(d)
                        if parts[1] == &#34;&#34; or parts[0] == &#34;&#34;:
                                break
                        directories.append(parts[0])
                        d = parts[0]
                if &#34;/&#34; in directories:
                        directories.remove(&#34;/&#34;)
                if tools.sdcard.SdCard.get_mountpoint() in directories:
                        directories.remove(tools.sdcard.SdCard.get_mountpoint())
                for d in directories:
                        if tools.filesystem.exists(d) and d != &#34;.&#34;:
                                removedir(d, force=force, quiet=quiet, simulate=simulate, ignore_error=ignore_error)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.rmfile"><code class="name flex">
<span>def <span class="ident">rmfile</span></span>(<span>filename, quiet=False, force=False, simulate=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rmfile(filename, quiet=False, force=False, simulate=False):
        &#34;&#34;&#34; Remove file &#34;&#34;&#34;
        try:
                if (tools.filesystem.ismicropython() or force) and simulate is False:
                        uos.remove(tools.filesystem.normpath(filename))
                if quiet is False:
                        tools.console.Console.print(&#34;rm &#39;%s&#39;&#34;%(filename))
        except:
                tools.console.Console.print(&#34;rm &#39;%s&#39; not removed&#34;%(filename))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.searchfile"><code class="name flex">
<span>def <span class="ident">searchfile</span></span>(<span>file, recursive, obj=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Search file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def searchfile(file, recursive, obj = None):
        &#34;&#34;&#34; Search file &#34;&#34;&#34;
        file = tools.filesystem.normpath(file)
        p = tools.filesystem.abspath(uos.getcwd(), file)
        filenames = []
        try:
                if file == &#34;&#34;:
                        _,filenames = tools.filesystem.scandir(uos.getcwd(), &#34;*&#34;, recursive, obj)
                elif tools.filesystem.isfile(p):
                        if obj is not None:
                                obj.show_dir(False)
                                obj.show(p)
                        filenames = [p]
                elif tools.filesystem.isdir(p):
                        _, filenames = tools.filesystem.scandir(p, &#34;*&#34;, recursive, obj)
                else:
                        path, pattern = tools.filesystem.split(p)
                        if obj is not None:
                                obj.show_dir(False)
                        _, filenames = tools.filesystem.scandir(path, pattern, recursive, obj)
        except Exception as err:
                tools.console.Console.print(err)
        if len(filenames) == 0 and file != &#34;&#34; and file != &#34;.&#34;:
                tools.console.Console.print(&#34;%s : No such file or directory&#34;%file)
        return filenames</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.setdate"><code class="name flex">
<span>def <span class="ident">setdate</span></span>(<span>datetime='')</span>
</code></dt>
<dd>
<div class="desc"><p>Set date and time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setdate(datetime=&#34;&#34;):
        &#34;&#34;&#34; Set date and time &#34;&#34;&#34;
        import re
        file_date=re.compile(&#34;[/: ]&#34;)
        failed = False
        try:
                spls = file_date.split(datetime)

                lst = []
                if len(spls) &gt; 1:
                        for spl in spls:
                                if len(spl) &gt; 0:
                                        try:
                                                r = spl.lstrip(&#34;0&#34;)
                                                if len(r) == 0:
                                                        lst.append(0)
                                                else:
                                                        lst.append(eval(r))
                                        except:
                                                failed = True
                                                break
                        if len(lst) == 6:
                                # pylint: disable=unbalanced-tuple-unpacking
                                year,month,day,hour,minute,second = lst
                                machine.RTC().datetime((year, month, day, 0, hour, minute, second, 0))
                        else:
                                failed = True
                else:
                        failed = True
        except Exception as err:
                failed = True
                tools.logger.syslog(err)

        if failed is True:
                tools.console.Console.print(&#39;Expected format &#34;YYYY/MM/DD hh:mm:ss&#34;&#39;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.sysinfo"><code class="name flex">
<span>def <span class="ident">sysinfo</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get system informations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sysinfo():
        &#34;&#34;&#34; Get system informations &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(tools.info.sysinfo()))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.temperature"><code class="name flex">
<span>def <span class="ident">temperature</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the internal temperature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temperature():
        &#34;&#34;&#34; Get the internal temperature &#34;&#34;&#34;
        celcius, farenheit = tools.info.temperature()
        tools.console.Console.print(&#34;%.2fÂ°C, %dÂ°F&#34;%(celcius, farenheit))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.umountsd"><code class="name flex">
<span>def <span class="ident">umountsd</span></span>(<span>mountpoint='/sd')</span>
</code></dt>
<dd>
<div class="desc"><p>Umount command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def umountsd(mountpoint=&#34;/sd&#34;):
        &#34;&#34;&#34; Umount command &#34;&#34;&#34;
        try:
                tools.sdcard.SdCard.umount(mountpoint)
                tools.console.Console.print(&#34;Sd umounted from &#39;%s&#39;&#34;%mountpoint)
        except:
                tools.console.Console.print(&#34;Cannot umount sd from &#39;%s&#39;&#34;%mountpoint)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>file='', recursive=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload file from computer to device</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(file=&#34;&#34;, recursive=False):
        &#34;&#34;&#34; Upload file from computer to device &#34;&#34;&#34;
        if check_cam_flasher():
                tools.console.Console.print(&#34;Upload to device start&#34;)
                try:
                        command = tools.exchange.UploadCommand(uos.getcwd())
                        command.write(file, recursive, sys.stdin.buffer, sys.stdout.buffer)
                        result = True
                        while result:
                                file_reader = tools.exchange.FileReader()
                                result = file_reader.read(uos.getcwd(), sys.stdin.buffer, sys.stdout.buffer)
                                tools.watchdog.WatchDog.feed()
                        tools.console.Console.print(&#34;Upload end&#34;)
                except Exception as err:
                        tools.logger.syslog(err, display=False)
                        tools.console.Console.print(&#34;Upload failed&#34;)
        else:
                tools.console.Console.print(&#34;CamFlasher application required for this command&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.uptime"><code class="name flex">
<span>def <span class="ident">uptime</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Tell how long the system has been running</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uptime():
        &#34;&#34;&#34; Tell how long the system has been running &#34;&#34;&#34;
        tools.console.Console.print(tools.strings.tostrings(tools.info.uptime()))</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.vtcolors"><code class="name flex">
<span>def <span class="ident">vtcolors</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Show all VT100 colors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vtcolors():
        &#34;&#34;&#34; Show all VT100 colors &#34;&#34;&#34;
        res = b&#39;\x1B[4m4 bits colors\x1B[m\n&#39;
        for i in range(16):
                if i % 8 == 0:
                        res += b&#34;\n  &#34;
                if i &lt; 9:
                        forecolor = 15
                else:
                        forecolor = 0
                res += b&#34;\x1B[38;5;%dm\x1B[48;5;%dm %2d \x1B[0m&#34;%(forecolor, i,i)
        res += b&#39;\n\n\x1B[4m8 bits colors\x1B[m\n&#39;
        j = 0
        for i in range(16,256):
                if j % 12== 0:
                        res += b&#34;\n  &#34;
                backcolor = i
                if j % 36 &lt; 36//2:
                        forecolor = 15
                else:
                        forecolor = 0
                res += b&#34;\x1B[38;5;%dm\x1B[48;5;%dm %3d \x1B[0m&#34;%(forecolor,backcolor,i)
                j += 1
        res += b&#39;\n\n\x1B[4mModifiers\x1B[m\n\n&#39;

        for i,j in [(0,&#34;reset/normal&#34;),(1,b&#34;bold&#34;),(3,b&#34;italic&#34;),(4,b&#34;underline&#34;),(7,b&#34;reverse&#34;)]:
                res += b&#34;  %d : \x1B[%dm%s\x1B[0m\n&#34;%(i,i,j)
        res += b&#39;\n\x1B[4mExamples\x1B[m\n\n&#39;
        res += b&#39;  &gt;&gt;&gt; print(&#34;\\033[\033[1m1\033[m;\033[7m7\033[mmBold reverse\\033[0m&#34;)\n&#39;
        res += b&#34;  \033[1;7mBold reverse\033[0m&#34;
        res += b&#34;\n\n&#34;
        res += b&#39;  &gt;&gt;&gt; print(&#34;\033[38;5;15m\033[48;5;1m\\033[48;5;1m\033[m\033[38;5;13m\\033[38;5;13m\033[mHello\\033[m&#34;)\n&#39;
        res += b&#34;  \033[48;5;1m\033[38;5;13mHello\033[m\n&#34;

        tools.console.Console.print(res.decode(&#34;utf8&#34;))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.shell.commands.Exporter"><code class="flex name class">
<span>class <span class="ident">Exporter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Exporter file to camflasher </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Exporter:
        &#34;&#34;&#34; Exporter file to camflasher &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;

        def send_file(self, path):
                &#34;&#34;&#34; Send the file &#34;&#34;&#34;
                result = True
                fileinfo = tools.filesystem.fileinfo(path)

                # If a file
                if fileinfo[0] &amp; 0x4000 != 0x4000:
                        file_write = tools.exchange.FileWriter()
                        if tools.filesystem.exists(path):
                                sys.stdout.buffer.write(&#34;à¿Š&#34;.encode(&#34;utf8&#34;))
                                result = file_write.write(path, sys.stdin.buffer, sys.stdout.buffer)
                                tools.watchdog.WatchDog.feed()
                return result

        def show(self, path):
                &#34;&#34;&#34; Show the information of a file or directory &#34;&#34;&#34;
                for _ in range(3):
                        # If the send successful exit, else retry three time
                        if self.send_file(path) is True:
                                break

        def show_dir(self, state):
                &#34;&#34;&#34; Indicates if the directory must show &#34;&#34;&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.commands.Exporter.send_file"><code class="name flex">
<span>def <span class="ident">send_file</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Send the file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_file(self, path):
        &#34;&#34;&#34; Send the file &#34;&#34;&#34;
        result = True
        fileinfo = tools.filesystem.fileinfo(path)

        # If a file
        if fileinfo[0] &amp; 0x4000 != 0x4000:
                file_write = tools.exchange.FileWriter()
                if tools.filesystem.exists(path):
                        sys.stdout.buffer.write(&#34;à¿Š&#34;.encode(&#34;utf8&#34;))
                        result = file_write.write(path, sys.stdin.buffer, sys.stdout.buffer)
                        tools.watchdog.WatchDog.feed()
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.Exporter.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the information of a file or directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, path):
        &#34;&#34;&#34; Show the information of a file or directory &#34;&#34;&#34;
        for _ in range(3):
                # If the send successful exit, else retry three time
                if self.send_file(path) is True:
                        break</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.Exporter.show_dir"><code class="name flex">
<span>def <span class="ident">show_dir</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the directory must show</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_dir(self, state):
        &#34;&#34;&#34; Indicates if the directory must show &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.shell.commands.LsDisplayer"><code class="flex name class">
<span>class <span class="ident">LsDisplayer</span></span>
<span>(</span><span>path, showdir, long)</span>
</code></dt>
<dd>
<div class="desc"><p>Ls displayer class </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LsDisplayer:
        &#34;&#34;&#34; Ls displayer class &#34;&#34;&#34;
        def __init__(self, path, showdir, long):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.height, self.width = get_screen_size()
                self.count = 1
                self.long = long
                self.path = path
                self.showdir = showdir

        def purge_path(self, path):
                &#34;&#34;&#34; Purge the path for the display &#34;&#34;&#34;
                path = path.encode(&#34;utf8&#34;)
                path = tools.filesystem.normpath(path)
                prefix = tools.filesystem.prefix([path, self.path.encode(&#34;utf8&#34;)])
                return path[len(prefix):].lstrip(b&#34;/&#34;)

        def show(self, path):
                &#34;&#34;&#34; Show the information of a file or directory &#34;&#34;&#34;
                fileinfo = tools.filesystem.fileinfo(path)
                file_date = fileinfo[8]
                size = fileinfo[6]

                # If directory
                if fileinfo[0] &amp; 0x4000 == 0x4000:
                        if self.showdir:
                                if self.long:
                                        message = b&#34;%s %s [%s]&#34;%(tools.date.date_to_bytes(file_date),b&#34; &#34;*7,self.purge_path(path))
                                else:
                                        message = b&#34;[%s]&#34;%self.purge_path(path)
                                self.count = print_part(message, self.width, self.height, self.count)
                else:
                        if self.long:
                                fileinfo = tools.filesystem.fileinfo(path)
                                file_date = fileinfo[8]
                                size = fileinfo[6]
                                message = b&#34;%s %s %s&#34;%(tools.date.date_to_bytes(file_date),tools.strings.size_to_bytes(size),self.purge_path(path))
                        else:
                                message = self.purge_path(path)
                        self.count = print_part(message, self.width, self.height, self.count)

        def show_dir(self, state):
                &#34;&#34;&#34; Indicates if the directory must show &#34;&#34;&#34;
                self.showdir = state</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.commands.LsDisplayer.purge_path"><code class="name flex">
<span>def <span class="ident">purge_path</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Purge the path for the display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge_path(self, path):
        &#34;&#34;&#34; Purge the path for the display &#34;&#34;&#34;
        path = path.encode(&#34;utf8&#34;)
        path = tools.filesystem.normpath(path)
        prefix = tools.filesystem.prefix([path, self.path.encode(&#34;utf8&#34;)])
        return path[len(prefix):].lstrip(b&#34;/&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.LsDisplayer.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the information of a file or directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, path):
        &#34;&#34;&#34; Show the information of a file or directory &#34;&#34;&#34;
        fileinfo = tools.filesystem.fileinfo(path)
        file_date = fileinfo[8]
        size = fileinfo[6]

        # If directory
        if fileinfo[0] &amp; 0x4000 == 0x4000:
                if self.showdir:
                        if self.long:
                                message = b&#34;%s %s [%s]&#34;%(tools.date.date_to_bytes(file_date),b&#34; &#34;*7,self.purge_path(path))
                        else:
                                message = b&#34;[%s]&#34;%self.purge_path(path)
                        self.count = print_part(message, self.width, self.height, self.count)
        else:
                if self.long:
                        fileinfo = tools.filesystem.fileinfo(path)
                        file_date = fileinfo[8]
                        size = fileinfo[6]
                        message = b&#34;%s %s %s&#34;%(tools.date.date_to_bytes(file_date),tools.strings.size_to_bytes(size),self.purge_path(path))
                else:
                        message = self.purge_path(path)
                self.count = print_part(message, self.width, self.height, self.count)</code></pre>
</details>
</dd>
<dt id="lib.shell.commands.LsDisplayer.show_dir"><code class="name flex">
<span>def <span class="ident">show_dir</span></span>(<span>self, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the directory must show</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_dir(self, state):
        &#34;&#34;&#34; Indicates if the directory must show &#34;&#34;&#34;
        self.showdir = state</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.shell" href="index.html">lib.shell</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lib.shell.commands.cat" href="#lib.shell.commands.cat">cat</a></code></li>
<li><code><a title="lib.shell.commands.cd" href="#lib.shell.commands.cd">cd</a></code></li>
<li><code><a title="lib.shell.commands.check_cam_flasher" href="#lib.shell.commands.check_cam_flasher">check_cam_flasher</a></code></li>
<li><code><a title="lib.shell.commands.cls" href="#lib.shell.commands.cls">cls</a></code></li>
<li><code><a title="lib.shell.commands.commands" href="#lib.shell.commands.commands">commands</a></code></li>
<li><code><a title="lib.shell.commands.copyfile" href="#lib.shell.commands.copyfile">copyfile</a></code></li>
<li><code><a title="lib.shell.commands.cp" href="#lib.shell.commands.cp">cp</a></code></li>
<li><code><a title="lib.shell.commands.create_shell_commands" href="#lib.shell.commands.create_shell_commands">create_shell_commands</a></code></li>
<li><code><a title="lib.shell.commands.date_time" href="#lib.shell.commands.date_time">date_time</a></code></li>
<li><code><a title="lib.shell.commands.deepsleep" href="#lib.shell.commands.deepsleep">deepsleep</a></code></li>
<li><code><a title="lib.shell.commands.df" href="#lib.shell.commands.df">df</a></code></li>
<li><code><a title="lib.shell.commands.download" href="#lib.shell.commands.download">download</a></code></li>
<li><code><a title="lib.shell.commands.dump_" href="#lib.shell.commands.dump_">dump_</a></code></li>
<li><code><a title="lib.shell.commands.edit" href="#lib.shell.commands.edit">edit</a></code></li>
<li><code><a title="lib.shell.commands.eval_" href="#lib.shell.commands.eval_">eval_</a></code></li>
<li><code><a title="lib.shell.commands.exec_" href="#lib.shell.commands.exec_">exec_</a></code></li>
<li><code><a title="lib.shell.commands.exec_command" href="#lib.shell.commands.exec_command">exec_command</a></code></li>
<li><code><a title="lib.shell.commands.exit" href="#lib.shell.commands.exit">exit</a></code></li>
<li><code><a title="lib.shell.commands.find" href="#lib.shell.commands.find">find</a></code></li>
<li><code><a title="lib.shell.commands.flashinfo" href="#lib.shell.commands.flashinfo">flashinfo</a></code></li>
<li><code><a title="lib.shell.commands.formatsd" href="#lib.shell.commands.formatsd">formatsd</a></code></li>
<li><code><a title="lib.shell.commands.gc" href="#lib.shell.commands.gc">gc</a></code></li>
<li><code><a title="lib.shell.commands.get_command" href="#lib.shell.commands.get_command">get_command</a></code></li>
<li><code><a title="lib.shell.commands.get_screen_size" href="#lib.shell.commands.get_screen_size">get_screen_size</a></code></li>
<li><code><a title="lib.shell.commands.grep" href="#lib.shell.commands.grep">grep</a></code></li>
<li><code><a title="lib.shell.commands.help" href="#lib.shell.commands.help">help</a></code></li>
<li><code><a title="lib.shell.commands.host2ip" href="#lib.shell.commands.host2ip">host2ip</a></code></li>
<li><code><a title="lib.shell.commands.ip2host" href="#lib.shell.commands.ip2host">ip2host</a></code></li>
<li><code><a title="lib.shell.commands.ligthsleep" href="#lib.shell.commands.ligthsleep">ligthsleep</a></code></li>
<li><code><a title="lib.shell.commands.ll" href="#lib.shell.commands.ll">ll</a></code></li>
<li><code><a title="lib.shell.commands.ls" href="#lib.shell.commands.ls">ls</a></code></li>
<li><code><a title="lib.shell.commands.man" href="#lib.shell.commands.man">man</a></code></li>
<li><code><a title="lib.shell.commands.man_one" href="#lib.shell.commands.man_one">man_one</a></code></li>
<li><code><a title="lib.shell.commands.meminfo" href="#lib.shell.commands.meminfo">meminfo</a></code></li>
<li><code><a title="lib.shell.commands.mkdir" href="#lib.shell.commands.mkdir">mkdir</a></code></li>
<li><code><a title="lib.shell.commands.mountsd" href="#lib.shell.commands.mountsd">mountsd</a></code></li>
<li><code><a title="lib.shell.commands.mv" href="#lib.shell.commands.mv">mv</a></code></li>
<li><code><a title="lib.shell.commands.parse_command_line" href="#lib.shell.commands.parse_command_line">parse_command_line</a></code></li>
<li><code><a title="lib.shell.commands.ping" href="#lib.shell.commands.ping">ping</a></code></li>
<li><code><a title="lib.shell.commands.print_part" href="#lib.shell.commands.print_part">print_part</a></code></li>
<li><code><a title="lib.shell.commands.pwd" href="#lib.shell.commands.pwd">pwd</a></code></li>
<li><code><a title="lib.shell.commands.reboot" href="#lib.shell.commands.reboot">reboot</a></code></li>
<li><code><a title="lib.shell.commands.removedir" href="#lib.shell.commands.removedir">removedir</a></code></li>
<li><code><a title="lib.shell.commands.rm" href="#lib.shell.commands.rm">rm</a></code></li>
<li><code><a title="lib.shell.commands.rmdir" href="#lib.shell.commands.rmdir">rmdir</a></code></li>
<li><code><a title="lib.shell.commands.rmfile" href="#lib.shell.commands.rmfile">rmfile</a></code></li>
<li><code><a title="lib.shell.commands.searchfile" href="#lib.shell.commands.searchfile">searchfile</a></code></li>
<li><code><a title="lib.shell.commands.setdate" href="#lib.shell.commands.setdate">setdate</a></code></li>
<li><code><a title="lib.shell.commands.sysinfo" href="#lib.shell.commands.sysinfo">sysinfo</a></code></li>
<li><code><a title="lib.shell.commands.temperature" href="#lib.shell.commands.temperature">temperature</a></code></li>
<li><code><a title="lib.shell.commands.umountsd" href="#lib.shell.commands.umountsd">umountsd</a></code></li>
<li><code><a title="lib.shell.commands.upload" href="#lib.shell.commands.upload">upload</a></code></li>
<li><code><a title="lib.shell.commands.uptime" href="#lib.shell.commands.uptime">uptime</a></code></li>
<li><code><a title="lib.shell.commands.vtcolors" href="#lib.shell.commands.vtcolors">vtcolors</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.shell.commands.Exporter" href="#lib.shell.commands.Exporter">Exporter</a></code></h4>
<ul class="">
<li><code><a title="lib.shell.commands.Exporter.send_file" href="#lib.shell.commands.Exporter.send_file">send_file</a></code></li>
<li><code><a title="lib.shell.commands.Exporter.show" href="#lib.shell.commands.Exporter.show">show</a></code></li>
<li><code><a title="lib.shell.commands.Exporter.show_dir" href="#lib.shell.commands.Exporter.show_dir">show_dir</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.shell.commands.LsDisplayer" href="#lib.shell.commands.LsDisplayer">LsDisplayer</a></code></h4>
<ul class="">
<li><code><a title="lib.shell.commands.LsDisplayer.purge_path" href="#lib.shell.commands.LsDisplayer.purge_path">purge_path</a></code></li>
<li><code><a title="lib.shell.commands.LsDisplayer.show" href="#lib.shell.commands.LsDisplayer.show">show</a></code></li>
<li><code><a title="lib.shell.commands.LsDisplayer.show_dir" href="#lib.shell.commands.LsDisplayer.show_dir">show_dir</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>