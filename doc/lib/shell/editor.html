<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lib.shell.editor API documentation</title>
<meta name="description" content="Class defining a VT100 text editor.
This editor works directly in the board.
This allows you to make quick and easy changes directly on the board, â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.shell.editor</code></h1>
</header>
<section id="section-intro">
<p>Class defining a VT100 text editor.
This editor works directly in the board.
This allows you to make quick and easy changes directly on the board, without having to use synchronization tools.
This editor allows script execution, and displays errors and execution time.</p>
<p>Editor shortcuts :
<br> - <b>Exit
</b>: Escape
<br> - <b>Move cursor
</b>: Arrows, Home, End, PageUp, PageDown, Ctrl-Home, Ctrl-End, Ctrl-Left, Ctrl-Right
<br> - <b>Selection
</b>: Shift-Arrows, Shift-Home, Shift-End, Alt-Shift-Arrows, Ctrl-Shift-Left, Ctrl-Shift-Right
<br> - <b>Clipboard
</b>: Selection with Ctrl X(Cut), Ctrl-C(Copy), Ctrl-V(Paste)
<br> - <b>Case change
</b>: Selection with Ctrl-U(Toggle majuscule, minuscule)
<br> - <b>Indent
</b>: Selection with Tab(Indent) or Shift-Tab(Unindent)
<br> - <b>Comment block </b>: Selection with Ctrl-Q
<br> - <b>Save
</b>: Ctrl-S
<br> - <b>Find
</b>: Ctrl-F
<br> - <b>Replace
</b>: Ctrl-H
<br> - <b>Toggle mode
</b>: Ctrl-T (Insertion/Replacement)
<br> - <b>Delete line
</b>: Ctrl-L
<br> - <b>Goto line
</b>: Ctrl-G
<br> - <b>Execute
</b>: F5</p>
<p>This editor also works on linux and osx, and can also be used autonomously,
you need to add the useful.py,logger.py,strings.py,terminal.py script to its side.
All the keyboard shortcuts are at the start of the script.</p>
<p>On the boards with low memory, it may work, but on very small files, otherwise it may produce an error due to insufficient memory.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python3
# Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
# pylint:disable=multiple-statements
# pylint:disable=too-many-lines
&#34;&#34;&#34; Class defining a VT100 text editor.
This editor works directly in the board.
This allows you to make quick and easy changes directly on the board, without having to use synchronization tools.
This editor allows script execution, and displays errors and execution time.

Editor shortcuts :
&lt;br&gt; - &lt;b&gt;Exit          &lt;/b&gt;: Escape
&lt;br&gt; - &lt;b&gt;Move cursor   &lt;/b&gt;: Arrows, Home, End, PageUp, PageDown, Ctrl-Home, Ctrl-End, Ctrl-Left, Ctrl-Right
&lt;br&gt; - &lt;b&gt;Selection     &lt;/b&gt;: Shift-Arrows, Shift-Home, Shift-End, Alt-Shift-Arrows, Ctrl-Shift-Left, Ctrl-Shift-Right
&lt;br&gt; - &lt;b&gt;Clipboard     &lt;/b&gt;: Selection with Ctrl X(Cut), Ctrl-C(Copy), Ctrl-V(Paste)
&lt;br&gt; - &lt;b&gt;Case change   &lt;/b&gt;: Selection with Ctrl-U(Toggle majuscule, minuscule)
&lt;br&gt; - &lt;b&gt;Indent        &lt;/b&gt;: Selection with Tab(Indent) or Shift-Tab(Unindent)
&lt;br&gt; - &lt;b&gt;Comment block &lt;/b&gt;: Selection with Ctrl-Q
&lt;br&gt; - &lt;b&gt;Save          &lt;/b&gt;: Ctrl-S
&lt;br&gt; - &lt;b&gt;Find          &lt;/b&gt;: Ctrl-F
&lt;br&gt; - &lt;b&gt;Replace       &lt;/b&gt;: Ctrl-H
&lt;br&gt; - &lt;b&gt;Toggle mode   &lt;/b&gt;: Ctrl-T (Insertion/Replacement)
&lt;br&gt; - &lt;b&gt;Delete line   &lt;/b&gt;: Ctrl-L
&lt;br&gt; - &lt;b&gt;Goto line     &lt;/b&gt;: Ctrl-G
&lt;br&gt; - &lt;b&gt;Execute       &lt;/b&gt;: F5

This editor also works on linux and osx, and can also be used autonomously,
you need to add the useful.py,logger.py,strings.py,terminal.py script to its side.
All the keyboard shortcuts are at the start of the script.

On the boards with low memory, it may work, but on very small files, otherwise it may produce an error due to insufficient memory.
&#34;&#34;&#34;
import sys

from . import filesystem
sys.path.append(&#34;lib&#34;)
sys.path.append(&#34;lib/tools&#34;)
try:
        from tools import useful,logger,strings,terminal
except:
        # pylint:disable=multiple-imports
        import useful,logger,strings,terminal

TABSIZE = 4          # Tabulation size
HORIZONTAL_MOVE=8    # Scrolling minimal deplacement

ESCAPE           = &#34;\x1b&#34;

# Move shortcuts
UP               = [&#34;\x1b[A&#34;]
DOWN             = [&#34;\x1b[B&#34;]
RIGHT            = [&#34;\x1b[C&#34;]
LEFT             = [&#34;\x1b[D&#34;]
HOME             = [&#34;\x1b[1;3D&#34;, &#34;\x1b[H&#34;, &#34;\x1b\x1b[D&#34;, &#34;\x1b[1~&#34;, &#34;\x1bb&#34;]
END              = [&#34;\x1b[1;3C&#34;, &#34;\x1b[F&#34;, &#34;\x1b\x1b[C&#34;, &#34;\x1b[4~&#34;, &#34;\x1bf&#34;]
PAGE_UP          = [&#34;\x1b[1;3A&#34;, &#34;\x1b[A&#34;, &#34;\x1b\x1b[A&#34;, &#34;\x1b[5~&#34;]
PAGE_DOWN        = [&#34;\x1b[1;3B&#34;, &#34;\x1b[B&#34;, &#34;\x1b\x1b[B&#34;, &#34;\x1b[6~&#34;]
TOP              = [&#34;\x1b[1;5H&#34;]
BOTTOM           = [&#34;\x1b[1;5F&#34;]
NEXT_WORD        = [&#34;\x1b[1;5C&#34;]
PREVIOUS_WORD    = [&#34;\x1b[1;5D&#34;]

# Selection shortcuts
SELECT_UP        = [&#34;\x1b[1;2A&#34;]
SELECT_DOWN      = [&#34;\x1b[1;2B&#34;]
SELECT_RIGHT     = [&#34;\x1b[1;2C&#34;]
SELECT_LEFT      = [&#34;\x1b[1;2D&#34;]
SELECT_PAGE_UP   = [&#34;\x1b[1;10A&#34;,&#34;\x1b[1;4A&#34;,&#34;\x1b[5;2~&#34;]
SELECT_PAGE_DOWN = [&#34;\x1b[1;10B&#34;,&#34;\x1b[1;4B&#34;,&#34;\x1b[6;2~&#34;]
SELECT_HOME      = [&#34;\x1b[1;2H&#34;,&#34;\x1b[1;10D&#34;]
SELECT_END       = [&#34;\x1b[1;2F&#34;,&#34;\x1b[1;10C&#34;]
SELECT_TOP       = [&#34;\x1b[1;6H&#34;]
SELECT_BOTTOM    = [&#34;\x1b[1;6F&#34;]
SELECT_ALL       = [&#34;\x01&#34;]
SELECT_NEXT_WORD = [&#34;\x1b[1;6C&#34;,&#34;\x1b[1;4C&#34;]
SELECT_PREV_WORD = [&#34;\x1b[1;6D&#34;,&#34;\x1b[1;4D&#34;]

# Clipboard shortcuts
CUT              = [&#34;\x18&#34;,&#34;\x1bx&#34;]                      # Cut
COPY             = [&#34;\x03&#34;,&#34;\x1bc&#34;]                      # Copy
PASTE            = [&#34;\x16&#34;,&#34;\x1bv&#34;]                      # Paste

# Selection modification shortcut
INDENT           = [&#34;\t&#34;]                                # Indent
UNINDENT         = [&#34;\x1b[Z&#34;]                            # Unindent
CHANGE_CASE      = [&#34;\x15&#34;]                              # Change case
COMMENT          = [&#34;\x11&#34;]                              # Comment block

DELETE           = [&#34;\x1b[3~&#34;]                           # Delete pressed
BACKSPACE        = [&#34;\x7F&#34;]                              # Backspace pressed
NEW_LINE         = [&#34;\n&#34;, &#34;\r&#34;]                          # New line pressed

TOGGLE_MODE      = [&#34;\x14&#34;]                              # Toggle replace/insert mode
EXIT             = [ESCAPE]                              # Exit
FIND             = [&#34;\x06&#34;]                              # Find
FIND_NEXT        = [&#34;\x1bOR&#34;]                            # Find next
FIND_PREVIOUS    = [&#34;\x1b[1;2R&#34;]                         # Find previous
GOTO             = [&#34;\x07&#34;]                              # Goto line
SAVE             = [&#34;\x13&#34;,&#34;\x1bs&#34;]                      # Save
DELETE_LINE      = [&#34;\x0C&#34;]                              # Delete line
REPLACE          = [&#34;\x08&#34;]                              # Replace
REPLACE_CURRENT  = [&#34;\x12&#34;]                              # Replace the selection
EXECUTE          = [&#34;\x1b[15~&#34;]                          # Execute script

class View:
        &#34;&#34;&#34; Class which manage the view of the edit field &#34;&#34;&#34;
        def __init__(self, view_height, view_top):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.line     = 0
                self.column   = 0
                if view_height is None:
                        self.height   = 20
                else:
                        self.height          = view_height
                self.width               = 80
                self.top                 = view_top
                self.is_refresh_all        = True
                self.is_refresh_line       = False
                self.is_refresh_line_before = False
                self.is_refresh_line_after  = False
                self.refresh_part         = None
                self.text                = None
                self.tab_cursor_column     = 0
                self.sel_line_start        = None
                self.sel_line_end          = None
                self.screen_height = 1
                self.screen_width = 1

        def write(self, data):
                &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
                sys.stdout.write(data)

        def flush(self):
                &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
                try:
                        sys.stdout.flush()
                except:
                        pass

        def set_text(self, text):
                &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
                self.text = text

        def get_screen_position(self):
                &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
                return (self.text.get_cursor_line() - self.line + self.top, self.tab_cursor_column - self.column)

        def reset(self):
                &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
                self.write(&#34;\x1B&#34;&#34;c&#34;)
                self.flush()

        def reset_scroll_region(self):
                &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
                if self.screen_height &gt; 0:
                        self.set_scrolling_region(0, self.screen_height-1)

        def set_scrolling_region(self, top_line, bottom_line):
                &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
                if top_line &lt; bottom_line:
                        self.write(&#34;\x1B[%d;%dr&#34;%(top_line+1,bottom_line+1))

        def scroll_up(self):
                &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
                self.set_scrolling_region(self.top, self.height+1)
                self.write(&#34;\x1B[1S&#34;)

        def scroll_down(self):
                &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
                self.set_scrolling_region(self.top, self.height+1)
                self.write(&#34;\x1B[1T&#34;)

        def scroll_part_up(self):
                &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
                line, column = self.get_screen_position()
                if line &lt; self.height:
                        self.set_scrolling_region(line, self.height+1)
                        self.write(&#34;\x1B[1S&#34;)

        def scroll_part_down(self):
                &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
                line, column = self.get_screen_position()
                if line &lt; self.height:
                        self.set_scrolling_region(line+1, self.height+1)
                        self.write(&#34;\x1B[1T&#34;)
                else:
                        self.is_refresh_line_after = True

        def move(self):
                &#34;&#34;&#34; Move the view &#34;&#34;&#34;
                self.tab_cursor_column = self.text.get_tab_cursor(self.text.get_cursor_line())
                # Move view port
                if self.tab_cursor_column &lt; self.column:
                        self.is_refresh_all = True
                        if self.tab_cursor_column &gt; HORIZONTAL_MOVE:
                                self.column = self.tab_cursor_column-HORIZONTAL_MOVE
                        else:
                                self.column = 0
                elif self.tab_cursor_column &gt;= self.column + self.width:
                        self.column = self.tab_cursor_column-self.width+HORIZONTAL_MOVE
                        self.is_refresh_all = True
                if self.text.get_cursor_line() &lt; self.line:
                        delta = self.line - self.text.get_cursor_line()
                        self.line = self.text.get_cursor_line()
                        if self.line &lt; 0:
                                self.line = 0
                        if delta &lt;= 1:
                                self.scroll_down()
                                self.is_refresh_line = True
                        else:
                                self.is_refresh_all = True
                elif self.text.get_cursor_line() &gt; self.line + self.height:
                        delta =  self.text.get_cursor_line() - self.line - self.height
                        self.line = self.text.get_cursor_line()-self.height
                        if delta &lt;= 1:
                                self.scroll_up()
                                self.is_refresh_line = True
                        else:
                                self.is_refresh_all = True

        def set_refresh_line(self):
                &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True

        def set_refresh_after(self):
                &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True
                self.is_refresh_line_after = True

        def set_refresh_before(self):
                &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True
                self.is_refresh_line_before = True

        def set_refresh_all(self):
                &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
                self.is_refresh_all = True

        def show_line(self, current_line, screen_line, selection_start, selection_end, quick=False):
                &#34;&#34;&#34; Show one line &#34;&#34;&#34;
                if quick:
                        line_to_display = &#34;&#34;
                else:
                        line_to_display = &#34;\x1B[%d;1f\x1B[K&#34;%(screen_line+1)
                count_line = self.text.get_count_lines()
                if current_line &lt; count_line and current_line &gt;= 0:
                        line = self.text.get_tab_line(current_line)
                        partLine = line[self.column:self.column+self.width]
                        # If the line selected
                        if selection_start is not None:
                                # If the line not empty
                                if len(partLine) &gt;= 1:
                                        # If the line have carriage return at the end
                                        if partLine[-1] == &#34;\n&#34;:
                                                # Remove the carriage return
                                                partLine = partLine[:-1]
                                if len(partLine) &gt; 0:
                                        dummy, sel_line_start, sel_column_start = selection_start
                                        dummy, sel_line_end,   sel_column_end   = selection_end
                                        # If the current line is the end of selection
                                        if current_line == sel_line_end:
                                                # If the end of selection is outside the visible part
                                                if sel_column_end - self.column &lt; 0:
                                                        sel_column_end = 0
                                                else:
                                                        sel_column_end -= self.column

                                                # If the start of selection is on the previous lines
                                                if sel_line_start &lt; sel_line_end:
                                                        # Select the start of line
                                                        partLine = &#34;\x1B[7m&#34; + partLine[:sel_column_end] + &#34;\x1B[m&#34; + partLine[sel_column_end:]
                                                else:
                                                        # Unselect the end of line
                                                        partLine = partLine[:sel_column_end] + &#34;\x1B[m&#34; + partLine[sel_column_end:]
                                        # If the current line is the start of selection
                                        if current_line == sel_line_start:
                                                # If the start of selection is outside the visible part
                                                if sel_column_start - self.column &lt; 0:
                                                        sel_column_start = 0
                                                else:
                                                        sel_column_start -= self.column

                                                # If the end of selection is on the next lines
                                                if sel_line_start &lt; sel_line_end:
                                                        # Select the end of line
                                                        partLine = partLine[:sel_column_start] + &#34;\x1B[7m&#34; + partLine[sel_column_start:] + &#34;\x1B[m&#34;
                                                else:
                                                        # Select the start of line
                                                        partLine = partLine[:sel_column_start] + &#34;\x1B[7m&#34; + partLine[sel_column_start:]
                                        # If the line is completly selected
                                        if current_line &gt; sel_line_start and current_line &lt; sel_line_end:
                                                # Select all the line
                                                partLine = &#34;\x1B[7m&#34; + partLine + &#34;\x1B[m&#34;
                                else:
                                        partLine = &#34;&#34;
                                self.write(line_to_display + partLine)
                        else:
                                self.write(line_to_display + partLine.rstrip())

        def refresh_line(self, selection_start, selection_end):
                &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
                screen_line,     screen_column = self.get_screen_position()
                refreshed = False

                # If the line must be refreshed before the cursor line
                if self.is_refresh_line_before:
                        self.is_refresh_line_before = False
                        self.show_line(self.text.get_cursor_line()-1, screen_line-1, selection_start, selection_end)
                        refreshed = True
                # If the line must be refreshed after the cursor line
                if self.is_refresh_line_after:
                        self.is_refresh_line_after = False
                        self.show_line(self.text.get_cursor_line()+1, screen_line+1, selection_start, selection_end)
                        offset = self.height - screen_line
                        self.show_line(self.text.get_cursor_line()+offset+1, screen_line+offset+1, selection_start, selection_end)
                        refreshed = True
                # If only the cursor line must be refresh
                if self.is_refresh_line:
                        self.is_refresh_line = False
                        self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)
                        refreshed = True

                # If no refresh detected and a selection started
                if selection_start is not None and refreshed is False:
                        # Refresh the selection
                        self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)

        def refresh(self):
                &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if self.refresh_part is not None:
                        self.refresh_content(selection_start, selection_end, self.refresh_part)
                        self.refresh_part = None
                # Refresh all required
                if self.is_refresh_all:
                        self.refresh_content(selection_start, selection_end, True)
                        self.is_refresh_all  = False
                        self.is_refresh_line = False
                else:
                        # If no selection activated
                        if selection_start is None:
                                # Refresh the current line
                                self.refresh_line(selection_start, selection_end)
                        else:
                                # Refresh the selection
                                self.refresh_content(selection_start, selection_end, False)
                self.move_cursor()
                self.flush()

        def refresh_content(self, selection_start, selection_end, all_):
                &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
                # If selection present
                if selection_start is not None:
                        # Get the selection
                        dummy, sel_line_start, sel_column_start = selection_start
                        dummy, sel_line_end,   sel_column_end   = selection_end
                        lineStart = sel_line_start
                        lineEnd   = sel_line_end
                        # The aim of this part is to limit the refresh area
                        # If the precedent display show a selection
                        if self.sel_line_end is not None and self.sel_line_start is not None:
                                # If the start and end of selection is on the sames lines
                                if self.sel_line_end == sel_line_end and self.sel_line_start == sel_line_start:
                                        lineStart = lineEnd = self.text.get_cursor_line()
                                else:
                                        # If the end of selection is after the precedent display
                                        if self.sel_line_end &gt; sel_line_end:
                                                lineEnd = self.sel_line_end
                                        # If the end of selection is on the same line than the precedent display
                                        elif self.sel_line_end == sel_line_end:
                                                # If the start of selection is before the precedent display
                                                if self.sel_line_start &lt; sel_line_start:
                                                        lineEnd = sel_line_start
                                                else:
                                                        lineEnd = self.sel_line_start
                                        # If the start of selection is before the precedent display
                                        if self.sel_line_start &lt; sel_line_start:
                                                lineStart = self.sel_line_start
                                        # If the start of selection is on the same line than the precedent display
                                        elif self.sel_line_start == sel_line_start:
                                                # If the end of selection is after the precedent display
                                                if self.sel_line_end &gt; sel_line_end:
                                                        lineStart = sel_line_end
                                                else:
                                                        lineStart = self.sel_line_end
                else:
                        lineStart = 0
                        lineEnd = self.line + self.height
                current_line = self.line
                screen_line = self.top
                if type(all_) == type([]):
                        lineStart, lineEnd = all_
                        all_ = False
                count_line = self.text.get_count_lines()
                maxLine = self.line + self.height
                if all_:
                        # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                        self.move_cursor(screen_line, 0)
                        self.write(&#34;\x1B[J&#34;)
                        # Refresh all lines visible
                        while current_line &lt; count_line and current_line &lt;= maxLine:
                                self.show_line(current_line, screen_line, selection_start, selection_end, True)
                                screen_line  += 1
                                current_line += 1
                                if (current_line &lt; count_line and current_line &lt;= maxLine):
                                        self.write(&#34;\n\r&#34;)
                else:
                        # Refresh all lines visible
                        while current_line &lt; count_line and current_line &lt;= maxLine:
                                # If the line is in selection or all must be refreshed
                                if lineStart &lt;= current_line &lt;= lineEnd or all_:
                                        self.show_line(current_line, screen_line, selection_start, selection_end)
                                screen_line  += 1
                                current_line += 1

                # If selection present
                if selection_start is not None:
                        # Save current selection
                        dummy, self.sel_line_start, dummy = selection_start
                        dummy, self.sel_line_end,   dummy   = selection_end

        def hide_selection(self):
                &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if selection_start is not None:
                        self.set_refresh_selection()
                        self.sel_line_start = None
                        self.sel_line_end   = None

        def set_refresh_selection(self):
                &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if selection_start is not None:
                        # self.is_refresh_all = True
                        lineStart = selection_start[1]
                        if self.sel_line_start &lt; lineStart:
                                lineStart = self.sel_line_start
                        lineEnd = selection_end[1]
                        if self.sel_line_end &gt; lineEnd:
                                lineEnd = self.sel_line_end
                        self.refresh_part = [lineStart, lineEnd]

        def move_cursor(self, screen_line=None, screen_column=None):
                &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
                self.write(self.get_move_cursor(screen_line, screen_column))

        def get_move_cursor(self, screen_line=None, screen_column=None):
                &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
                if screen_line is None and screen_column is None:
                        screen_line, screen_column = self.get_screen_position()
                return &#34;\x1B[%d;%df&#34;%(screen_line+1,screen_column+1)

        def get_screen_size(self):
                &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
                height, width = terminal.get_screen_size()
                self.screen_height = height
                self.screen_width = width
                self.height = height-self.top-1
                self.width  = width
                self.move_cursor()

        def cls(self):
                &#34;&#34;&#34; clear the screen &#34;&#34;&#34;
                self.write(&#34;\x1B[2J&#34;)
                self.move_cursor(0,0)

class Text:
        &#34;&#34;&#34; Class which manage the text edition &#34;&#34;&#34;
        def __init__(self, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.lines = [&#34;&#34;]
                self.cursor_line   = 0
                self.cursor_column = 0
                self.tab_cursor_column   = 0
                self.modified     = False
                self.replace_mode  = False
                self.read_only     = read_only
                self.view         = None
                self.tab_size      = TABSIZE
                self.selection_start = None
                self.selection_end   = None
                self.selection = []
                self.filename = None

        def set_view(self, view):
                &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
                self.view = view

        def get_count_lines(self):
                &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
                return len(self.lines)

        def get_cursor_line(self):
                &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
                return self.cursor_line

        def get_tab_cursor(self, current_line, current_column=None):
                &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
                if current_column is None:
                        cursor_column = self.cursor_column
                else:
                        cursor_column = current_column
                line = self.lines[current_line]
                if &#34;\t&#34; in line:
                        tab_cursor_column   = 0
                        column = 0
                        lenLine = len(line)
                        while column &lt; cursor_column:
                                if line[column] == &#34;\t&#34;:
                                        pos = tab_cursor_column%self.tab_size
                                        tab_cursor_column += self.tab_size-pos
                                        column          += 1
                                else:
                                        tab = line.find(&#34;\t&#34;,column)
                                        if tab &gt; 0:
                                                partSize = tab - column
                                        else:
                                                partSize = lenLine - column
                                        if column + partSize &gt; cursor_column:
                                                partSize = cursor_column - column
                                        tab_cursor_column += partSize
                                        column          += partSize
                        return tab_cursor_column
                else:
                        return cursor_column

        def get_tab_line(self, current_line = None):
                &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
                line = self.lines[current_line]
                if &#34;\t&#34; in line:
                        tabLine = &#34;&#34;
                        tab_cursor_column   = 0
                        lenLine = len(line)
                        column = 0
                        while column &lt; lenLine:
                                char = line[column]
                                if char == &#34;\t&#34;:
                                        pos = tab_cursor_column%self.tab_size
                                        tab_cursor_column += self.tab_size-pos
                                        tabLine         += &#34; &#34;*(self.tab_size-pos)
                                        column          += 1
                                else:
                                        tab = line.find(&#34;\t&#34;,column)
                                        if tab &gt; 0:
                                                part = line[column:tab]
                                        else:
                                                part = line[column:]
                                        tab_cursor_column += len(part)
                                        tabLine         += part
                                        column          += len(part)
                else:
                        tabLine = line
                return tabLine

        def get_tab_cursor_column(self):
                &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
                line = self.lines[self.cursor_line]
                column = 0
                self.tab_cursor_column = 0
                while column &lt; self.cursor_column:
                        if line[column] == &#34;\t&#34;:
                                pos = self.tab_cursor_column%self.tab_size
                                self.tab_cursor_column += self.tab_size-pos
                                column += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        delta = tab - column
                                        if column + delta &gt; self.cursor_column:
                                                delta = self.cursor_column - column
                                                self.tab_cursor_column += delta
                                                column += delta
                                        else:
                                                self.tab_cursor_column += delta
                                                column += delta
                                else:
                                        delta = self.cursor_column - column
                                        self.tab_cursor_column += delta
                                        column += delta

        def set_cursor_column(self):
                &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
                line = self.lines[self.cursor_line]
                column = 0
                tab_cursor_column = 0
                lenLine = len(line)
                column = 0
                while column &lt; lenLine:
                        char = line[column]
                        # If the previous position found exactly in the current line
                        if tab_cursor_column == self.tab_cursor_column:
                                self.cursor_column = column
                                break
                        # If the previous position not found in the current line
                        if tab_cursor_column &gt; self.tab_cursor_column:
                                # Keep last existing position
                                self.cursor_column = column
                                break
                        # If tabulation found
                        if char == &#34;\t&#34;:
                                tab_cursor_column += self.tab_size-(tab_cursor_column%self.tab_size)
                                column += 1
                        else:
                                # Optimization to accelerate the cursor position
                                tab = line.find(&#34;\t&#34;, column)

                                # Tabulation found
                                if tab &gt; 0:
                                        delta = tab - column
                                        # If the tabulation position is after the previous tabulation cursor
                                        if delta + tab_cursor_column &gt; self.tab_cursor_column:
                                                # Move the cursor to the left
                                                self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                                break
                                        else:
                                                # Another tabulation found, move it after
                                                tab_cursor_column += delta
                                                column += delta
                                # Tabulation not found
                                else:
                                        # Move the cursor to the end of line
                                        self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                        break
                else:
                        if len(line) &gt;= 1:
                                self.cursor_column = len(line)-1
                        else:
                                self.cursor_column = 0

        def load(self, filename_):
                &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
                self.filename = None
                try:
                        self.lines = []
                        self.filename = filename_
                        file = open(filename_, &#34;r&#34;)
                        line = file.readline()
                        while line != &#34;&#34;:
                                self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                                line = file.readline()
                        file.close()
                        if len(self.lines) == 0:
                                self.lines = [&#34;&#34;]
                except MemoryError:
                        # pylint: disable=raise-missing-from
                        raise MemoryError()
                except OSError:
                        self.lines = [&#34;&#34;]
                        # File not existing
                except Exception as err:
                        logger.syslog(err)
                        self.lines = [&#34;&#34;]

        def save(self):
                &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
                result = False
                if self.read_only is False:
                        if self.filename is not None:
                                try:
                                        file = open(self.filename, &#34;w&#34;)
                                        for line in self.lines:
                                                file.write(line)
                                        file.close()
                                        self.modified = False
                                        result = True
                                except Exception as err:
                                        logger.syslog(err)
                return result

        def change_line(self, moveLine):
                &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
                # If cursor is before the first line
                if moveLine + self.cursor_line &lt; 0:
                        # Set the cursor to the first line
                        self.cursor_line = 0
                        self.cursor_column = 0
                        self.change_column(0)
                # If the cursor is after the last line
                elif moveLine + self.cursor_line &gt;= len(self.lines):
                        self.cursor_line = len(self.lines) -1
                        self.cursor_column = len(self.lines[self.cursor_line])
                        self.change_column(0)
                # else the cursor is in the lines of text
                else:
                        previousLine = self.cursor_line
                        self.cursor_line += moveLine
                        if len(self.lines) - 1 == self.cursor_line:
                                lenLine = len(self.lines[self.cursor_line])
                        else:
                                lenLine = len(self.lines[self.cursor_line])-1

                        self.set_cursor_column()
                        # If the new cursor position is outside the last line of text
                        if self.cursor_column &gt; lenLine:
                                self.cursor_column = lenLine

                if self.selection_start is not None:
                        self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]
                self.view.move()

        def change_column(self, move_column):
                &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
                cursor_line   = self.cursor_line
                cursor_column = self.cursor_column
                # If the cursor go to the previous line
                if move_column + self.cursor_column &lt; 0:
                        # If start of line
                        if abs(move_column) &gt; 1:
                                self.cursor_column = 0
                        # If move to the left and must go to previous line
                        elif self.cursor_line &gt; 0:
                                self.cursor_line -= 1
                                self.cursor_column = len(self.lines[self.cursor_line])-1
                # If the cursor is at the end of line
                elif move_column + self.cursor_column &gt; len(self.lines[self.cursor_line])-1:
                        # If the cursor is on the last line of file
                        if abs(move_column) &gt; 1 or self.cursor_line+1 == len(self.lines):
                                # If the file is empty
                                if self.lines[self.cursor_line] == &#34;&#34;:
                                        self.cursor_column = 0
                                        self.tab_cursor_column = 0
                                # If the last line of contains return char
                                elif self.lines[self.cursor_line][-1] == &#34;\n&#34;:
                                        # Move cursor before return
                                        self.cursor_column = len(self.lines[self.cursor_line])-1
                                else:
                                        # Move cursor after the last char
                                        self.cursor_column = len(self.lines[self.cursor_line])

                        # If the cursor is on the end of line and must change of line
                        elif self.cursor_line+1 &lt; len(self.lines):
                                self.cursor_line += 1
                                self.cursor_column = 0
                                self.tab_cursor_column = 0
                # Normal move of cursor
                else:
                        # Next or previous column
                        self.cursor_column += move_column
                if abs(move_column) &gt; 0:
                        self.get_tab_cursor_column()
                self.close_selection()
                self.view.move()
                if self.cursor_column == cursor_column and self.cursor_line == cursor_line:
                        return False
                else:
                        return True

        def backspace(self):
                &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        # The cursor not in the begining of line
                        if self.cursor_column &gt;= 1:
                                line = self.lines[self.cursor_line]
                                line = line[0:self.cursor_column-1:]+ line[self.cursor_column  : :]
                                self.lines[self.cursor_line] = line
                                self.change_column(-1)
                                self.view.set_refresh_line()
                        # The cursor is on the begining of line
                        else:
                                # If the cursor not on the first line
                                if self.cursor_line &gt;= 1:
                                        # Copy the current line to the end of previous line
                                        self.cursor_column = len(self.lines[self.cursor_line-1])
                                        self.lines[self.cursor_line-1] = self.lines[self.cursor_line-1][:-1] + self.lines[self.cursor_line]
                                        del self.lines[self.cursor_line]
                                        self.view.scroll_part_up()
                                        self.cursor_line -= 1
                                        self.view.set_refresh_after()
                                        self.change_column(-1)

        def delete(self):
                &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        line = self.lines[self.cursor_line]
                        if self.cursor_column &lt; len(line):
                                # If the line is empty
                                if line[self.cursor_column] == &#34;\n&#34;:
                                        # If the cursor not at end of files
                                        if self.cursor_line &lt; len(self.lines)-1:
                                                # Copy the next line to the current line
                                                self.lines[self.cursor_line] = line[:self.cursor_column] + self.lines[self.cursor_line+1]
                                                del self.lines[self.cursor_line+1]
                                                self.view.scroll_part_up()
                                                self.view.set_refresh_after()
                                # Else the char is deleted in the middle of line
                                else:
                                        line = line[0:self.cursor_column:]+ line[self.cursor_column+1  : :]
                                        self.lines[self.cursor_line] = line
                                        self.change_column(0)
                                        self.view.is_refresh_line = True

        def delete_line(self):
                &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
                self.hide_selection()
                self.modified = True
                # If file contains one or none line
                if len(self.lines) &lt;= 1:
                        # Clean the content of file
                        self.lines = [&#34;&#34;]
                        self.cursor_column = 0
                        self.cursor_line = 0
                        self.change_column(0)
                # If the current line is not the last of file
                elif self.cursor_line &lt; len(self.lines):
                        # Delete the line
                        self.cursor_column = 0
                        del self.lines[self.cursor_line]
                        self.view.scroll_part_up()
                        if self.cursor_line &gt;= len(self.lines):
                                self.cursor_line = len(self.lines)-1
                        self.change_column(0)
                self.view.set_refresh_after()

        def new_line(self):
                &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        line1 = self.lines[self.cursor_line][:self.cursor_column]+&#34;\n&#34;
                        line2 = self.lines[self.cursor_line][self.cursor_column:]
                        self.lines[self.cursor_line]=line1
                        self.lines.insert(self.cursor_line+1, line2)
                        self.view.scroll_part_down()
                        self.change_column(1)
                        self.view.set_refresh_before()

        def insert_char(self, char):
                &#34;&#34;&#34; Insert character &#34;&#34;&#34;
                self.modified = True
                self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column:]
                self.change_column(1)
                self.view.set_refresh_line()

        def replace_char(self, char):
                &#34;&#34;&#34; Replace character &#34;&#34;&#34;
                self.modified = True
                if self.cursor_line == len(self.lines)-1 and self.cursor_column &gt;= len(self.lines[self.cursor_line])-1:
                        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char
                        self.change_column(1)
                        self.view.set_refresh_line()
                # If it is the last char in the line
                elif self.lines[self.cursor_line][self.cursor_column] == &#34;\n&#34;:
                        # Append char to the line
                        self.insert_char(char)
                # Else the char must be replaced in the line
                else:
                        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column+1:]
                        self.change_column(1)
                        self.view.set_refresh_line()

        def open_selection(self):
                &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
                if self.selection_start is None:
                        self.selection_start = [self.cursor_column, self.cursor_line, self.get_tab_cursor(self.cursor_line)]

        def close_selection(self):
                &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
                if self.selection_start is not None:
                        self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]

        def select_all(self):
                &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
                self.selection_start = [0,0,0]
                lastLine = len(self.lines)-1
                lastColumn = len(self.lines[lastLine])-1
                self.move_cursor(lastLine, lastColumn)
                self.selection_end  = [lastColumn, lastLine, self.get_tab_cursor(lastLine, lastColumn)]
                self.view.set_refresh_all()

        def get_selection(self):
                &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
                if self.selection_start:
                        if self.selection_start[1] &gt; self.selection_end[1]:
                                return self.selection_end, self.selection_start
                        elif self.selection_start[1] &lt; self.selection_end[1]:
                                return self.selection_start, self.selection_end
                        elif self.selection_start[0] &lt; self.selection_end[0]:
                                return self.selection_start, self.selection_end
                        else:
                                return self.selection_end, self.selection_start
                else:
                        return None, None

        def arrow_up(self, keys):
                &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line(-1)

        def arrow_down(self, keys):
                &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line(1)

        def arrow_left(self, keys):
                &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(-len(keys))

        def arrow_right(self, keys):
                &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(len(keys))

        def select_up(self, keys):
                &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
                self.open_selection()
                self.change_line(-1)

        def select_down(self, keys):
                &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
                self.open_selection()
                self.change_line(1)

        def select_left(self, keys):
                &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(-len(keys))

        def select_right(self, keys):
                &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(len(keys))

        def select_home(self):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(-100000000000)

        def select_end(self):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(100000000000)

        def select_page_up(self, keys):
                &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
                self.open_selection()
                self.change_line((-self.view.height-1) * len(keys))
                self.change_column(-100000000000)

        def select_page_down(self, keys):
                &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
                self.open_selection()
                self.change_line((self.view.height+1) * len(keys))
                self.change_column(100000000000)

        def select_next_word(self):
                &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
                self.open_selection()
                self.move_word(1)

        def select_previous_word(self):
                &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
                self.open_selection()
                self.move_word(-1)

        def select_top(self):
                &#34;&#34;&#34; Manage select to the first line of text &#34;&#34;&#34;
                self.open_selection()
                self.change_line(-100000000000)

        def select_bottom(self):
                &#34;&#34;&#34; Manage select to the last line of text &#34;&#34;&#34;
                self.open_selection()
                self.change_line(100000000000)

        def page_up(self, keys):
                &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line((-self.view.height-1) * len(keys))

        def page_down(self, keys):
                &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line((self.view.height+1) * len(keys))

        def home(self):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(-100000000000)

        def end(self):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(100000000000)

        def add_char(self, keys):
                &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
                result = False

                if strings.isascii(keys[0]):
                        self.remove_selection()
                        for char in keys:
                                if strings.isascii(char):
                                        if self.replace_mode:
                                                self.replace_char(char)
                                        else:
                                                self.insert_char(char)
                                        result = True
                # if result is False:
                        # print(strings.dump(keys[0]))
                return result

        def find_next(self, text):
                &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
                # Get the selection
                selection_start, selection_end = self.get_selection()

                # Hide the selection
                self.hide_selection()

                # Set the start of search at the cursor position
                current_line   = self.cursor_line
                current_column = self.cursor_column

                # If selection activated
                if selection_start is not None and selection_end is not None:
                        # If selection is on one line
                        if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                                # If selection is exactly the size of text
                                if selection_start[0] == current_column:
                                        # Move the start of search after the text selected
                                        current_column = selection_end[0]

                # Find the text in next lines
                while current_line &lt; len(self.lines):
                        # Search text
                        pos = self.lines[current_line].find(text, current_column)

                        # If text found
                        if pos &gt;= 0:
                                # Move the cursor to the text found
                                self.cursor_line = current_line
                                self.cursor_column = pos + len(text)
                                self.change_column(0)
                                self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                                self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                                break
                        else:
                                # Set the search position at the begin of next line
                                current_column = 0
                                current_line += 1
                self.view.move()

        def find_previous(self, text):
                &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
                # Get the selection
                selection_start, selection_end = self.get_selection()

                # Hide the selection
                self.hide_selection()

                # Set the start of search at the cursor position
                current_line   = self.cursor_line
                current_column = self.cursor_column

                # If selection activated
                if selection_start is not None and selection_end is not None:
                        # If selection is on one line
                        if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                                # If selection is exactly the size of text
                                if selection_end[0] - selection_start[0] == len(text):
                                        # Move the start of search before the text selected
                                        current_column = selection_start[0]

                # While the line before the first line not reached
                while current_line &gt;= 0:
                        # Get the current line
                        line = self.lines[current_line]

                        # If the current column is negative
                        if current_column &lt; 0:
                                # Set the end of line
                                current_column = len(line)

                        # Search the text in reverse
                        pos = line.rfind(text, 0, current_column)

                        # If text found
                        if pos &gt;= 0:
                                self.cursor_line = current_line
                                self.cursor_column = pos
                                self.change_column(0)
                                self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                                self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                                break
                        else:
                                # Set the search position at the end of line
                                current_column = -1
                                current_line -= 1
                self.view.move()

        def hide_selection(self):
                &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
                self.view.hide_selection()
                self.selection_start = self.selection_end = None

        def goto(self, lineNumber):
                &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
                self.hide_selection()
                if lineNumber &lt; 0:
                        self.cursor_line = len(self.lines)-1
                elif lineNumber &lt; 1:
                        self.cursor_line = 1
                elif lineNumber &lt; len(self.lines):
                        self.cursor_line = lineNumber - 1
                else:
                        self.cursor_line = len(self.lines)-1
                self.cursor_column = 0
                self.change_column(0)
                self.view.move()

        def copy_clipboard(self):
                &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
                result = []
                if self.selection_start is not None:
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end
                        result = []
                        if sel_line_start == sel_line_end:
                                result.append(self.lines[sel_line_start][sel_column_start:sel_column_end])
                        else:
                                for line in range(sel_line_start, sel_line_end+1):
                                        if line == sel_line_start:
                                                part = self.lines[line][sel_column_start:]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][sel_column_start:])
                                        elif line == sel_line_end:
                                                part = self.lines[line][:sel_column_end]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][:sel_column_end])
                                        else:
                                                result.append(self.lines[line])
                return result

        def remove_selection(self):
                &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
                if self.selection_start is not None:
                        self.modified = True
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end
                        start = self.lines[sel_line_start][:sel_column_start]
                        end   = self.lines[sel_line_end  ][sel_column_end:]
                        self.lines[sel_line_start] = start + end
                        if sel_line_start &lt; sel_line_end:
                                for line in range(sel_line_end, sel_line_start,-1):
                                        del self.lines[line]
                        self.move_cursor(sel_line_start, sel_column_start)
                        self.hide_selection()
                        self.view.set_refresh_all()
                        return True
                return False

        def paste_clipboard(self, selection):
                &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
                if selection != []:
                        # Split the line with insertion
                        start = self.lines[self.cursor_line][:self.cursor_column]
                        end   = self.lines[self.cursor_line][self.cursor_column:]

                        # Paste the first line
                        self.lines[self.cursor_line] = start + selection[0]

                        self.cursor_line += 1

                        # Insert all lines from clipboard
                        for line in selection[1:-1]:
                                self.lines.insert(self.cursor_line, line)
                                self.cursor_line += 1

                        # If the last line of clipboard is not empty
                        if len(selection[-1]) &gt;= 1:
                                # If the last line of clipboard contains new line
                                if selection[-1][-1] == &#34;\n&#34;:
                                        if len(selection) &gt; 1:
                                                # Add the new line
                                                self.lines.insert(self.cursor_line, selection[-1])
                                                self.cursor_line += 1

                                        # Add the part after the insertion
                                        self.lines.insert(self.cursor_line, end)
                                        self.cursor_column = 0
                                else:
                                        if len(selection) &gt; 1:
                                                self.lines.insert(self.cursor_line, selection[-1] + end)
                                                self.cursor_column = len(selection[-1])
                                        else:
                                                self.cursor_line -= 1
                                                self.lines[self.cursor_line] += end
                                                self.cursor_column = len(start) + len(selection[-1])

                        self.move_cursor(self.cursor_line, self.cursor_column)

        def move_cursor(self, line, column):
                &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
                self.cursor_line   = line
                self.cursor_column = column
                self.change_column(0)
                self.get_tab_cursor_column()

        def copy(self):
                &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
                self.selection = self.copy_clipboard()

        def cut(self):
                &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
                self.modified = True
                self.selection = self.copy_clipboard()
                self.remove_selection()

        def paste(self):
                &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
                self.modified = True
                self.remove_selection()
                self.paste_clipboard(self.selection)
                self.view.set_refresh_all()
                self.hide_selection()

        def change_case(self):
                &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
                selection = self.copy_clipboard()
                if selection != []:
                        self.modified = True
                        selection_start = self.selection_start
                        selection_end   = self.selection_end

                        self.remove_selection()
                        isUpper = None
                        for line in selection:
                                for char in line:
                                        if strings.isupper(char):
                                                isUpper = True
                                                break
                                        elif strings.islower(char):
                                                isUpper = False
                                                break
                                if isUpper is not None:
                                        break
                        # pylint:disable=consider-using-enumerate
                        for line in range(len(selection)):
                                if isUpper:
                                        selection[line] = selection[line].lower()
                                else:
                                        selection[line] = selection[line].upper()
                        self.paste_clipboard(selection)
                        self.view.set_refresh_selection()
                        self.selection_start = selection_start
                        self.selection_end   = selection_end

        def comment(self):
                &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
                self.modified = True

                # If selection
                if self.selection_start is not None:
                        selection_start, selection_end = self.get_selection()
                        _, sel_line_start, _ = selection_start
                        _, sel_line_end,   _ = selection_end

                        # Add tabulation
                        for line in range(sel_line_start, sel_line_end+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] != &#39;#&#39;:
                                                self.lines[line] = &#34;#&#34; + self.lines[line]
                                        else:
                                                if len(self.lines[line]) &gt;= 1:
                                                        self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selection_start = [0,sel_line_start, 0]

                        # Get the length of last selected line
                        len_line_end =  len(self.lines[sel_line_end])

                        # Move the end of selection at the end of line selected
                        self.selection_end   = [len_line_end-1, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end-1)]
                        self.view.set_refresh_selection()
                else:
                        if len(self.lines[self.cursor_line]) &gt;= 1:
                                # If nothing selected
                                if self.lines[self.cursor_line][0] == &#34;#&#34;:
                                        self.lines[self.cursor_line] = self.lines[self.cursor_line][1:]
                                        if self.cursor_column &gt; 0:
                                                self.change_column(-1)
                                else:
                                        self.lines[self.cursor_line] = &#34;#&#34; + self.lines[self.cursor_line]
                                        self.change_column(1)
                        self.view.set_refresh_line()

        def indent(self, keys):
                &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
                # If nothing selected
                if self.selection_start is None:
                        self.add_char(keys)
                else:
                        self.modified = True
                        # Indent selection
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end

                        # If a part of line selected
                        if sel_line_start == sel_line_end and not (sel_column_start == 0 and sel_column_end == len(self.lines[sel_line_end])-1):
                                self.add_char(INDENT)
                        else:
                                # If the last line selected is at beginning of line
                                if sel_column_end == 0:
                                        # This line must not be indented
                                        sel_line_end -= 1

                                # Add tabulation
                                for line in range(sel_line_start, sel_line_end+1):
                                        self.lines[line] = &#34;\t&#34; + self.lines[line]

                                # Move the start selection to the start of first selected line
                                self.selection_start = [0,sel_line_start, 0]

                                # If the last line selected is not at beginning of line
                                if sel_column_end &gt; 0:
                                        # Get the length of last selected line
                                        len_line_end =  len(self.lines[sel_line_end])

                                        # If the end of selection is not on the last line
                                        if sel_line_end &lt; len(self.lines)-1:
                                                len_line_end -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selection_end  = [0, sel_line_end+1, 0]
                        self.view.set_refresh_selection()

        def unindent(self, keys):
                &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
                # If nothing selected
                if self.selection_start is None:
                        self.backspace()
                else:
                        self.modified = True

                        # Unindent selection
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end

                        # If the selection is only alone line
                        if sel_line_start == sel_line_end:
                                self.hide_selection()
                        else:
                                # If the last line selected is at beginning of line
                                if sel_column_end == 0:
                                        # This line must not be indented
                                        sel_line_end -= 1

                                # Remove indentation
                                for line in range(sel_line_start, sel_line_end+1):
                                        if len(self.lines[line]) &gt;= 1:
                                                if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                        self.lines[line] = self.lines[line][1:]

                                # Move the start selection to the start of first selected line
                                self.selection_start = [0,sel_line_start, 0]

                                # If the last line selected is not at beginning of line
                                if sel_column_end &gt; 0:
                                        # Get the length of last selected line
                                        len_line_end =  len(self.lines[sel_line_end])

                                        # If the end of selection is not on the last line
                                        if sel_line_end &lt; len(self.lines)-1:
                                                len_line_end -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selection_end  = [0, sel_line_end+1, 0]
                        self.view.set_refresh_selection()

        def replace(self, old, new):
                &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
                if self.read_only is False:
                        selection = self.copy_clipboard()
                        if len(selection) == 1:
                                if selection[0] == old:
                                        self.delete()
                                        self.insert_char(new)
                                        return True
                return False

        def get_cursor_char(self):
                &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
                try:
                        return self.lines[self.cursor_line][self.cursor_column]
                except:
                        return None

        def move_word(self, direction):
                &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
                state = 0
                while self.change_column(direction):
                        current_char = self.get_cursor_char()
                        if current_char is None:
                                break
                        elif strings.ispunctuation(current_char):
                                if state == 0:
                                        state = 2
                                elif state == 1:
                                        break
                        elif strings.isalpha(current_char):
                                if state == 0:
                                        state = 1
                                elif state == 2:
                                        break
                        elif strings.isspace(current_char):
                                if state == 1:
                                        break
                                if state == 2:
                                        break

        def next_word(self):
                &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
                self.hide_selection()
                self.move_word(1)
                self.view.move()

        def previous_word(self):
                &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
                self.hide_selection()
                self.move_word(-1)
                self.view.move()

        def top(self):
                &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
                self.goto(1)

        def bottom(self):
                &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
                self.goto(100000000000)

        def treat_char(self, keys):
                &#34;&#34;&#34; Treat character entered &#34;&#34;&#34;
                char = ord(keys[0][0])
                if self.read_only is False:
                        if char &gt;= 0x20 and char != 0x7F:
                                self.add_char(keys)
                                return True
                return False

        def treat_key(self, keys):
                &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
                if self.treat_char(keys) is False:
                        # Move in the edit field
                        if   keys[0] in UP  :            self.arrow_up(keys)
                        elif keys[0] in DOWN:            self.arrow_down(keys)
                        elif keys[0] in LEFT:            self.arrow_left(keys)
                        elif keys[0] in RIGHT:           self.arrow_right(keys)
                        elif keys[0] in HOME:            self.home()
                        elif keys[0] in END:             self.end()
                        elif keys[0] in PAGE_UP:         self.page_up(keys)
                        elif keys[0] in PAGE_DOWN:       self.page_down(keys)
                        elif keys[0] in TOP:             self.top()
                        elif keys[0] in BOTTOM:          self.bottom()
                        elif keys[0] in NEXT_WORD:       self.next_word()
                        elif keys[0] in PREVIOUS_WORD:   self.previous_word()
                        # Selection the edit field
                        elif keys[0] in SELECT_UP:       self.select_up(keys)
                        elif keys[0] in SELECT_DOWN:     self.select_down(keys)
                        elif keys[0] in SELECT_RIGHT:    self.select_right(keys)
                        elif keys[0] in SELECT_LEFT:     self.select_left(keys)
                        elif keys[0] in SELECT_HOME:     self.select_home()
                        elif keys[0] in SELECT_END:      self.select_end()
                        elif keys[0] in SELECT_TOP:      self.select_top()
                        elif keys[0] in SELECT_BOTTOM:   self.select_bottom()
                        elif keys[0] in SELECT_PAGE_UP:  self.select_page_up(keys)
                        elif keys[0] in SELECT_PAGE_DOWN:self.select_page_down(keys)
                        elif keys[0] in SELECT_ALL:      self.select_all()
                        elif keys[0] in SELECT_NEXT_WORD:self.select_next_word()
                        elif keys[0] in SELECT_PREV_WORD:self.select_previous_word()

                        # If the edit is not in read only
                        elif self.read_only is False:
                                # Modification in the edit field
                                if   keys[0] in COPY:            self.copy()
                                elif keys[0] in CUT:             self.cut()
                                elif keys[0] in PASTE:           self.paste()

                                elif keys[0] in INDENT:          self.indent(keys)
                                elif keys[0] in UNINDENT:        self.unindent(keys)
                                elif keys[0] in CHANGE_CASE:     self.change_case()
                                elif keys[0] in COMMENT:         self.comment()

                                elif keys[0] in BACKSPACE:       self.backspace()
                                elif keys[0] in DELETE:          self.delete()
                                elif keys[0] in NEW_LINE:        self.new_line()
                                elif keys[0] in DELETE_LINE:     self.delete_line()
                        # else: self.add_char(keys)

class Edit:
        &#34;&#34;&#34; Class which aggregate the View and Text &#34;&#34;&#34;
        def __init__(self, view_top=1, view_height=None, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.view = View(view_height, view_top)
                self.text = Text(read_only)
                self.text.set_view(self.view)
                self.view.set_text(self.text)

class Editor:
        &#34;&#34;&#34; Class which manage a complete editor &#34;&#34;&#34;
        def __init__(self, filename_, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.file = filename_
                self.filename = filesystem.split(filename_)[1]
                self.edit = Edit(read_only=read_only)
                self.edit.text.load(filename_)
                self.is_refresh_header = True
                self.find_text = None
                self.replace_text = None
                self.keys= []
                self.loop = None

                if (not filesystem.exists(filename_) and read_only is True) or filesystem.isdir(filename_):
                        print(&#34;Cannot open &#39;%s&#39;&#34;%self.filename)
                else:
                        self.run()

        def refresh_header(self):
                &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
                if self.is_refresh_header:
                        self.edit.view.move_cursor(0, 0)
                        filename_ = &#34;File: %s&#34;%(self.filename)
                        if self.edit.text.read_only is False:
                                filename_ += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                                end = &#34;Mode: %s&#34;%(&#34;Replace&#34; if self.edit.text.replace_mode else &#34;Insert&#34;)
                        else:
                                end = &#34;Read only&#34; if self.edit.text.read_only else &#34;&#34;

                        header = &#34;\x1B[7m %s%s%s \x1B[m&#34;%(filename_, &#34; &#34;*(self.edit.view.width - len(filename_) - len(end)-1), end)
                        self.edit.view.write(header)
                        self.edit.view.move_cursor()
                        self.is_refresh_header = False

        def refresh(self):
                &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
                self.refresh_header()
                self.edit.view.refresh()

        def toggle_mode(self):
                &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
                if self.edit.text.replace_mode:
                        self.edit.text.replace_mode = False
                else:
                        self.edit.text.replace_mode = True
                self.is_refresh_header = True

        def save(self):
                &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
                self.edit.text.save()
                self.is_refresh_header = True

        def exit(self):
                &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
                self.edit.view.cls()
                if self.edit.text.modified:
                        self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.filename)
                        self.edit.view.flush()
                        while 1:
                                key = terminal.getch()
                                if key == &#34;Y&#34; or key == &#34;y&#34;:
                                        if self.edit.text.save():
                                                self.edit.view.write(&#34;Saved\n&#34;)
                                                self.edit.view.flush()
                                        else:
                                                self.edit.view.write(&#34;Failed to save\n&#34;)
                                                self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == &#34;N&#34; or key == &#34;n&#34;:
                                        self.edit.view.write(&#34;Not saved\n&#34;)
                                        self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == ESCAPE:
                                        self.edit.view.set_refresh_all()
                                        self.is_refresh_header = True
                                        break
                else:
                        self.loop = False

        def input(self, text, help_=&#34;&#34;):
                &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
                edit_ = Edit(view_top=2, view_height=1, read_only=False)
                edit_.view.cls()
                edit_.view.move_cursor(1,0)
                edit_.view.write(text)
                edit_.view.move_cursor(4,0)
                edit_.view.write(help_)
                result = None
                while 1:
                        edit_.view.refresh()
                        key = self.get_key()
                        if key[0] in NEW_LINE:
                                result = edit_.text.lines[0]
                                break
                        elif key[0] in ESCAPE:
                                break
                        else:
                                edit_.text.treat_key(key)
                return result

        def find(self):
                &#34;&#34;&#34; Find a text &#34;&#34;&#34;
                self.find_text = self.input(&#34;Find :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next&#34;)
                self.find_next()
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def replace(self):
                &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
                self.find_text    = self.input(&#34;Find to replace :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
                if self.find_text:
                        self.replace_text = self.input(&#34;Replace with :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next  \x1B[7m^R\x1B[m:Replace&#34;)
                        self.find_next()

                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def replace_current(self):
                &#34;&#34;&#34; Replace current &#34;&#34;&#34;
                if self.find_text and self.replace_text:
                        if self.edit.text.replace(self.find_text, self.replace_text):
                                self.find_next()

        def find_next(self):
                &#34;&#34;&#34; Find next text &#34;&#34;&#34;
                if self.find_text:
                        self.edit.text.find_next(self.find_text)

        def find_previous(self):
                &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
                if self.find_text:
                        self.edit.text.find_previous(self.find_text)

        def goto(self):
                &#34;&#34;&#34; Goto line &#34;&#34;&#34;
                lineNumber = self.input(&#34;Goto line :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
                try:
                        lineNumber = int(lineNumber)
                        self.edit.text.goto(int(lineNumber))
                except:
                        pass
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def group_key(self):
                &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
                result = [self.keys.pop(0)]
                while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                        if self.keys[0] == result[0]:
                                result.append(self.keys.pop(0))
                        else:
                                if strings.isascii(result[0]) and strings.isascii(self.keys[0]):
                                        result.append(self.keys.pop(0))
                                else:
                                        break
                return result

        def get_key(self):
                &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
                if len(self.keys) == 0:
                        while True:
                                try:
                                        key = terminal.getch()
                                except KeyboardInterrupt:
                                        key = &#34;\x03&#34;
                                self.keys.append(key)
                                if terminal.kbhit() is False or len(self.keys) &gt; 5:
                                        break
                return self.group_key()

        def execute(self):
                &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
                self.save()
                loop = True
                while loop:
                        self.edit.view.reset_scroll_region()
                        self.edit.view.cls()
                        self.edit.view.flush()
                        startTime = strings.ticks()
                        try:
                                useful.run(self.filename)
                        except KeyboardInterrupt:
                                pass
                        endTime = strings.ticks()
                        print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                        while 1:
                                keys = self.get_key()
                                if keys[0] in NEW_LINE:
                                        loop = False
                                        break
                                elif keys[0] in EXECUTE:
                                        break
                                # else:
                                        # print(strings.dump(keys[0]))
                self.edit.view.cls()
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def run(self):
                &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
                self.edit.view.cls()
                self.edit.view.get_screen_size()
                self.loop = True
                while(self.loop):
                        try:
                                self.refresh()
                                keys = self.get_key()
                                modified = self.edit.text.modified
                                if ord(keys[0][0]) &lt; 0x20:
                                        if   keys[0] in TOGGLE_MODE:    self.toggle_mode()
                                        elif keys[0] in FIND:           self.find()
                                        elif keys[0] in REPLACE:        self.replace()
                                        elif keys[0] in FIND_PREVIOUS:  self.find_previous()
                                        elif keys[0] in FIND_NEXT:      self.find_next()
                                        elif keys[0] in REPLACE_CURRENT:self.replace_current()
                                        elif keys[0] in EXIT:           self.exit()
                                        elif keys[0] in GOTO:           self.goto()
                                        elif keys[0] in SAVE:           self.save()
                                        elif keys[0] in EXECUTE:        self.execute()
                                self.edit.text.treat_key(keys)
                                if modified != self.edit.text.modified:
                                        self.is_refresh_header = True
                        except KeyboardInterrupt:
                                pass
                self.edit.view.reset_scroll_region()
                self.edit.view.reset()

if __name__ == &#34;__main__&#34;:
        if len(sys.argv) &gt; 1:
                filename = sys.argv[1]
        else:
                filename = &#34;editor.txt&#34;
        edit = Editor(filename, read_only=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.shell.editor.Edit"><code class="flex name class">
<span>class <span class="ident">Edit</span></span>
<span>(</span><span>view_top=1, view_height=None, read_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which aggregate the View and Text </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edit:
        &#34;&#34;&#34; Class which aggregate the View and Text &#34;&#34;&#34;
        def __init__(self, view_top=1, view_height=None, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.view = View(view_height, view_top)
                self.text = Text(read_only)
                self.text.set_view(self.view)
                self.view.set_text(self.text)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor"><code class="flex name class">
<span>class <span class="ident">Editor</span></span>
<span>(</span><span>filename_, read_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage a complete editor </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Editor:
        &#34;&#34;&#34; Class which manage a complete editor &#34;&#34;&#34;
        def __init__(self, filename_, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.file = filename_
                self.filename = filesystem.split(filename_)[1]
                self.edit = Edit(read_only=read_only)
                self.edit.text.load(filename_)
                self.is_refresh_header = True
                self.find_text = None
                self.replace_text = None
                self.keys= []
                self.loop = None

                if (not filesystem.exists(filename_) and read_only is True) or filesystem.isdir(filename_):
                        print(&#34;Cannot open &#39;%s&#39;&#34;%self.filename)
                else:
                        self.run()

        def refresh_header(self):
                &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
                if self.is_refresh_header:
                        self.edit.view.move_cursor(0, 0)
                        filename_ = &#34;File: %s&#34;%(self.filename)
                        if self.edit.text.read_only is False:
                                filename_ += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                                end = &#34;Mode: %s&#34;%(&#34;Replace&#34; if self.edit.text.replace_mode else &#34;Insert&#34;)
                        else:
                                end = &#34;Read only&#34; if self.edit.text.read_only else &#34;&#34;

                        header = &#34;\x1B[7m %s%s%s \x1B[m&#34;%(filename_, &#34; &#34;*(self.edit.view.width - len(filename_) - len(end)-1), end)
                        self.edit.view.write(header)
                        self.edit.view.move_cursor()
                        self.is_refresh_header = False

        def refresh(self):
                &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
                self.refresh_header()
                self.edit.view.refresh()

        def toggle_mode(self):
                &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
                if self.edit.text.replace_mode:
                        self.edit.text.replace_mode = False
                else:
                        self.edit.text.replace_mode = True
                self.is_refresh_header = True

        def save(self):
                &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
                self.edit.text.save()
                self.is_refresh_header = True

        def exit(self):
                &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
                self.edit.view.cls()
                if self.edit.text.modified:
                        self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.filename)
                        self.edit.view.flush()
                        while 1:
                                key = terminal.getch()
                                if key == &#34;Y&#34; or key == &#34;y&#34;:
                                        if self.edit.text.save():
                                                self.edit.view.write(&#34;Saved\n&#34;)
                                                self.edit.view.flush()
                                        else:
                                                self.edit.view.write(&#34;Failed to save\n&#34;)
                                                self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == &#34;N&#34; or key == &#34;n&#34;:
                                        self.edit.view.write(&#34;Not saved\n&#34;)
                                        self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == ESCAPE:
                                        self.edit.view.set_refresh_all()
                                        self.is_refresh_header = True
                                        break
                else:
                        self.loop = False

        def input(self, text, help_=&#34;&#34;):
                &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
                edit_ = Edit(view_top=2, view_height=1, read_only=False)
                edit_.view.cls()
                edit_.view.move_cursor(1,0)
                edit_.view.write(text)
                edit_.view.move_cursor(4,0)
                edit_.view.write(help_)
                result = None
                while 1:
                        edit_.view.refresh()
                        key = self.get_key()
                        if key[0] in NEW_LINE:
                                result = edit_.text.lines[0]
                                break
                        elif key[0] in ESCAPE:
                                break
                        else:
                                edit_.text.treat_key(key)
                return result

        def find(self):
                &#34;&#34;&#34; Find a text &#34;&#34;&#34;
                self.find_text = self.input(&#34;Find :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next&#34;)
                self.find_next()
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def replace(self):
                &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
                self.find_text    = self.input(&#34;Find to replace :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
                if self.find_text:
                        self.replace_text = self.input(&#34;Replace with :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next  \x1B[7m^R\x1B[m:Replace&#34;)
                        self.find_next()

                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def replace_current(self):
                &#34;&#34;&#34; Replace current &#34;&#34;&#34;
                if self.find_text and self.replace_text:
                        if self.edit.text.replace(self.find_text, self.replace_text):
                                self.find_next()

        def find_next(self):
                &#34;&#34;&#34; Find next text &#34;&#34;&#34;
                if self.find_text:
                        self.edit.text.find_next(self.find_text)

        def find_previous(self):
                &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
                if self.find_text:
                        self.edit.text.find_previous(self.find_text)

        def goto(self):
                &#34;&#34;&#34; Goto line &#34;&#34;&#34;
                lineNumber = self.input(&#34;Goto line :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
                try:
                        lineNumber = int(lineNumber)
                        self.edit.text.goto(int(lineNumber))
                except:
                        pass
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def group_key(self):
                &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
                result = [self.keys.pop(0)]
                while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                        if self.keys[0] == result[0]:
                                result.append(self.keys.pop(0))
                        else:
                                if strings.isascii(result[0]) and strings.isascii(self.keys[0]):
                                        result.append(self.keys.pop(0))
                                else:
                                        break
                return result

        def get_key(self):
                &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
                if len(self.keys) == 0:
                        while True:
                                try:
                                        key = terminal.getch()
                                except KeyboardInterrupt:
                                        key = &#34;\x03&#34;
                                self.keys.append(key)
                                if terminal.kbhit() is False or len(self.keys) &gt; 5:
                                        break
                return self.group_key()

        def execute(self):
                &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
                self.save()
                loop = True
                while loop:
                        self.edit.view.reset_scroll_region()
                        self.edit.view.cls()
                        self.edit.view.flush()
                        startTime = strings.ticks()
                        try:
                                useful.run(self.filename)
                        except KeyboardInterrupt:
                                pass
                        endTime = strings.ticks()
                        print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                        while 1:
                                keys = self.get_key()
                                if keys[0] in NEW_LINE:
                                        loop = False
                                        break
                                elif keys[0] in EXECUTE:
                                        break
                                # else:
                                        # print(strings.dump(keys[0]))
                self.edit.view.cls()
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def run(self):
                &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
                self.edit.view.cls()
                self.edit.view.get_screen_size()
                self.loop = True
                while(self.loop):
                        try:
                                self.refresh()
                                keys = self.get_key()
                                modified = self.edit.text.modified
                                if ord(keys[0][0]) &lt; 0x20:
                                        if   keys[0] in TOGGLE_MODE:    self.toggle_mode()
                                        elif keys[0] in FIND:           self.find()
                                        elif keys[0] in REPLACE:        self.replace()
                                        elif keys[0] in FIND_PREVIOUS:  self.find_previous()
                                        elif keys[0] in FIND_NEXT:      self.find_next()
                                        elif keys[0] in REPLACE_CURRENT:self.replace_current()
                                        elif keys[0] in EXIT:           self.exit()
                                        elif keys[0] in GOTO:           self.goto()
                                        elif keys[0] in SAVE:           self.save()
                                        elif keys[0] in EXECUTE:        self.execute()
                                self.edit.text.treat_key(keys)
                                if modified != self.edit.text.modified:
                                        self.is_refresh_header = True
                        except KeyboardInterrupt:
                                pass
                self.edit.view.reset_scroll_region()
                self.edit.view.reset()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.Editor.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the python script edited</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
        &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
        self.save()
        loop = True
        while loop:
                self.edit.view.reset_scroll_region()
                self.edit.view.cls()
                self.edit.view.flush()
                startTime = strings.ticks()
                try:
                        useful.run(self.filename)
                except KeyboardInterrupt:
                        pass
                endTime = strings.ticks()
                print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                while 1:
                        keys = self.get_key()
                        if keys[0] in NEW_LINE:
                                loop = False
                                break
                        elif keys[0] in EXECUTE:
                                break
                        # else:
                                # print(strings.dump(keys[0]))
        self.edit.view.cls()
        self.edit.view.set_refresh_all()
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit from editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit(self):
        &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
        self.edit.view.cls()
        if self.edit.text.modified:
                self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.filename)
                self.edit.view.flush()
                while 1:
                        key = terminal.getch()
                        if key == &#34;Y&#34; or key == &#34;y&#34;:
                                if self.edit.text.save():
                                        self.edit.view.write(&#34;Saved\n&#34;)
                                        self.edit.view.flush()
                                else:
                                        self.edit.view.write(&#34;Failed to save\n&#34;)
                                        self.edit.view.flush()
                                self.loop = False
                                break
                        elif key == &#34;N&#34; or key == &#34;n&#34;:
                                self.edit.view.write(&#34;Not saved\n&#34;)
                                self.edit.view.flush()
                                self.loop = False
                                break
                        elif key == ESCAPE:
                                self.edit.view.set_refresh_all()
                                self.is_refresh_header = True
                                break
        else:
                self.loop = False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find a text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self):
        &#34;&#34;&#34; Find a text &#34;&#34;&#34;
        self.find_text = self.input(&#34;Find :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next&#34;)
        self.find_next()
        self.edit.view.set_refresh_all()
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.find_next"><code class="name flex">
<span>def <span class="ident">find_next</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find next text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_next(self):
        &#34;&#34;&#34; Find next text &#34;&#34;&#34;
        if self.find_text:
                self.edit.text.find_next(self.find_text)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.find_previous"><code class="name flex">
<span>def <span class="ident">find_previous</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find previous text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_previous(self):
        &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
        if self.find_text:
                self.edit.text.find_previous(self.find_text)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.get_key"><code class="name flex">
<span>def <span class="ident">get_key</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a key pressed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_key(self):
        &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
        if len(self.keys) == 0:
                while True:
                        try:
                                key = terminal.getch()
                        except KeyboardInterrupt:
                                key = &#34;\x03&#34;
                        self.keys.append(key)
                        if terminal.kbhit() is False or len(self.keys) &gt; 5:
                                break
        return self.group_key()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Goto line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self):
        &#34;&#34;&#34; Goto line &#34;&#34;&#34;
        lineNumber = self.input(&#34;Goto line :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
        try:
                lineNumber = int(lineNumber)
                self.edit.text.goto(int(lineNumber))
        except:
                pass
        self.edit.view.set_refresh_all()
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.group_key"><code class="name flex">
<span>def <span class="ident">group_key</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Group similar key to optimize move of cursor and edition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_key(self):
        &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
        result = [self.keys.pop(0)]
        while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                if self.keys[0] == result[0]:
                        result.append(self.keys.pop(0))
                else:
                        if strings.isascii(result[0]) and strings.isascii(self.keys[0]):
                                result.append(self.keys.pop(0))
                        else:
                                break
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.input"><code class="name flex">
<span>def <span class="ident">input</span></span>(<span>self, text, help_='')</span>
</code></dt>
<dd>
<div class="desc"><p>Input value, used to get a line number, or text searched</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input(self, text, help_=&#34;&#34;):
        &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
        edit_ = Edit(view_top=2, view_height=1, read_only=False)
        edit_.view.cls()
        edit_.view.move_cursor(1,0)
        edit_.view.write(text)
        edit_.view.move_cursor(4,0)
        edit_.view.write(help_)
        result = None
        while 1:
                edit_.view.refresh()
                key = self.get_key()
                if key[0] in NEW_LINE:
                        result = edit_.text.lines[0]
                        break
                elif key[0] in ESCAPE:
                        break
                else:
                        edit_.text.treat_key(key)
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
        &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
        self.refresh_header()
        self.edit.view.refresh()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.refresh_header"><code class="name flex">
<span>def <span class="ident">refresh_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the header of editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_header(self):
        &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
        if self.is_refresh_header:
                self.edit.view.move_cursor(0, 0)
                filename_ = &#34;File: %s&#34;%(self.filename)
                if self.edit.text.read_only is False:
                        filename_ += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                        end = &#34;Mode: %s&#34;%(&#34;Replace&#34; if self.edit.text.replace_mode else &#34;Insert&#34;)
                else:
                        end = &#34;Read only&#34; if self.edit.text.read_only else &#34;&#34;

                header = &#34;\x1B[7m %s%s%s \x1B[m&#34;%(filename_, &#34; &#34;*(self.edit.view.width - len(filename_) - len(end)-1), end)
                self.edit.view.write(header)
                self.edit.view.move_cursor()
                self.is_refresh_header = False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace a text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self):
        &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
        self.find_text    = self.input(&#34;Find to replace :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
        if self.find_text:
                self.replace_text = self.input(&#34;Replace with :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next  \x1B[7m^R\x1B[m:Replace&#34;)
                self.find_next()

        self.edit.view.set_refresh_all()
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.replace_current"><code class="name flex">
<span>def <span class="ident">replace_current</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace current</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_current(self):
        &#34;&#34;&#34; Replace current &#34;&#34;&#34;
        if self.find_text and self.replace_text:
                if self.edit.text.replace(self.find_text, self.replace_text):
                        self.find_next()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Core of the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
        &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
        self.edit.view.cls()
        self.edit.view.get_screen_size()
        self.loop = True
        while(self.loop):
                try:
                        self.refresh()
                        keys = self.get_key()
                        modified = self.edit.text.modified
                        if ord(keys[0][0]) &lt; 0x20:
                                if   keys[0] in TOGGLE_MODE:    self.toggle_mode()
                                elif keys[0] in FIND:           self.find()
                                elif keys[0] in REPLACE:        self.replace()
                                elif keys[0] in FIND_PREVIOUS:  self.find_previous()
                                elif keys[0] in FIND_NEXT:      self.find_next()
                                elif keys[0] in REPLACE_CURRENT:self.replace_current()
                                elif keys[0] in EXIT:           self.exit()
                                elif keys[0] in GOTO:           self.goto()
                                elif keys[0] in SAVE:           self.save()
                                elif keys[0] in EXECUTE:        self.execute()
                        self.edit.text.treat_key(keys)
                        if modified != self.edit.text.modified:
                                self.is_refresh_header = True
                except KeyboardInterrupt:
                        pass
        self.edit.view.reset_scroll_region()
        self.edit.view.reset()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the file edited</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
        &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
        self.edit.text.save()
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.toggle_mode"><code class="name flex">
<span>def <span class="ident">toggle_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the replace mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_mode(self):
        &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
        if self.edit.text.replace_mode:
                self.edit.text.replace_mode = False
        else:
                self.edit.text.replace_mode = True
        self.is_refresh_header = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.shell.editor.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
<span>(</span><span>read_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage the text edition </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Text:
        &#34;&#34;&#34; Class which manage the text edition &#34;&#34;&#34;
        def __init__(self, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.lines = [&#34;&#34;]
                self.cursor_line   = 0
                self.cursor_column = 0
                self.tab_cursor_column   = 0
                self.modified     = False
                self.replace_mode  = False
                self.read_only     = read_only
                self.view         = None
                self.tab_size      = TABSIZE
                self.selection_start = None
                self.selection_end   = None
                self.selection = []
                self.filename = None

        def set_view(self, view):
                &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
                self.view = view

        def get_count_lines(self):
                &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
                return len(self.lines)

        def get_cursor_line(self):
                &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
                return self.cursor_line

        def get_tab_cursor(self, current_line, current_column=None):
                &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
                if current_column is None:
                        cursor_column = self.cursor_column
                else:
                        cursor_column = current_column
                line = self.lines[current_line]
                if &#34;\t&#34; in line:
                        tab_cursor_column   = 0
                        column = 0
                        lenLine = len(line)
                        while column &lt; cursor_column:
                                if line[column] == &#34;\t&#34;:
                                        pos = tab_cursor_column%self.tab_size
                                        tab_cursor_column += self.tab_size-pos
                                        column          += 1
                                else:
                                        tab = line.find(&#34;\t&#34;,column)
                                        if tab &gt; 0:
                                                partSize = tab - column
                                        else:
                                                partSize = lenLine - column
                                        if column + partSize &gt; cursor_column:
                                                partSize = cursor_column - column
                                        tab_cursor_column += partSize
                                        column          += partSize
                        return tab_cursor_column
                else:
                        return cursor_column

        def get_tab_line(self, current_line = None):
                &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
                line = self.lines[current_line]
                if &#34;\t&#34; in line:
                        tabLine = &#34;&#34;
                        tab_cursor_column   = 0
                        lenLine = len(line)
                        column = 0
                        while column &lt; lenLine:
                                char = line[column]
                                if char == &#34;\t&#34;:
                                        pos = tab_cursor_column%self.tab_size
                                        tab_cursor_column += self.tab_size-pos
                                        tabLine         += &#34; &#34;*(self.tab_size-pos)
                                        column          += 1
                                else:
                                        tab = line.find(&#34;\t&#34;,column)
                                        if tab &gt; 0:
                                                part = line[column:tab]
                                        else:
                                                part = line[column:]
                                        tab_cursor_column += len(part)
                                        tabLine         += part
                                        column          += len(part)
                else:
                        tabLine = line
                return tabLine

        def get_tab_cursor_column(self):
                &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
                line = self.lines[self.cursor_line]
                column = 0
                self.tab_cursor_column = 0
                while column &lt; self.cursor_column:
                        if line[column] == &#34;\t&#34;:
                                pos = self.tab_cursor_column%self.tab_size
                                self.tab_cursor_column += self.tab_size-pos
                                column += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        delta = tab - column
                                        if column + delta &gt; self.cursor_column:
                                                delta = self.cursor_column - column
                                                self.tab_cursor_column += delta
                                                column += delta
                                        else:
                                                self.tab_cursor_column += delta
                                                column += delta
                                else:
                                        delta = self.cursor_column - column
                                        self.tab_cursor_column += delta
                                        column += delta

        def set_cursor_column(self):
                &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
                line = self.lines[self.cursor_line]
                column = 0
                tab_cursor_column = 0
                lenLine = len(line)
                column = 0
                while column &lt; lenLine:
                        char = line[column]
                        # If the previous position found exactly in the current line
                        if tab_cursor_column == self.tab_cursor_column:
                                self.cursor_column = column
                                break
                        # If the previous position not found in the current line
                        if tab_cursor_column &gt; self.tab_cursor_column:
                                # Keep last existing position
                                self.cursor_column = column
                                break
                        # If tabulation found
                        if char == &#34;\t&#34;:
                                tab_cursor_column += self.tab_size-(tab_cursor_column%self.tab_size)
                                column += 1
                        else:
                                # Optimization to accelerate the cursor position
                                tab = line.find(&#34;\t&#34;, column)

                                # Tabulation found
                                if tab &gt; 0:
                                        delta = tab - column
                                        # If the tabulation position is after the previous tabulation cursor
                                        if delta + tab_cursor_column &gt; self.tab_cursor_column:
                                                # Move the cursor to the left
                                                self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                                break
                                        else:
                                                # Another tabulation found, move it after
                                                tab_cursor_column += delta
                                                column += delta
                                # Tabulation not found
                                else:
                                        # Move the cursor to the end of line
                                        self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                        break
                else:
                        if len(line) &gt;= 1:
                                self.cursor_column = len(line)-1
                        else:
                                self.cursor_column = 0

        def load(self, filename_):
                &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
                self.filename = None
                try:
                        self.lines = []
                        self.filename = filename_
                        file = open(filename_, &#34;r&#34;)
                        line = file.readline()
                        while line != &#34;&#34;:
                                self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                                line = file.readline()
                        file.close()
                        if len(self.lines) == 0:
                                self.lines = [&#34;&#34;]
                except MemoryError:
                        # pylint: disable=raise-missing-from
                        raise MemoryError()
                except OSError:
                        self.lines = [&#34;&#34;]
                        # File not existing
                except Exception as err:
                        logger.syslog(err)
                        self.lines = [&#34;&#34;]

        def save(self):
                &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
                result = False
                if self.read_only is False:
                        if self.filename is not None:
                                try:
                                        file = open(self.filename, &#34;w&#34;)
                                        for line in self.lines:
                                                file.write(line)
                                        file.close()
                                        self.modified = False
                                        result = True
                                except Exception as err:
                                        logger.syslog(err)
                return result

        def change_line(self, moveLine):
                &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
                # If cursor is before the first line
                if moveLine + self.cursor_line &lt; 0:
                        # Set the cursor to the first line
                        self.cursor_line = 0
                        self.cursor_column = 0
                        self.change_column(0)
                # If the cursor is after the last line
                elif moveLine + self.cursor_line &gt;= len(self.lines):
                        self.cursor_line = len(self.lines) -1
                        self.cursor_column = len(self.lines[self.cursor_line])
                        self.change_column(0)
                # else the cursor is in the lines of text
                else:
                        previousLine = self.cursor_line
                        self.cursor_line += moveLine
                        if len(self.lines) - 1 == self.cursor_line:
                                lenLine = len(self.lines[self.cursor_line])
                        else:
                                lenLine = len(self.lines[self.cursor_line])-1

                        self.set_cursor_column()
                        # If the new cursor position is outside the last line of text
                        if self.cursor_column &gt; lenLine:
                                self.cursor_column = lenLine

                if self.selection_start is not None:
                        self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]
                self.view.move()

        def change_column(self, move_column):
                &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
                cursor_line   = self.cursor_line
                cursor_column = self.cursor_column
                # If the cursor go to the previous line
                if move_column + self.cursor_column &lt; 0:
                        # If start of line
                        if abs(move_column) &gt; 1:
                                self.cursor_column = 0
                        # If move to the left and must go to previous line
                        elif self.cursor_line &gt; 0:
                                self.cursor_line -= 1
                                self.cursor_column = len(self.lines[self.cursor_line])-1
                # If the cursor is at the end of line
                elif move_column + self.cursor_column &gt; len(self.lines[self.cursor_line])-1:
                        # If the cursor is on the last line of file
                        if abs(move_column) &gt; 1 or self.cursor_line+1 == len(self.lines):
                                # If the file is empty
                                if self.lines[self.cursor_line] == &#34;&#34;:
                                        self.cursor_column = 0
                                        self.tab_cursor_column = 0
                                # If the last line of contains return char
                                elif self.lines[self.cursor_line][-1] == &#34;\n&#34;:
                                        # Move cursor before return
                                        self.cursor_column = len(self.lines[self.cursor_line])-1
                                else:
                                        # Move cursor after the last char
                                        self.cursor_column = len(self.lines[self.cursor_line])

                        # If the cursor is on the end of line and must change of line
                        elif self.cursor_line+1 &lt; len(self.lines):
                                self.cursor_line += 1
                                self.cursor_column = 0
                                self.tab_cursor_column = 0
                # Normal move of cursor
                else:
                        # Next or previous column
                        self.cursor_column += move_column
                if abs(move_column) &gt; 0:
                        self.get_tab_cursor_column()
                self.close_selection()
                self.view.move()
                if self.cursor_column == cursor_column and self.cursor_line == cursor_line:
                        return False
                else:
                        return True

        def backspace(self):
                &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        # The cursor not in the begining of line
                        if self.cursor_column &gt;= 1:
                                line = self.lines[self.cursor_line]
                                line = line[0:self.cursor_column-1:]+ line[self.cursor_column  : :]
                                self.lines[self.cursor_line] = line
                                self.change_column(-1)
                                self.view.set_refresh_line()
                        # The cursor is on the begining of line
                        else:
                                # If the cursor not on the first line
                                if self.cursor_line &gt;= 1:
                                        # Copy the current line to the end of previous line
                                        self.cursor_column = len(self.lines[self.cursor_line-1])
                                        self.lines[self.cursor_line-1] = self.lines[self.cursor_line-1][:-1] + self.lines[self.cursor_line]
                                        del self.lines[self.cursor_line]
                                        self.view.scroll_part_up()
                                        self.cursor_line -= 1
                                        self.view.set_refresh_after()
                                        self.change_column(-1)

        def delete(self):
                &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        line = self.lines[self.cursor_line]
                        if self.cursor_column &lt; len(line):
                                # If the line is empty
                                if line[self.cursor_column] == &#34;\n&#34;:
                                        # If the cursor not at end of files
                                        if self.cursor_line &lt; len(self.lines)-1:
                                                # Copy the next line to the current line
                                                self.lines[self.cursor_line] = line[:self.cursor_column] + self.lines[self.cursor_line+1]
                                                del self.lines[self.cursor_line+1]
                                                self.view.scroll_part_up()
                                                self.view.set_refresh_after()
                                # Else the char is deleted in the middle of line
                                else:
                                        line = line[0:self.cursor_column:]+ line[self.cursor_column+1  : :]
                                        self.lines[self.cursor_line] = line
                                        self.change_column(0)
                                        self.view.is_refresh_line = True

        def delete_line(self):
                &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
                self.hide_selection()
                self.modified = True
                # If file contains one or none line
                if len(self.lines) &lt;= 1:
                        # Clean the content of file
                        self.lines = [&#34;&#34;]
                        self.cursor_column = 0
                        self.cursor_line = 0
                        self.change_column(0)
                # If the current line is not the last of file
                elif self.cursor_line &lt; len(self.lines):
                        # Delete the line
                        self.cursor_column = 0
                        del self.lines[self.cursor_line]
                        self.view.scroll_part_up()
                        if self.cursor_line &gt;= len(self.lines):
                                self.cursor_line = len(self.lines)-1
                        self.change_column(0)
                self.view.set_refresh_after()

        def new_line(self):
                &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        line1 = self.lines[self.cursor_line][:self.cursor_column]+&#34;\n&#34;
                        line2 = self.lines[self.cursor_line][self.cursor_column:]
                        self.lines[self.cursor_line]=line1
                        self.lines.insert(self.cursor_line+1, line2)
                        self.view.scroll_part_down()
                        self.change_column(1)
                        self.view.set_refresh_before()

        def insert_char(self, char):
                &#34;&#34;&#34; Insert character &#34;&#34;&#34;
                self.modified = True
                self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column:]
                self.change_column(1)
                self.view.set_refresh_line()

        def replace_char(self, char):
                &#34;&#34;&#34; Replace character &#34;&#34;&#34;
                self.modified = True
                if self.cursor_line == len(self.lines)-1 and self.cursor_column &gt;= len(self.lines[self.cursor_line])-1:
                        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char
                        self.change_column(1)
                        self.view.set_refresh_line()
                # If it is the last char in the line
                elif self.lines[self.cursor_line][self.cursor_column] == &#34;\n&#34;:
                        # Append char to the line
                        self.insert_char(char)
                # Else the char must be replaced in the line
                else:
                        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column+1:]
                        self.change_column(1)
                        self.view.set_refresh_line()

        def open_selection(self):
                &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
                if self.selection_start is None:
                        self.selection_start = [self.cursor_column, self.cursor_line, self.get_tab_cursor(self.cursor_line)]

        def close_selection(self):
                &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
                if self.selection_start is not None:
                        self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]

        def select_all(self):
                &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
                self.selection_start = [0,0,0]
                lastLine = len(self.lines)-1
                lastColumn = len(self.lines[lastLine])-1
                self.move_cursor(lastLine, lastColumn)
                self.selection_end  = [lastColumn, lastLine, self.get_tab_cursor(lastLine, lastColumn)]
                self.view.set_refresh_all()

        def get_selection(self):
                &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
                if self.selection_start:
                        if self.selection_start[1] &gt; self.selection_end[1]:
                                return self.selection_end, self.selection_start
                        elif self.selection_start[1] &lt; self.selection_end[1]:
                                return self.selection_start, self.selection_end
                        elif self.selection_start[0] &lt; self.selection_end[0]:
                                return self.selection_start, self.selection_end
                        else:
                                return self.selection_end, self.selection_start
                else:
                        return None, None

        def arrow_up(self, keys):
                &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line(-1)

        def arrow_down(self, keys):
                &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line(1)

        def arrow_left(self, keys):
                &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(-len(keys))

        def arrow_right(self, keys):
                &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(len(keys))

        def select_up(self, keys):
                &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
                self.open_selection()
                self.change_line(-1)

        def select_down(self, keys):
                &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
                self.open_selection()
                self.change_line(1)

        def select_left(self, keys):
                &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(-len(keys))

        def select_right(self, keys):
                &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(len(keys))

        def select_home(self):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(-100000000000)

        def select_end(self):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(100000000000)

        def select_page_up(self, keys):
                &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
                self.open_selection()
                self.change_line((-self.view.height-1) * len(keys))
                self.change_column(-100000000000)

        def select_page_down(self, keys):
                &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
                self.open_selection()
                self.change_line((self.view.height+1) * len(keys))
                self.change_column(100000000000)

        def select_next_word(self):
                &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
                self.open_selection()
                self.move_word(1)

        def select_previous_word(self):
                &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
                self.open_selection()
                self.move_word(-1)

        def select_top(self):
                &#34;&#34;&#34; Manage select to the first line of text &#34;&#34;&#34;
                self.open_selection()
                self.change_line(-100000000000)

        def select_bottom(self):
                &#34;&#34;&#34; Manage select to the last line of text &#34;&#34;&#34;
                self.open_selection()
                self.change_line(100000000000)

        def page_up(self, keys):
                &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line((-self.view.height-1) * len(keys))

        def page_down(self, keys):
                &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line((self.view.height+1) * len(keys))

        def home(self):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(-100000000000)

        def end(self):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(100000000000)

        def add_char(self, keys):
                &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
                result = False

                if strings.isascii(keys[0]):
                        self.remove_selection()
                        for char in keys:
                                if strings.isascii(char):
                                        if self.replace_mode:
                                                self.replace_char(char)
                                        else:
                                                self.insert_char(char)
                                        result = True
                # if result is False:
                        # print(strings.dump(keys[0]))
                return result

        def find_next(self, text):
                &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
                # Get the selection
                selection_start, selection_end = self.get_selection()

                # Hide the selection
                self.hide_selection()

                # Set the start of search at the cursor position
                current_line   = self.cursor_line
                current_column = self.cursor_column

                # If selection activated
                if selection_start is not None and selection_end is not None:
                        # If selection is on one line
                        if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                                # If selection is exactly the size of text
                                if selection_start[0] == current_column:
                                        # Move the start of search after the text selected
                                        current_column = selection_end[0]

                # Find the text in next lines
                while current_line &lt; len(self.lines):
                        # Search text
                        pos = self.lines[current_line].find(text, current_column)

                        # If text found
                        if pos &gt;= 0:
                                # Move the cursor to the text found
                                self.cursor_line = current_line
                                self.cursor_column = pos + len(text)
                                self.change_column(0)
                                self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                                self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                                break
                        else:
                                # Set the search position at the begin of next line
                                current_column = 0
                                current_line += 1
                self.view.move()

        def find_previous(self, text):
                &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
                # Get the selection
                selection_start, selection_end = self.get_selection()

                # Hide the selection
                self.hide_selection()

                # Set the start of search at the cursor position
                current_line   = self.cursor_line
                current_column = self.cursor_column

                # If selection activated
                if selection_start is not None and selection_end is not None:
                        # If selection is on one line
                        if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                                # If selection is exactly the size of text
                                if selection_end[0] - selection_start[0] == len(text):
                                        # Move the start of search before the text selected
                                        current_column = selection_start[0]

                # While the line before the first line not reached
                while current_line &gt;= 0:
                        # Get the current line
                        line = self.lines[current_line]

                        # If the current column is negative
                        if current_column &lt; 0:
                                # Set the end of line
                                current_column = len(line)

                        # Search the text in reverse
                        pos = line.rfind(text, 0, current_column)

                        # If text found
                        if pos &gt;= 0:
                                self.cursor_line = current_line
                                self.cursor_column = pos
                                self.change_column(0)
                                self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                                self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                                break
                        else:
                                # Set the search position at the end of line
                                current_column = -1
                                current_line -= 1
                self.view.move()

        def hide_selection(self):
                &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
                self.view.hide_selection()
                self.selection_start = self.selection_end = None

        def goto(self, lineNumber):
                &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
                self.hide_selection()
                if lineNumber &lt; 0:
                        self.cursor_line = len(self.lines)-1
                elif lineNumber &lt; 1:
                        self.cursor_line = 1
                elif lineNumber &lt; len(self.lines):
                        self.cursor_line = lineNumber - 1
                else:
                        self.cursor_line = len(self.lines)-1
                self.cursor_column = 0
                self.change_column(0)
                self.view.move()

        def copy_clipboard(self):
                &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
                result = []
                if self.selection_start is not None:
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end
                        result = []
                        if sel_line_start == sel_line_end:
                                result.append(self.lines[sel_line_start][sel_column_start:sel_column_end])
                        else:
                                for line in range(sel_line_start, sel_line_end+1):
                                        if line == sel_line_start:
                                                part = self.lines[line][sel_column_start:]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][sel_column_start:])
                                        elif line == sel_line_end:
                                                part = self.lines[line][:sel_column_end]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][:sel_column_end])
                                        else:
                                                result.append(self.lines[line])
                return result

        def remove_selection(self):
                &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
                if self.selection_start is not None:
                        self.modified = True
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end
                        start = self.lines[sel_line_start][:sel_column_start]
                        end   = self.lines[sel_line_end  ][sel_column_end:]
                        self.lines[sel_line_start] = start + end
                        if sel_line_start &lt; sel_line_end:
                                for line in range(sel_line_end, sel_line_start,-1):
                                        del self.lines[line]
                        self.move_cursor(sel_line_start, sel_column_start)
                        self.hide_selection()
                        self.view.set_refresh_all()
                        return True
                return False

        def paste_clipboard(self, selection):
                &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
                if selection != []:
                        # Split the line with insertion
                        start = self.lines[self.cursor_line][:self.cursor_column]
                        end   = self.lines[self.cursor_line][self.cursor_column:]

                        # Paste the first line
                        self.lines[self.cursor_line] = start + selection[0]

                        self.cursor_line += 1

                        # Insert all lines from clipboard
                        for line in selection[1:-1]:
                                self.lines.insert(self.cursor_line, line)
                                self.cursor_line += 1

                        # If the last line of clipboard is not empty
                        if len(selection[-1]) &gt;= 1:
                                # If the last line of clipboard contains new line
                                if selection[-1][-1] == &#34;\n&#34;:
                                        if len(selection) &gt; 1:
                                                # Add the new line
                                                self.lines.insert(self.cursor_line, selection[-1])
                                                self.cursor_line += 1

                                        # Add the part after the insertion
                                        self.lines.insert(self.cursor_line, end)
                                        self.cursor_column = 0
                                else:
                                        if len(selection) &gt; 1:
                                                self.lines.insert(self.cursor_line, selection[-1] + end)
                                                self.cursor_column = len(selection[-1])
                                        else:
                                                self.cursor_line -= 1
                                                self.lines[self.cursor_line] += end
                                                self.cursor_column = len(start) + len(selection[-1])

                        self.move_cursor(self.cursor_line, self.cursor_column)

        def move_cursor(self, line, column):
                &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
                self.cursor_line   = line
                self.cursor_column = column
                self.change_column(0)
                self.get_tab_cursor_column()

        def copy(self):
                &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
                self.selection = self.copy_clipboard()

        def cut(self):
                &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
                self.modified = True
                self.selection = self.copy_clipboard()
                self.remove_selection()

        def paste(self):
                &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
                self.modified = True
                self.remove_selection()
                self.paste_clipboard(self.selection)
                self.view.set_refresh_all()
                self.hide_selection()

        def change_case(self):
                &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
                selection = self.copy_clipboard()
                if selection != []:
                        self.modified = True
                        selection_start = self.selection_start
                        selection_end   = self.selection_end

                        self.remove_selection()
                        isUpper = None
                        for line in selection:
                                for char in line:
                                        if strings.isupper(char):
                                                isUpper = True
                                                break
                                        elif strings.islower(char):
                                                isUpper = False
                                                break
                                if isUpper is not None:
                                        break
                        # pylint:disable=consider-using-enumerate
                        for line in range(len(selection)):
                                if isUpper:
                                        selection[line] = selection[line].lower()
                                else:
                                        selection[line] = selection[line].upper()
                        self.paste_clipboard(selection)
                        self.view.set_refresh_selection()
                        self.selection_start = selection_start
                        self.selection_end   = selection_end

        def comment(self):
                &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
                self.modified = True

                # If selection
                if self.selection_start is not None:
                        selection_start, selection_end = self.get_selection()
                        _, sel_line_start, _ = selection_start
                        _, sel_line_end,   _ = selection_end

                        # Add tabulation
                        for line in range(sel_line_start, sel_line_end+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] != &#39;#&#39;:
                                                self.lines[line] = &#34;#&#34; + self.lines[line]
                                        else:
                                                if len(self.lines[line]) &gt;= 1:
                                                        self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selection_start = [0,sel_line_start, 0]

                        # Get the length of last selected line
                        len_line_end =  len(self.lines[sel_line_end])

                        # Move the end of selection at the end of line selected
                        self.selection_end   = [len_line_end-1, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end-1)]
                        self.view.set_refresh_selection()
                else:
                        if len(self.lines[self.cursor_line]) &gt;= 1:
                                # If nothing selected
                                if self.lines[self.cursor_line][0] == &#34;#&#34;:
                                        self.lines[self.cursor_line] = self.lines[self.cursor_line][1:]
                                        if self.cursor_column &gt; 0:
                                                self.change_column(-1)
                                else:
                                        self.lines[self.cursor_line] = &#34;#&#34; + self.lines[self.cursor_line]
                                        self.change_column(1)
                        self.view.set_refresh_line()

        def indent(self, keys):
                &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
                # If nothing selected
                if self.selection_start is None:
                        self.add_char(keys)
                else:
                        self.modified = True
                        # Indent selection
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end

                        # If a part of line selected
                        if sel_line_start == sel_line_end and not (sel_column_start == 0 and sel_column_end == len(self.lines[sel_line_end])-1):
                                self.add_char(INDENT)
                        else:
                                # If the last line selected is at beginning of line
                                if sel_column_end == 0:
                                        # This line must not be indented
                                        sel_line_end -= 1

                                # Add tabulation
                                for line in range(sel_line_start, sel_line_end+1):
                                        self.lines[line] = &#34;\t&#34; + self.lines[line]

                                # Move the start selection to the start of first selected line
                                self.selection_start = [0,sel_line_start, 0]

                                # If the last line selected is not at beginning of line
                                if sel_column_end &gt; 0:
                                        # Get the length of last selected line
                                        len_line_end =  len(self.lines[sel_line_end])

                                        # If the end of selection is not on the last line
                                        if sel_line_end &lt; len(self.lines)-1:
                                                len_line_end -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selection_end  = [0, sel_line_end+1, 0]
                        self.view.set_refresh_selection()

        def unindent(self, keys):
                &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
                # If nothing selected
                if self.selection_start is None:
                        self.backspace()
                else:
                        self.modified = True

                        # Unindent selection
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end

                        # If the selection is only alone line
                        if sel_line_start == sel_line_end:
                                self.hide_selection()
                        else:
                                # If the last line selected is at beginning of line
                                if sel_column_end == 0:
                                        # This line must not be indented
                                        sel_line_end -= 1

                                # Remove indentation
                                for line in range(sel_line_start, sel_line_end+1):
                                        if len(self.lines[line]) &gt;= 1:
                                                if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                        self.lines[line] = self.lines[line][1:]

                                # Move the start selection to the start of first selected line
                                self.selection_start = [0,sel_line_start, 0]

                                # If the last line selected is not at beginning of line
                                if sel_column_end &gt; 0:
                                        # Get the length of last selected line
                                        len_line_end =  len(self.lines[sel_line_end])

                                        # If the end of selection is not on the last line
                                        if sel_line_end &lt; len(self.lines)-1:
                                                len_line_end -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selection_end  = [0, sel_line_end+1, 0]
                        self.view.set_refresh_selection()

        def replace(self, old, new):
                &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
                if self.read_only is False:
                        selection = self.copy_clipboard()
                        if len(selection) == 1:
                                if selection[0] == old:
                                        self.delete()
                                        self.insert_char(new)
                                        return True
                return False

        def get_cursor_char(self):
                &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
                try:
                        return self.lines[self.cursor_line][self.cursor_column]
                except:
                        return None

        def move_word(self, direction):
                &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
                state = 0
                while self.change_column(direction):
                        current_char = self.get_cursor_char()
                        if current_char is None:
                                break
                        elif strings.ispunctuation(current_char):
                                if state == 0:
                                        state = 2
                                elif state == 1:
                                        break
                        elif strings.isalpha(current_char):
                                if state == 0:
                                        state = 1
                                elif state == 2:
                                        break
                        elif strings.isspace(current_char):
                                if state == 1:
                                        break
                                if state == 2:
                                        break

        def next_word(self):
                &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
                self.hide_selection()
                self.move_word(1)
                self.view.move()

        def previous_word(self):
                &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
                self.hide_selection()
                self.move_word(-1)
                self.view.move()

        def top(self):
                &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
                self.goto(1)

        def bottom(self):
                &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
                self.goto(100000000000)

        def treat_char(self, keys):
                &#34;&#34;&#34; Treat character entered &#34;&#34;&#34;
                char = ord(keys[0][0])
                if self.read_only is False:
                        if char &gt;= 0x20 and char != 0x7F:
                                self.add_char(keys)
                                return True
                return False

        def treat_key(self, keys):
                &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
                if self.treat_char(keys) is False:
                        # Move in the edit field
                        if   keys[0] in UP  :            self.arrow_up(keys)
                        elif keys[0] in DOWN:            self.arrow_down(keys)
                        elif keys[0] in LEFT:            self.arrow_left(keys)
                        elif keys[0] in RIGHT:           self.arrow_right(keys)
                        elif keys[0] in HOME:            self.home()
                        elif keys[0] in END:             self.end()
                        elif keys[0] in PAGE_UP:         self.page_up(keys)
                        elif keys[0] in PAGE_DOWN:       self.page_down(keys)
                        elif keys[0] in TOP:             self.top()
                        elif keys[0] in BOTTOM:          self.bottom()
                        elif keys[0] in NEXT_WORD:       self.next_word()
                        elif keys[0] in PREVIOUS_WORD:   self.previous_word()
                        # Selection the edit field
                        elif keys[0] in SELECT_UP:       self.select_up(keys)
                        elif keys[0] in SELECT_DOWN:     self.select_down(keys)
                        elif keys[0] in SELECT_RIGHT:    self.select_right(keys)
                        elif keys[0] in SELECT_LEFT:     self.select_left(keys)
                        elif keys[0] in SELECT_HOME:     self.select_home()
                        elif keys[0] in SELECT_END:      self.select_end()
                        elif keys[0] in SELECT_TOP:      self.select_top()
                        elif keys[0] in SELECT_BOTTOM:   self.select_bottom()
                        elif keys[0] in SELECT_PAGE_UP:  self.select_page_up(keys)
                        elif keys[0] in SELECT_PAGE_DOWN:self.select_page_down(keys)
                        elif keys[0] in SELECT_ALL:      self.select_all()
                        elif keys[0] in SELECT_NEXT_WORD:self.select_next_word()
                        elif keys[0] in SELECT_PREV_WORD:self.select_previous_word()

                        # If the edit is not in read only
                        elif self.read_only is False:
                                # Modification in the edit field
                                if   keys[0] in COPY:            self.copy()
                                elif keys[0] in CUT:             self.cut()
                                elif keys[0] in PASTE:           self.paste()

                                elif keys[0] in INDENT:          self.indent(keys)
                                elif keys[0] in UNINDENT:        self.unindent(keys)
                                elif keys[0] in CHANGE_CASE:     self.change_case()
                                elif keys[0] in COMMENT:         self.comment()

                                elif keys[0] in BACKSPACE:       self.backspace()
                                elif keys[0] in DELETE:          self.delete()
                                elif keys[0] in NEW_LINE:        self.new_line()
                                elif keys[0] in DELETE_LINE:     self.delete_line()
                        # else: self.add_char(keys)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.Text.add_char"><code class="name flex">
<span>def <span class="ident">add_char</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage other key, add character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_char(self, keys):
        &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
        result = False

        if strings.isascii(keys[0]):
                self.remove_selection()
                for char in keys:
                        if strings.isascii(char):
                                if self.replace_mode:
                                        self.replace_char(char)
                                else:
                                        self.insert_char(char)
                                result = True
        # if result is False:
                # print(strings.dump(keys[0]))
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrow_down"><code class="name flex">
<span>def <span class="ident">arrow_down</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow_down(self, keys):
        &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
        self.hide_selection()
        self.change_line(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrow_left"><code class="name flex">
<span>def <span class="ident">arrow_left</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow left key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow_left(self, keys):
        &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
        self.hide_selection()
        self.change_column(-len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrow_right"><code class="name flex">
<span>def <span class="ident">arrow_right</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow right key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow_right(self, keys):
        &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
        self.hide_selection()
        self.change_column(len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrow_up"><code class="name flex">
<span>def <span class="ident">arrow_up</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow_up(self, keys):
        &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
        self.hide_selection()
        self.change_line(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.backspace"><code class="name flex">
<span>def <span class="ident">backspace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the backspace key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backspace(self):
        &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
        self.modified = True
        if self.remove_selection() is False:
                # The cursor not in the begining of line
                if self.cursor_column &gt;= 1:
                        line = self.lines[self.cursor_line]
                        line = line[0:self.cursor_column-1:]+ line[self.cursor_column  : :]
                        self.lines[self.cursor_line] = line
                        self.change_column(-1)
                        self.view.set_refresh_line()
                # The cursor is on the begining of line
                else:
                        # If the cursor not on the first line
                        if self.cursor_line &gt;= 1:
                                # Copy the current line to the end of previous line
                                self.cursor_column = len(self.lines[self.cursor_line-1])
                                self.lines[self.cursor_line-1] = self.lines[self.cursor_line-1][:-1] + self.lines[self.cursor_line]
                                del self.lines[self.cursor_line]
                                self.view.scroll_part_up()
                                self.cursor_line -= 1
                                self.view.set_refresh_after()
                                self.change_column(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.bottom"><code class="name flex">
<span>def <span class="ident">bottom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the last line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bottom(self):
        &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
        self.goto(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.change_case"><code class="name flex">
<span>def <span class="ident">change_case</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the case of selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_case(self):
        &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
        selection = self.copy_clipboard()
        if selection != []:
                self.modified = True
                selection_start = self.selection_start
                selection_end   = self.selection_end

                self.remove_selection()
                isUpper = None
                for line in selection:
                        for char in line:
                                if strings.isupper(char):
                                        isUpper = True
                                        break
                                elif strings.islower(char):
                                        isUpper = False
                                        break
                        if isUpper is not None:
                                break
                # pylint:disable=consider-using-enumerate
                for line in range(len(selection)):
                        if isUpper:
                                selection[line] = selection[line].lower()
                        else:
                                selection[line] = selection[line].upper()
                self.paste_clipboard(selection)
                self.view.set_refresh_selection()
                self.selection_start = selection_start
                self.selection_end   = selection_end</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.change_column"><code class="name flex">
<span>def <span class="ident">change_column</span></span>(<span>self, move_column)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor on another column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_column(self, move_column):
        &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
        cursor_line   = self.cursor_line
        cursor_column = self.cursor_column
        # If the cursor go to the previous line
        if move_column + self.cursor_column &lt; 0:
                # If start of line
                if abs(move_column) &gt; 1:
                        self.cursor_column = 0
                # If move to the left and must go to previous line
                elif self.cursor_line &gt; 0:
                        self.cursor_line -= 1
                        self.cursor_column = len(self.lines[self.cursor_line])-1
        # If the cursor is at the end of line
        elif move_column + self.cursor_column &gt; len(self.lines[self.cursor_line])-1:
                # If the cursor is on the last line of file
                if abs(move_column) &gt; 1 or self.cursor_line+1 == len(self.lines):
                        # If the file is empty
                        if self.lines[self.cursor_line] == &#34;&#34;:
                                self.cursor_column = 0
                                self.tab_cursor_column = 0
                        # If the last line of contains return char
                        elif self.lines[self.cursor_line][-1] == &#34;\n&#34;:
                                # Move cursor before return
                                self.cursor_column = len(self.lines[self.cursor_line])-1
                        else:
                                # Move cursor after the last char
                                self.cursor_column = len(self.lines[self.cursor_line])

                # If the cursor is on the end of line and must change of line
                elif self.cursor_line+1 &lt; len(self.lines):
                        self.cursor_line += 1
                        self.cursor_column = 0
                        self.tab_cursor_column = 0
        # Normal move of cursor
        else:
                # Next or previous column
                self.cursor_column += move_column
        if abs(move_column) &gt; 0:
                self.get_tab_cursor_column()
        self.close_selection()
        self.view.move()
        if self.cursor_column == cursor_column and self.cursor_line == cursor_line:
                return False
        else:
                return True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.change_line"><code class="name flex">
<span>def <span class="ident">change_line</span></span>(<span>self, moveLine)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor on another line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_line(self, moveLine):
        &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
        # If cursor is before the first line
        if moveLine + self.cursor_line &lt; 0:
                # Set the cursor to the first line
                self.cursor_line = 0
                self.cursor_column = 0
                self.change_column(0)
        # If the cursor is after the last line
        elif moveLine + self.cursor_line &gt;= len(self.lines):
                self.cursor_line = len(self.lines) -1
                self.cursor_column = len(self.lines[self.cursor_line])
                self.change_column(0)
        # else the cursor is in the lines of text
        else:
                previousLine = self.cursor_line
                self.cursor_line += moveLine
                if len(self.lines) - 1 == self.cursor_line:
                        lenLine = len(self.lines[self.cursor_line])
                else:
                        lenLine = len(self.lines[self.cursor_line])-1

                self.set_cursor_column()
                # If the new cursor position is outside the last line of text
                if self.cursor_column &gt; lenLine:
                        self.cursor_column = lenLine

        if self.selection_start is not None:
                self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.close_selection"><code class="name flex">
<span>def <span class="ident">close_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminate selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_selection(self):
        &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
        if self.selection_start is not None:
                self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.comment"><code class="name flex">
<span>def <span class="ident">comment</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Comment the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comment(self):
        &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
        self.modified = True

        # If selection
        if self.selection_start is not None:
                selection_start, selection_end = self.get_selection()
                _, sel_line_start, _ = selection_start
                _, sel_line_end,   _ = selection_end

                # Add tabulation
                for line in range(sel_line_start, sel_line_end+1):
                        if len(self.lines[line]) &gt;= 1:
                                if self.lines[line][0] != &#39;#&#39;:
                                        self.lines[line] = &#34;#&#34; + self.lines[line]
                                else:
                                        if len(self.lines[line]) &gt;= 1:
                                                self.lines[line] = self.lines[line][1:]

                # Move the start selection to the start of first selected line
                self.selection_start = [0,sel_line_start, 0]

                # Get the length of last selected line
                len_line_end =  len(self.lines[sel_line_end])

                # Move the end of selection at the end of line selected
                self.selection_end   = [len_line_end-1, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end-1)]
                self.view.set_refresh_selection()
        else:
                if len(self.lines[self.cursor_line]) &gt;= 1:
                        # If nothing selected
                        if self.lines[self.cursor_line][0] == &#34;#&#34;:
                                self.lines[self.cursor_line] = self.lines[self.cursor_line][1:]
                                if self.cursor_column &gt; 0:
                                        self.change_column(-1)
                        else:
                                self.lines[self.cursor_line] = &#34;#&#34; + self.lines[self.cursor_line]
                                self.change_column(1)
                self.view.set_refresh_line()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage copy key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
        &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
        self.selection = self.copy_clipboard()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.copy_clipboard"><code class="name flex">
<span>def <span class="ident">copy_clipboard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy selection to clipboard</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_clipboard(self):
        &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
        result = []
        if self.selection_start is not None:
                selection_start, selection_end = self.get_selection()
                sel_column_start, sel_line_start, dummy = selection_start
                sel_column_end,   sel_line_end,   dummy = selection_end
                result = []
                if sel_line_start == sel_line_end:
                        result.append(self.lines[sel_line_start][sel_column_start:sel_column_end])
                else:
                        for line in range(sel_line_start, sel_line_end+1):
                                if line == sel_line_start:
                                        part = self.lines[line][sel_column_start:]
                                        if part != &#34;&#34;:
                                                result.append(self.lines[line][sel_column_start:])
                                elif line == sel_line_end:
                                        part = self.lines[line][:sel_column_end]
                                        if part != &#34;&#34;:
                                                result.append(self.lines[line][:sel_column_end])
                                else:
                                        result.append(self.lines[line])
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.cut"><code class="name flex">
<span>def <span class="ident">cut</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage cut key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut(self):
        &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
        self.modified = True
        self.selection = self.copy_clipboard()
        self.remove_selection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the delete key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
        &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
        self.modified = True
        if self.remove_selection() is False:
                line = self.lines[self.cursor_line]
                if self.cursor_column &lt; len(line):
                        # If the line is empty
                        if line[self.cursor_column] == &#34;\n&#34;:
                                # If the cursor not at end of files
                                if self.cursor_line &lt; len(self.lines)-1:
                                        # Copy the next line to the current line
                                        self.lines[self.cursor_line] = line[:self.cursor_column] + self.lines[self.cursor_line+1]
                                        del self.lines[self.cursor_line+1]
                                        self.view.scroll_part_up()
                                        self.view.set_refresh_after()
                        # Else the char is deleted in the middle of line
                        else:
                                line = line[0:self.cursor_column:]+ line[self.cursor_column+1  : :]
                                self.lines[self.cursor_line] = line
                                self.change_column(0)
                                self.view.is_refresh_line = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.delete_line"><code class="name flex">
<span>def <span class="ident">delete_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the delete of line key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_line(self):
        &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
        self.hide_selection()
        self.modified = True
        # If file contains one or none line
        if len(self.lines) &lt;= 1:
                # Clean the content of file
                self.lines = [&#34;&#34;]
                self.cursor_column = 0
                self.cursor_line = 0
                self.change_column(0)
        # If the current line is not the last of file
        elif self.cursor_line &lt; len(self.lines):
                # Delete the line
                self.cursor_column = 0
                del self.lines[self.cursor_line]
                self.view.scroll_part_up()
                if self.cursor_line &gt;= len(self.lines):
                        self.cursor_line = len(self.lines)-1
                self.change_column(0)
        self.view.set_refresh_after()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage end key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self):
        &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
        self.hide_selection()
        self.change_column(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.find_next"><code class="name flex">
<span>def <span class="ident">find_next</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Find next researched text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_next(self, text):
        &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
        # Get the selection
        selection_start, selection_end = self.get_selection()

        # Hide the selection
        self.hide_selection()

        # Set the start of search at the cursor position
        current_line   = self.cursor_line
        current_column = self.cursor_column

        # If selection activated
        if selection_start is not None and selection_end is not None:
                # If selection is on one line
                if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                        # If selection is exactly the size of text
                        if selection_start[0] == current_column:
                                # Move the start of search after the text selected
                                current_column = selection_end[0]

        # Find the text in next lines
        while current_line &lt; len(self.lines):
                # Search text
                pos = self.lines[current_line].find(text, current_column)

                # If text found
                if pos &gt;= 0:
                        # Move the cursor to the text found
                        self.cursor_line = current_line
                        self.cursor_column = pos + len(text)
                        self.change_column(0)
                        self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                        self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                        break
                else:
                        # Set the search position at the begin of next line
                        current_column = 0
                        current_line += 1
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.find_previous"><code class="name flex">
<span>def <span class="ident">find_previous</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Find previous researched text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_previous(self, text):
        &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
        # Get the selection
        selection_start, selection_end = self.get_selection()

        # Hide the selection
        self.hide_selection()

        # Set the start of search at the cursor position
        current_line   = self.cursor_line
        current_column = self.cursor_column

        # If selection activated
        if selection_start is not None and selection_end is not None:
                # If selection is on one line
                if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                        # If selection is exactly the size of text
                        if selection_end[0] - selection_start[0] == len(text):
                                # Move the start of search before the text selected
                                current_column = selection_start[0]

        # While the line before the first line not reached
        while current_line &gt;= 0:
                # Get the current line
                line = self.lines[current_line]

                # If the current column is negative
                if current_column &lt; 0:
                        # Set the end of line
                        current_column = len(line)

                # Search the text in reverse
                pos = line.rfind(text, 0, current_column)

                # If text found
                if pos &gt;= 0:
                        self.cursor_line = current_line
                        self.cursor_column = pos
                        self.change_column(0)
                        self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                        self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                        break
                else:
                        # Set the search position at the end of line
                        current_column = -1
                        current_line -= 1
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_count_lines"><code class="name flex">
<span>def <span class="ident">get_count_lines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the total of lines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_count_lines(self):
        &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
        return len(self.lines)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_cursor_char"><code class="name flex">
<span>def <span class="ident">get_cursor_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the char on the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cursor_char(self):
        &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
        try:
                return self.lines[self.cursor_line][self.cursor_column]
        except:
                return None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_cursor_line"><code class="name flex">
<span>def <span class="ident">get_cursor_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current line of the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cursor_line(self):
        &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
        return self.cursor_line</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_selection"><code class="name flex">
<span>def <span class="ident">get_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get information about selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_selection(self):
        &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
        if self.selection_start:
                if self.selection_start[1] &gt; self.selection_end[1]:
                        return self.selection_end, self.selection_start
                elif self.selection_start[1] &lt; self.selection_end[1]:
                        return self.selection_start, self.selection_end
                elif self.selection_start[0] &lt; self.selection_end[0]:
                        return self.selection_start, self.selection_end
                else:
                        return self.selection_end, self.selection_start
        else:
                return None, None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_tab_cursor"><code class="name flex">
<span>def <span class="ident">get_tab_cursor</span></span>(<span>self, current_line, current_column=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position of cursor with line with tabulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tab_cursor(self, current_line, current_column=None):
        &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
        if current_column is None:
                cursor_column = self.cursor_column
        else:
                cursor_column = current_column
        line = self.lines[current_line]
        if &#34;\t&#34; in line:
                tab_cursor_column   = 0
                column = 0
                lenLine = len(line)
                while column &lt; cursor_column:
                        if line[column] == &#34;\t&#34;:
                                pos = tab_cursor_column%self.tab_size
                                tab_cursor_column += self.tab_size-pos
                                column          += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        partSize = tab - column
                                else:
                                        partSize = lenLine - column
                                if column + partSize &gt; cursor_column:
                                        partSize = cursor_column - column
                                tab_cursor_column += partSize
                                column          += partSize
                return tab_cursor_column
        else:
                return cursor_column</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_tab_cursor_column"><code class="name flex">
<span>def <span class="ident">get_tab_cursor_column</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the column of cursor in tabuled line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tab_cursor_column(self):
        &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
        line = self.lines[self.cursor_line]
        column = 0
        self.tab_cursor_column = 0
        while column &lt; self.cursor_column:
                if line[column] == &#34;\t&#34;:
                        pos = self.tab_cursor_column%self.tab_size
                        self.tab_cursor_column += self.tab_size-pos
                        column += 1
                else:
                        tab = line.find(&#34;\t&#34;,column)
                        if tab &gt; 0:
                                delta = tab - column
                                if column + delta &gt; self.cursor_column:
                                        delta = self.cursor_column - column
                                        self.tab_cursor_column += delta
                                        column += delta
                                else:
                                        self.tab_cursor_column += delta
                                        column += delta
                        else:
                                delta = self.cursor_column - column
                                self.tab_cursor_column += delta
                                column += delta</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_tab_line"><code class="name flex">
<span>def <span class="ident">get_tab_line</span></span>(<span>self, current_line=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the tabuled line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tab_line(self, current_line = None):
        &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
        line = self.lines[current_line]
        if &#34;\t&#34; in line:
                tabLine = &#34;&#34;
                tab_cursor_column   = 0
                lenLine = len(line)
                column = 0
                while column &lt; lenLine:
                        char = line[column]
                        if char == &#34;\t&#34;:
                                pos = tab_cursor_column%self.tab_size
                                tab_cursor_column += self.tab_size-pos
                                tabLine         += &#34; &#34;*(self.tab_size-pos)
                                column          += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        part = line[column:tab]
                                else:
                                        part = line[column:]
                                tab_cursor_column += len(part)
                                tabLine         += part
                                column          += len(part)
        else:
                tabLine = line
        return tabLine</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, lineNumber)</span>
</code></dt>
<dd>
<div class="desc"><p>Goto specified line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self, lineNumber):
        &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
        self.hide_selection()
        if lineNumber &lt; 0:
                self.cursor_line = len(self.lines)-1
        elif lineNumber &lt; 1:
                self.cursor_line = 1
        elif lineNumber &lt; len(self.lines):
                self.cursor_line = lineNumber - 1
        else:
                self.cursor_line = len(self.lines)-1
        self.cursor_column = 0
        self.change_column(0)
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.hide_selection"><code class="name flex">
<span>def <span class="ident">hide_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_selection(self):
        &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
        self.view.hide_selection()
        self.selection_start = self.selection_end = None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.home"><code class="name flex">
<span>def <span class="ident">home</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage home key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def home(self):
        &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
        self.hide_selection()
        self.change_column(-100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.indent"><code class="name flex">
<span>def <span class="ident">indent</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage tabulation key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indent(self, keys):
        &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
        # If nothing selected
        if self.selection_start is None:
                self.add_char(keys)
        else:
                self.modified = True
                # Indent selection
                selection_start, selection_end = self.get_selection()
                sel_column_start, sel_line_start, dummy = selection_start
                sel_column_end,   sel_line_end,   dummy = selection_end

                # If a part of line selected
                if sel_line_start == sel_line_end and not (sel_column_start == 0 and sel_column_end == len(self.lines[sel_line_end])-1):
                        self.add_char(INDENT)
                else:
                        # If the last line selected is at beginning of line
                        if sel_column_end == 0:
                                # This line must not be indented
                                sel_line_end -= 1

                        # Add tabulation
                        for line in range(sel_line_start, sel_line_end+1):
                                self.lines[line] = &#34;\t&#34; + self.lines[line]

                        # Move the start selection to the start of first selected line
                        self.selection_start = [0,sel_line_start, 0]

                        # If the last line selected is not at beginning of line
                        if sel_column_end &gt; 0:
                                # Get the length of last selected line
                                len_line_end =  len(self.lines[sel_line_end])

                                # If the end of selection is not on the last line
                                if sel_line_end &lt; len(self.lines)-1:
                                        len_line_end -= 1

                                # Move the end of selection at the end of line selected
                                self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                        else:
                                # Move the end of selection at the start of the last line selected
                                self.selection_end  = [0, sel_line_end+1, 0]
                self.view.set_refresh_selection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.insert_char"><code class="name flex">
<span>def <span class="ident">insert_char</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_char(self, char):
        &#34;&#34;&#34; Insert character &#34;&#34;&#34;
        self.modified = True
        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column:]
        self.change_column(1)
        self.view.set_refresh_line()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename_)</span>
</code></dt>
<dd>
<div class="desc"><p>Load file in the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, filename_):
        &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
        self.filename = None
        try:
                self.lines = []
                self.filename = filename_
                file = open(filename_, &#34;r&#34;)
                line = file.readline()
                while line != &#34;&#34;:
                        self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                        line = file.readline()
                file.close()
                if len(self.lines) == 0:
                        self.lines = [&#34;&#34;]
        except MemoryError:
                # pylint: disable=raise-missing-from
                raise MemoryError()
        except OSError:
                self.lines = [&#34;&#34;]
                # File not existing
        except Exception as err:
                logger.syslog(err)
                self.lines = [&#34;&#34;]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.move_cursor"><code class="name flex">
<span>def <span class="ident">move_cursor</span></span>(<span>self, line, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_cursor(self, line, column):
        &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
        self.cursor_line   = line
        self.cursor_column = column
        self.change_column(0)
        self.get_tab_cursor_column()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.move_word"><code class="name flex">
<span>def <span class="ident">move_word</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_word(self, direction):
        &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
        state = 0
        while self.change_column(direction):
                current_char = self.get_cursor_char()
                if current_char is None:
                        break
                elif strings.ispunctuation(current_char):
                        if state == 0:
                                state = 2
                        elif state == 1:
                                break
                elif strings.isalpha(current_char):
                        if state == 0:
                                state = 1
                        elif state == 2:
                                break
                elif strings.isspace(current_char):
                        if state == 1:
                                break
                        if state == 2:
                                break</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.new_line"><code class="name flex">
<span>def <span class="ident">new_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the newline key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_line(self):
        &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
        self.modified = True
        if self.remove_selection() is False:
                line1 = self.lines[self.cursor_line][:self.cursor_column]+&#34;\n&#34;
                line2 = self.lines[self.cursor_line][self.cursor_column:]
                self.lines[self.cursor_line]=line1
                self.lines.insert(self.cursor_line+1, line2)
                self.view.scroll_part_down()
                self.change_column(1)
                self.view.set_refresh_before()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.next_word"><code class="name flex">
<span>def <span class="ident">next_word</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the next word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_word(self):
        &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
        self.hide_selection()
        self.move_word(1)
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.open_selection"><code class="name flex">
<span>def <span class="ident">open_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_selection(self):
        &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
        if self.selection_start is None:
                self.selection_start = [self.cursor_column, self.cursor_line, self.get_tab_cursor(self.cursor_line)]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.page_down"><code class="name flex">
<span>def <span class="ident">page_down</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage page down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_down(self, keys):
        &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
        self.hide_selection()
        self.change_line((self.view.height+1) * len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.page_up"><code class="name flex">
<span>def <span class="ident">page_up</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage page up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_up(self, keys):
        &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
        self.hide_selection()
        self.change_line((-self.view.height-1) * len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.paste"><code class="name flex">
<span>def <span class="ident">paste</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage paste key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paste(self):
        &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
        self.modified = True
        self.remove_selection()
        self.paste_clipboard(self.selection)
        self.view.set_refresh_all()
        self.hide_selection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.paste_clipboard"><code class="name flex">
<span>def <span class="ident">paste_clipboard</span></span>(<span>self, selection)</span>
</code></dt>
<dd>
<div class="desc"><p>Paste clipboard at the cursor position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paste_clipboard(self, selection):
        &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
        if selection != []:
                # Split the line with insertion
                start = self.lines[self.cursor_line][:self.cursor_column]
                end   = self.lines[self.cursor_line][self.cursor_column:]

                # Paste the first line
                self.lines[self.cursor_line] = start + selection[0]

                self.cursor_line += 1

                # Insert all lines from clipboard
                for line in selection[1:-1]:
                        self.lines.insert(self.cursor_line, line)
                        self.cursor_line += 1

                # If the last line of clipboard is not empty
                if len(selection[-1]) &gt;= 1:
                        # If the last line of clipboard contains new line
                        if selection[-1][-1] == &#34;\n&#34;:
                                if len(selection) &gt; 1:
                                        # Add the new line
                                        self.lines.insert(self.cursor_line, selection[-1])
                                        self.cursor_line += 1

                                # Add the part after the insertion
                                self.lines.insert(self.cursor_line, end)
                                self.cursor_column = 0
                        else:
                                if len(selection) &gt; 1:
                                        self.lines.insert(self.cursor_line, selection[-1] + end)
                                        self.cursor_column = len(selection[-1])
                                else:
                                        self.cursor_line -= 1
                                        self.lines[self.cursor_line] += end
                                        self.cursor_column = len(start) + len(selection[-1])

                self.move_cursor(self.cursor_line, self.cursor_column)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.previous_word"><code class="name flex">
<span>def <span class="ident">previous_word</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the previous word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previous_word(self):
        &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
        self.hide_selection()
        self.move_word(-1)
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.remove_selection"><code class="name flex">
<span>def <span class="ident">remove_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_selection(self):
        &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
        if self.selection_start is not None:
                self.modified = True
                selection_start, selection_end = self.get_selection()
                sel_column_start, sel_line_start, dummy = selection_start
                sel_column_end,   sel_line_end,   dummy = selection_end
                start = self.lines[sel_line_start][:sel_column_start]
                end   = self.lines[sel_line_end  ][sel_column_end:]
                self.lines[sel_line_start] = start + end
                if sel_line_start &lt; sel_line_end:
                        for line in range(sel_line_end, sel_line_start,-1):
                                del self.lines[line]
                self.move_cursor(sel_line_start, sel_column_start)
                self.hide_selection()
                self.view.set_refresh_all()
                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, old, new)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, old, new):
        &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
        if self.read_only is False:
                selection = self.copy_clipboard()
                if len(selection) == 1:
                        if selection[0] == old:
                                self.delete()
                                self.insert_char(new)
                                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.replace_char"><code class="name flex">
<span>def <span class="ident">replace_char</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_char(self, char):
        &#34;&#34;&#34; Replace character &#34;&#34;&#34;
        self.modified = True
        if self.cursor_line == len(self.lines)-1 and self.cursor_column &gt;= len(self.lines[self.cursor_line])-1:
                self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char
                self.change_column(1)
                self.view.set_refresh_line()
        # If it is the last char in the line
        elif self.lines[self.cursor_line][self.cursor_column] == &#34;\n&#34;:
                # Append char to the line
                self.insert_char(char)
        # Else the char must be replaced in the line
        else:
                self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column+1:]
                self.change_column(1)
                self.view.set_refresh_line()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save text in the file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
        &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
        result = False
        if self.read_only is False:
                if self.filename is not None:
                        try:
                                file = open(self.filename, &#34;w&#34;)
                                for line in self.lines:
                                        file.write(line)
                                file.close()
                                self.modified = False
                                result = True
                        except Exception as err:
                                logger.syslog(err)
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_all"><code class="name flex">
<span>def <span class="ident">select_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Do a select all</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_all(self):
        &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
        self.selection_start = [0,0,0]
        lastLine = len(self.lines)-1
        lastColumn = len(self.lines[lastLine])-1
        self.move_cursor(lastLine, lastColumn)
        self.selection_end  = [lastColumn, lastLine, self.get_tab_cursor(lastLine, lastColumn)]
        self.view.set_refresh_all()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_bottom"><code class="name flex">
<span>def <span class="ident">select_bottom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select to the last line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_bottom(self):
        &#34;&#34;&#34; Manage select to the last line of text &#34;&#34;&#34;
        self.open_selection()
        self.change_line(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_down"><code class="name flex">
<span>def <span class="ident">select_down</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_down(self, keys):
        &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
        self.open_selection()
        self.change_line(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_end"><code class="name flex">
<span>def <span class="ident">select_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage end key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_end(self):
        &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
        self.open_selection()
        self.change_column(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_home"><code class="name flex">
<span>def <span class="ident">select_home</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage home key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_home(self):
        &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
        self.open_selection()
        self.change_column(-100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_left"><code class="name flex">
<span>def <span class="ident">select_left</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select left key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_left(self, keys):
        &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
        self.open_selection()
        self.change_column(-len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_next_word"><code class="name flex">
<span>def <span class="ident">select_next_word</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select next word key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_next_word(self):
        &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
        self.open_selection()
        self.move_word(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_page_down"><code class="name flex">
<span>def <span class="ident">select_page_down</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select page down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_page_down(self, keys):
        &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
        self.open_selection()
        self.change_line((self.view.height+1) * len(keys))
        self.change_column(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_page_up"><code class="name flex">
<span>def <span class="ident">select_page_up</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select page up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_page_up(self, keys):
        &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
        self.open_selection()
        self.change_line((-self.view.height-1) * len(keys))
        self.change_column(-100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_previous_word"><code class="name flex">
<span>def <span class="ident">select_previous_word</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select previous word key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_previous_word(self):
        &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
        self.open_selection()
        self.move_word(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_right"><code class="name flex">
<span>def <span class="ident">select_right</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select right key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_right(self, keys):
        &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
        self.open_selection()
        self.change_column(len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_top"><code class="name flex">
<span>def <span class="ident">select_top</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select to the first line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_top(self):
        &#34;&#34;&#34; Manage select to the first line of text &#34;&#34;&#34;
        self.open_selection()
        self.change_line(-100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_up"><code class="name flex">
<span>def <span class="ident">select_up</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_up(self, keys):
        &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
        self.open_selection()
        self.change_line(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.set_cursor_column"><code class="name flex">
<span>def <span class="ident">set_cursor_column</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the line change compute the cursor position with tabulation in the line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cursor_column(self):
        &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
        line = self.lines[self.cursor_line]
        column = 0
        tab_cursor_column = 0
        lenLine = len(line)
        column = 0
        while column &lt; lenLine:
                char = line[column]
                # If the previous position found exactly in the current line
                if tab_cursor_column == self.tab_cursor_column:
                        self.cursor_column = column
                        break
                # If the previous position not found in the current line
                if tab_cursor_column &gt; self.tab_cursor_column:
                        # Keep last existing position
                        self.cursor_column = column
                        break
                # If tabulation found
                if char == &#34;\t&#34;:
                        tab_cursor_column += self.tab_size-(tab_cursor_column%self.tab_size)
                        column += 1
                else:
                        # Optimization to accelerate the cursor position
                        tab = line.find(&#34;\t&#34;, column)

                        # Tabulation found
                        if tab &gt; 0:
                                delta = tab - column
                                # If the tabulation position is after the previous tabulation cursor
                                if delta + tab_cursor_column &gt; self.tab_cursor_column:
                                        # Move the cursor to the left
                                        self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                        break
                                else:
                                        # Another tabulation found, move it after
                                        tab_cursor_column += delta
                                        column += delta
                        # Tabulation not found
                        else:
                                # Move the cursor to the end of line
                                self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                break
        else:
                if len(line) &gt;= 1:
                        self.cursor_column = len(line)-1
                else:
                        self.cursor_column = 0</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.set_view"><code class="name flex">
<span>def <span class="ident">set_view</span></span>(<span>self, view)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the view attached to the text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_view(self, view):
        &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
        self.view = view</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the first line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top(self):
        &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
        self.goto(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.treat_char"><code class="name flex">
<span>def <span class="ident">treat_char</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Treat character entered</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treat_char(self, keys):
        &#34;&#34;&#34; Treat character entered &#34;&#34;&#34;
        char = ord(keys[0][0])
        if self.read_only is False:
                if char &gt;= 0x20 and char != 0x7F:
                        self.add_char(keys)
                        return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.treat_key"><code class="name flex">
<span>def <span class="ident">treat_key</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Treat keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treat_key(self, keys):
        &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
        if self.treat_char(keys) is False:
                # Move in the edit field
                if   keys[0] in UP  :            self.arrow_up(keys)
                elif keys[0] in DOWN:            self.arrow_down(keys)
                elif keys[0] in LEFT:            self.arrow_left(keys)
                elif keys[0] in RIGHT:           self.arrow_right(keys)
                elif keys[0] in HOME:            self.home()
                elif keys[0] in END:             self.end()
                elif keys[0] in PAGE_UP:         self.page_up(keys)
                elif keys[0] in PAGE_DOWN:       self.page_down(keys)
                elif keys[0] in TOP:             self.top()
                elif keys[0] in BOTTOM:          self.bottom()
                elif keys[0] in NEXT_WORD:       self.next_word()
                elif keys[0] in PREVIOUS_WORD:   self.previous_word()
                # Selection the edit field
                elif keys[0] in SELECT_UP:       self.select_up(keys)
                elif keys[0] in SELECT_DOWN:     self.select_down(keys)
                elif keys[0] in SELECT_RIGHT:    self.select_right(keys)
                elif keys[0] in SELECT_LEFT:     self.select_left(keys)
                elif keys[0] in SELECT_HOME:     self.select_home()
                elif keys[0] in SELECT_END:      self.select_end()
                elif keys[0] in SELECT_TOP:      self.select_top()
                elif keys[0] in SELECT_BOTTOM:   self.select_bottom()
                elif keys[0] in SELECT_PAGE_UP:  self.select_page_up(keys)
                elif keys[0] in SELECT_PAGE_DOWN:self.select_page_down(keys)
                elif keys[0] in SELECT_ALL:      self.select_all()
                elif keys[0] in SELECT_NEXT_WORD:self.select_next_word()
                elif keys[0] in SELECT_PREV_WORD:self.select_previous_word()

                # If the edit is not in read only
                elif self.read_only is False:
                        # Modification in the edit field
                        if   keys[0] in COPY:            self.copy()
                        elif keys[0] in CUT:             self.cut()
                        elif keys[0] in PASTE:           self.paste()

                        elif keys[0] in INDENT:          self.indent(keys)
                        elif keys[0] in UNINDENT:        self.unindent(keys)
                        elif keys[0] in CHANGE_CASE:     self.change_case()
                        elif keys[0] in COMMENT:         self.comment()

                        elif keys[0] in BACKSPACE:       self.backspace()
                        elif keys[0] in DELETE:          self.delete()
                        elif keys[0] in NEW_LINE:        self.new_line()
                        elif keys[0] in DELETE_LINE:     self.delete_line()
                # else: self.add_char(keys)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.unindent"><code class="name flex">
<span>def <span class="ident">unindent</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the unindentation key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unindent(self, keys):
        &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
        # If nothing selected
        if self.selection_start is None:
                self.backspace()
        else:
                self.modified = True

                # Unindent selection
                selection_start, selection_end = self.get_selection()
                sel_column_start, sel_line_start, dummy = selection_start
                sel_column_end,   sel_line_end,   dummy = selection_end

                # If the selection is only alone line
                if sel_line_start == sel_line_end:
                        self.hide_selection()
                else:
                        # If the last line selected is at beginning of line
                        if sel_column_end == 0:
                                # This line must not be indented
                                sel_line_end -= 1

                        # Remove indentation
                        for line in range(sel_line_start, sel_line_end+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selection_start = [0,sel_line_start, 0]

                        # If the last line selected is not at beginning of line
                        if sel_column_end &gt; 0:
                                # Get the length of last selected line
                                len_line_end =  len(self.lines[sel_line_end])

                                # If the end of selection is not on the last line
                                if sel_line_end &lt; len(self.lines)-1:
                                        len_line_end -= 1

                                # Move the end of selection at the end of line selected
                                self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                        else:
                                # Move the end of selection at the start of the last line selected
                                self.selection_end  = [0, sel_line_end+1, 0]
                self.view.set_refresh_selection()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.shell.editor.View"><code class="flex name class">
<span>class <span class="ident">View</span></span>
<span>(</span><span>view_height, view_top)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage the view of the edit field </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class View:
        &#34;&#34;&#34; Class which manage the view of the edit field &#34;&#34;&#34;
        def __init__(self, view_height, view_top):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.line     = 0
                self.column   = 0
                if view_height is None:
                        self.height   = 20
                else:
                        self.height          = view_height
                self.width               = 80
                self.top                 = view_top
                self.is_refresh_all        = True
                self.is_refresh_line       = False
                self.is_refresh_line_before = False
                self.is_refresh_line_after  = False
                self.refresh_part         = None
                self.text                = None
                self.tab_cursor_column     = 0
                self.sel_line_start        = None
                self.sel_line_end          = None
                self.screen_height = 1
                self.screen_width = 1

        def write(self, data):
                &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
                sys.stdout.write(data)

        def flush(self):
                &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
                try:
                        sys.stdout.flush()
                except:
                        pass

        def set_text(self, text):
                &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
                self.text = text

        def get_screen_position(self):
                &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
                return (self.text.get_cursor_line() - self.line + self.top, self.tab_cursor_column - self.column)

        def reset(self):
                &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
                self.write(&#34;\x1B&#34;&#34;c&#34;)
                self.flush()

        def reset_scroll_region(self):
                &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
                if self.screen_height &gt; 0:
                        self.set_scrolling_region(0, self.screen_height-1)

        def set_scrolling_region(self, top_line, bottom_line):
                &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
                if top_line &lt; bottom_line:
                        self.write(&#34;\x1B[%d;%dr&#34;%(top_line+1,bottom_line+1))

        def scroll_up(self):
                &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
                self.set_scrolling_region(self.top, self.height+1)
                self.write(&#34;\x1B[1S&#34;)

        def scroll_down(self):
                &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
                self.set_scrolling_region(self.top, self.height+1)
                self.write(&#34;\x1B[1T&#34;)

        def scroll_part_up(self):
                &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
                line, column = self.get_screen_position()
                if line &lt; self.height:
                        self.set_scrolling_region(line, self.height+1)
                        self.write(&#34;\x1B[1S&#34;)

        def scroll_part_down(self):
                &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
                line, column = self.get_screen_position()
                if line &lt; self.height:
                        self.set_scrolling_region(line+1, self.height+1)
                        self.write(&#34;\x1B[1T&#34;)
                else:
                        self.is_refresh_line_after = True

        def move(self):
                &#34;&#34;&#34; Move the view &#34;&#34;&#34;
                self.tab_cursor_column = self.text.get_tab_cursor(self.text.get_cursor_line())
                # Move view port
                if self.tab_cursor_column &lt; self.column:
                        self.is_refresh_all = True
                        if self.tab_cursor_column &gt; HORIZONTAL_MOVE:
                                self.column = self.tab_cursor_column-HORIZONTAL_MOVE
                        else:
                                self.column = 0
                elif self.tab_cursor_column &gt;= self.column + self.width:
                        self.column = self.tab_cursor_column-self.width+HORIZONTAL_MOVE
                        self.is_refresh_all = True
                if self.text.get_cursor_line() &lt; self.line:
                        delta = self.line - self.text.get_cursor_line()
                        self.line = self.text.get_cursor_line()
                        if self.line &lt; 0:
                                self.line = 0
                        if delta &lt;= 1:
                                self.scroll_down()
                                self.is_refresh_line = True
                        else:
                                self.is_refresh_all = True
                elif self.text.get_cursor_line() &gt; self.line + self.height:
                        delta =  self.text.get_cursor_line() - self.line - self.height
                        self.line = self.text.get_cursor_line()-self.height
                        if delta &lt;= 1:
                                self.scroll_up()
                                self.is_refresh_line = True
                        else:
                                self.is_refresh_all = True

        def set_refresh_line(self):
                &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True

        def set_refresh_after(self):
                &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True
                self.is_refresh_line_after = True

        def set_refresh_before(self):
                &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True
                self.is_refresh_line_before = True

        def set_refresh_all(self):
                &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
                self.is_refresh_all = True

        def show_line(self, current_line, screen_line, selection_start, selection_end, quick=False):
                &#34;&#34;&#34; Show one line &#34;&#34;&#34;
                if quick:
                        line_to_display = &#34;&#34;
                else:
                        line_to_display = &#34;\x1B[%d;1f\x1B[K&#34;%(screen_line+1)
                count_line = self.text.get_count_lines()
                if current_line &lt; count_line and current_line &gt;= 0:
                        line = self.text.get_tab_line(current_line)
                        partLine = line[self.column:self.column+self.width]
                        # If the line selected
                        if selection_start is not None:
                                # If the line not empty
                                if len(partLine) &gt;= 1:
                                        # If the line have carriage return at the end
                                        if partLine[-1] == &#34;\n&#34;:
                                                # Remove the carriage return
                                                partLine = partLine[:-1]
                                if len(partLine) &gt; 0:
                                        dummy, sel_line_start, sel_column_start = selection_start
                                        dummy, sel_line_end,   sel_column_end   = selection_end
                                        # If the current line is the end of selection
                                        if current_line == sel_line_end:
                                                # If the end of selection is outside the visible part
                                                if sel_column_end - self.column &lt; 0:
                                                        sel_column_end = 0
                                                else:
                                                        sel_column_end -= self.column

                                                # If the start of selection is on the previous lines
                                                if sel_line_start &lt; sel_line_end:
                                                        # Select the start of line
                                                        partLine = &#34;\x1B[7m&#34; + partLine[:sel_column_end] + &#34;\x1B[m&#34; + partLine[sel_column_end:]
                                                else:
                                                        # Unselect the end of line
                                                        partLine = partLine[:sel_column_end] + &#34;\x1B[m&#34; + partLine[sel_column_end:]
                                        # If the current line is the start of selection
                                        if current_line == sel_line_start:
                                                # If the start of selection is outside the visible part
                                                if sel_column_start - self.column &lt; 0:
                                                        sel_column_start = 0
                                                else:
                                                        sel_column_start -= self.column

                                                # If the end of selection is on the next lines
                                                if sel_line_start &lt; sel_line_end:
                                                        # Select the end of line
                                                        partLine = partLine[:sel_column_start] + &#34;\x1B[7m&#34; + partLine[sel_column_start:] + &#34;\x1B[m&#34;
                                                else:
                                                        # Select the start of line
                                                        partLine = partLine[:sel_column_start] + &#34;\x1B[7m&#34; + partLine[sel_column_start:]
                                        # If the line is completly selected
                                        if current_line &gt; sel_line_start and current_line &lt; sel_line_end:
                                                # Select all the line
                                                partLine = &#34;\x1B[7m&#34; + partLine + &#34;\x1B[m&#34;
                                else:
                                        partLine = &#34;&#34;
                                self.write(line_to_display + partLine)
                        else:
                                self.write(line_to_display + partLine.rstrip())

        def refresh_line(self, selection_start, selection_end):
                &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
                screen_line,     screen_column = self.get_screen_position()
                refreshed = False

                # If the line must be refreshed before the cursor line
                if self.is_refresh_line_before:
                        self.is_refresh_line_before = False
                        self.show_line(self.text.get_cursor_line()-1, screen_line-1, selection_start, selection_end)
                        refreshed = True
                # If the line must be refreshed after the cursor line
                if self.is_refresh_line_after:
                        self.is_refresh_line_after = False
                        self.show_line(self.text.get_cursor_line()+1, screen_line+1, selection_start, selection_end)
                        offset = self.height - screen_line
                        self.show_line(self.text.get_cursor_line()+offset+1, screen_line+offset+1, selection_start, selection_end)
                        refreshed = True
                # If only the cursor line must be refresh
                if self.is_refresh_line:
                        self.is_refresh_line = False
                        self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)
                        refreshed = True

                # If no refresh detected and a selection started
                if selection_start is not None and refreshed is False:
                        # Refresh the selection
                        self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)

        def refresh(self):
                &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if self.refresh_part is not None:
                        self.refresh_content(selection_start, selection_end, self.refresh_part)
                        self.refresh_part = None
                # Refresh all required
                if self.is_refresh_all:
                        self.refresh_content(selection_start, selection_end, True)
                        self.is_refresh_all  = False
                        self.is_refresh_line = False
                else:
                        # If no selection activated
                        if selection_start is None:
                                # Refresh the current line
                                self.refresh_line(selection_start, selection_end)
                        else:
                                # Refresh the selection
                                self.refresh_content(selection_start, selection_end, False)
                self.move_cursor()
                self.flush()

        def refresh_content(self, selection_start, selection_end, all_):
                &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
                # If selection present
                if selection_start is not None:
                        # Get the selection
                        dummy, sel_line_start, sel_column_start = selection_start
                        dummy, sel_line_end,   sel_column_end   = selection_end
                        lineStart = sel_line_start
                        lineEnd   = sel_line_end
                        # The aim of this part is to limit the refresh area
                        # If the precedent display show a selection
                        if self.sel_line_end is not None and self.sel_line_start is not None:
                                # If the start and end of selection is on the sames lines
                                if self.sel_line_end == sel_line_end and self.sel_line_start == sel_line_start:
                                        lineStart = lineEnd = self.text.get_cursor_line()
                                else:
                                        # If the end of selection is after the precedent display
                                        if self.sel_line_end &gt; sel_line_end:
                                                lineEnd = self.sel_line_end
                                        # If the end of selection is on the same line than the precedent display
                                        elif self.sel_line_end == sel_line_end:
                                                # If the start of selection is before the precedent display
                                                if self.sel_line_start &lt; sel_line_start:
                                                        lineEnd = sel_line_start
                                                else:
                                                        lineEnd = self.sel_line_start
                                        # If the start of selection is before the precedent display
                                        if self.sel_line_start &lt; sel_line_start:
                                                lineStart = self.sel_line_start
                                        # If the start of selection is on the same line than the precedent display
                                        elif self.sel_line_start == sel_line_start:
                                                # If the end of selection is after the precedent display
                                                if self.sel_line_end &gt; sel_line_end:
                                                        lineStart = sel_line_end
                                                else:
                                                        lineStart = self.sel_line_end
                else:
                        lineStart = 0
                        lineEnd = self.line + self.height
                current_line = self.line
                screen_line = self.top
                if type(all_) == type([]):
                        lineStart, lineEnd = all_
                        all_ = False
                count_line = self.text.get_count_lines()
                maxLine = self.line + self.height
                if all_:
                        # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                        self.move_cursor(screen_line, 0)
                        self.write(&#34;\x1B[J&#34;)
                        # Refresh all lines visible
                        while current_line &lt; count_line and current_line &lt;= maxLine:
                                self.show_line(current_line, screen_line, selection_start, selection_end, True)
                                screen_line  += 1
                                current_line += 1
                                if (current_line &lt; count_line and current_line &lt;= maxLine):
                                        self.write(&#34;\n\r&#34;)
                else:
                        # Refresh all lines visible
                        while current_line &lt; count_line and current_line &lt;= maxLine:
                                # If the line is in selection or all must be refreshed
                                if lineStart &lt;= current_line &lt;= lineEnd or all_:
                                        self.show_line(current_line, screen_line, selection_start, selection_end)
                                screen_line  += 1
                                current_line += 1

                # If selection present
                if selection_start is not None:
                        # Save current selection
                        dummy, self.sel_line_start, dummy = selection_start
                        dummy, self.sel_line_end,   dummy   = selection_end

        def hide_selection(self):
                &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if selection_start is not None:
                        self.set_refresh_selection()
                        self.sel_line_start = None
                        self.sel_line_end   = None

        def set_refresh_selection(self):
                &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if selection_start is not None:
                        # self.is_refresh_all = True
                        lineStart = selection_start[1]
                        if self.sel_line_start &lt; lineStart:
                                lineStart = self.sel_line_start
                        lineEnd = selection_end[1]
                        if self.sel_line_end &gt; lineEnd:
                                lineEnd = self.sel_line_end
                        self.refresh_part = [lineStart, lineEnd]

        def move_cursor(self, screen_line=None, screen_column=None):
                &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
                self.write(self.get_move_cursor(screen_line, screen_column))

        def get_move_cursor(self, screen_line=None, screen_column=None):
                &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
                if screen_line is None and screen_column is None:
                        screen_line, screen_column = self.get_screen_position()
                return &#34;\x1B[%d;%df&#34;%(screen_line+1,screen_column+1)

        def get_screen_size(self):
                &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
                height, width = terminal.get_screen_size()
                self.screen_height = height
                self.screen_width = width
                self.height = height-self.top-1
                self.width  = width
                self.move_cursor()

        def cls(self):
                &#34;&#34;&#34; clear the screen &#34;&#34;&#34;
                self.write(&#34;\x1B[2J&#34;)
                self.move_cursor(0,0)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.View.cls"><code class="name flex">
<span>def <span class="ident">cls</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cls(self):
        &#34;&#34;&#34; clear the screen &#34;&#34;&#34;
        self.write(&#34;\x1B[2J&#34;)
        self.move_cursor(0,0)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flush text to stdout</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self):
        &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
        try:
                sys.stdout.flush()
        except:
                pass</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.get_move_cursor"><code class="name flex">
<span>def <span class="ident">get_move_cursor</span></span>(<span>self, screen_line=None, screen_column=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor in the view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_move_cursor(self, screen_line=None, screen_column=None):
        &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
        if screen_line is None and screen_column is None:
                screen_line, screen_column = self.get_screen_position()
        return &#34;\x1B[%d;%df&#34;%(screen_line+1,screen_column+1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.get_screen_position"><code class="name flex">
<span>def <span class="ident">get_screen_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the screen position of cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screen_position(self):
        &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
        return (self.text.get_cursor_line() - self.line + self.top, self.tab_cursor_column - self.column)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.get_screen_size"><code class="name flex">
<span>def <span class="ident">get_screen_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the screen size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screen_size(self):
        &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
        height, width = terminal.get_screen_size()
        self.screen_height = height
        self.screen_width = width
        self.height = height-self.top-1
        self.width  = width
        self.move_cursor()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.hide_selection"><code class="name flex">
<span>def <span class="ident">hide_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_selection(self):
        &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
        selection_start, selection_end = self.text.get_selection()
        if selection_start is not None:
                self.set_refresh_selection()
                self.sel_line_start = None
                self.sel_line_end   = None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self):
        &#34;&#34;&#34; Move the view &#34;&#34;&#34;
        self.tab_cursor_column = self.text.get_tab_cursor(self.text.get_cursor_line())
        # Move view port
        if self.tab_cursor_column &lt; self.column:
                self.is_refresh_all = True
                if self.tab_cursor_column &gt; HORIZONTAL_MOVE:
                        self.column = self.tab_cursor_column-HORIZONTAL_MOVE
                else:
                        self.column = 0
        elif self.tab_cursor_column &gt;= self.column + self.width:
                self.column = self.tab_cursor_column-self.width+HORIZONTAL_MOVE
                self.is_refresh_all = True
        if self.text.get_cursor_line() &lt; self.line:
                delta = self.line - self.text.get_cursor_line()
                self.line = self.text.get_cursor_line()
                if self.line &lt; 0:
                        self.line = 0
                if delta &lt;= 1:
                        self.scroll_down()
                        self.is_refresh_line = True
                else:
                        self.is_refresh_all = True
        elif self.text.get_cursor_line() &gt; self.line + self.height:
                delta =  self.text.get_cursor_line() - self.line - self.height
                self.line = self.text.get_cursor_line()-self.height
                if delta &lt;= 1:
                        self.scroll_up()
                        self.is_refresh_line = True
                else:
                        self.is_refresh_all = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.move_cursor"><code class="name flex">
<span>def <span class="ident">move_cursor</span></span>(<span>self, screen_line=None, screen_column=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor in the view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_cursor(self, screen_line=None, screen_column=None):
        &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
        self.write(self.get_move_cursor(screen_line, screen_column))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
        &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
        selection_start, selection_end = self.text.get_selection()
        if self.refresh_part is not None:
                self.refresh_content(selection_start, selection_end, self.refresh_part)
                self.refresh_part = None
        # Refresh all required
        if self.is_refresh_all:
                self.refresh_content(selection_start, selection_end, True)
                self.is_refresh_all  = False
                self.is_refresh_line = False
        else:
                # If no selection activated
                if selection_start is None:
                        # Refresh the current line
                        self.refresh_line(selection_start, selection_end)
                else:
                        # Refresh the selection
                        self.refresh_content(selection_start, selection_end, False)
        self.move_cursor()
        self.flush()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refresh_content"><code class="name flex">
<span>def <span class="ident">refresh_content</span></span>(<span>self, selection_start, selection_end, all_)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh content</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_content(self, selection_start, selection_end, all_):
        &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
        # If selection present
        if selection_start is not None:
                # Get the selection
                dummy, sel_line_start, sel_column_start = selection_start
                dummy, sel_line_end,   sel_column_end   = selection_end
                lineStart = sel_line_start
                lineEnd   = sel_line_end
                # The aim of this part is to limit the refresh area
                # If the precedent display show a selection
                if self.sel_line_end is not None and self.sel_line_start is not None:
                        # If the start and end of selection is on the sames lines
                        if self.sel_line_end == sel_line_end and self.sel_line_start == sel_line_start:
                                lineStart = lineEnd = self.text.get_cursor_line()
                        else:
                                # If the end of selection is after the precedent display
                                if self.sel_line_end &gt; sel_line_end:
                                        lineEnd = self.sel_line_end
                                # If the end of selection is on the same line than the precedent display
                                elif self.sel_line_end == sel_line_end:
                                        # If the start of selection is before the precedent display
                                        if self.sel_line_start &lt; sel_line_start:
                                                lineEnd = sel_line_start
                                        else:
                                                lineEnd = self.sel_line_start
                                # If the start of selection is before the precedent display
                                if self.sel_line_start &lt; sel_line_start:
                                        lineStart = self.sel_line_start
                                # If the start of selection is on the same line than the precedent display
                                elif self.sel_line_start == sel_line_start:
                                        # If the end of selection is after the precedent display
                                        if self.sel_line_end &gt; sel_line_end:
                                                lineStart = sel_line_end
                                        else:
                                                lineStart = self.sel_line_end
        else:
                lineStart = 0
                lineEnd = self.line + self.height
        current_line = self.line
        screen_line = self.top
        if type(all_) == type([]):
                lineStart, lineEnd = all_
                all_ = False
        count_line = self.text.get_count_lines()
        maxLine = self.line + self.height
        if all_:
                # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                self.move_cursor(screen_line, 0)
                self.write(&#34;\x1B[J&#34;)
                # Refresh all lines visible
                while current_line &lt; count_line and current_line &lt;= maxLine:
                        self.show_line(current_line, screen_line, selection_start, selection_end, True)
                        screen_line  += 1
                        current_line += 1
                        if (current_line &lt; count_line and current_line &lt;= maxLine):
                                self.write(&#34;\n\r&#34;)
        else:
                # Refresh all lines visible
                while current_line &lt; count_line and current_line &lt;= maxLine:
                        # If the line is in selection or all must be refreshed
                        if lineStart &lt;= current_line &lt;= lineEnd or all_:
                                self.show_line(current_line, screen_line, selection_start, selection_end)
                        screen_line  += 1
                        current_line += 1

        # If selection present
        if selection_start is not None:
                # Save current selection
                dummy, self.sel_line_start, dummy = selection_start
                dummy, self.sel_line_end,   dummy   = selection_end</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refresh_line"><code class="name flex">
<span>def <span class="ident">refresh_line</span></span>(<span>self, selection_start, selection_end)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_line(self, selection_start, selection_end):
        &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
        screen_line,     screen_column = self.get_screen_position()
        refreshed = False

        # If the line must be refreshed before the cursor line
        if self.is_refresh_line_before:
                self.is_refresh_line_before = False
                self.show_line(self.text.get_cursor_line()-1, screen_line-1, selection_start, selection_end)
                refreshed = True
        # If the line must be refreshed after the cursor line
        if self.is_refresh_line_after:
                self.is_refresh_line_after = False
                self.show_line(self.text.get_cursor_line()+1, screen_line+1, selection_start, selection_end)
                offset = self.height - screen_line
                self.show_line(self.text.get_cursor_line()+offset+1, screen_line+offset+1, selection_start, selection_end)
                refreshed = True
        # If only the cursor line must be refresh
        if self.is_refresh_line:
                self.is_refresh_line = False
                self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)
                refreshed = True

        # If no refresh detected and a selection started
        if selection_start is not None and refreshed is False:
                # Refresh the selection
                self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset VT100</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
        &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
        self.write(&#34;\x1B&#34;&#34;c&#34;)
        self.flush()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.reset_scroll_region"><code class="name flex">
<span>def <span class="ident">reset_scroll_region</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset VT100 scroll region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_scroll_region(self):
        &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
        if self.screen_height &gt; 0:
                self.set_scrolling_region(0, self.screen_height-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scroll_down"><code class="name flex">
<span>def <span class="ident">scroll_down</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll to down</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_down(self):
        &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
        self.set_scrolling_region(self.top, self.height+1)
        self.write(&#34;\x1B[1T&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scroll_part_down"><code class="name flex">
<span>def <span class="ident">scroll_part_down</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the lower part</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_part_down(self):
        &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
        line, column = self.get_screen_position()
        if line &lt; self.height:
                self.set_scrolling_region(line+1, self.height+1)
                self.write(&#34;\x1B[1T&#34;)
        else:
                self.is_refresh_line_after = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scroll_part_up"><code class="name flex">
<span>def <span class="ident">scroll_part_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the upper part</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_part_up(self):
        &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
        line, column = self.get_screen_position()
        if line &lt; self.height:
                self.set_scrolling_region(line, self.height+1)
                self.write(&#34;\x1B[1S&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scroll_up"><code class="name flex">
<span>def <span class="ident">scroll_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll to up</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_up(self):
        &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
        self.set_scrolling_region(self.top, self.height+1)
        self.write(&#34;\x1B[1S&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_after"><code class="name flex">
<span>def <span class="ident">set_refresh_after</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines after the current line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_after(self):
        &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
        self.is_refresh_line = True
        self.is_refresh_line_after = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_all"><code class="name flex">
<span>def <span class="ident">set_refresh_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_all(self):
        &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
        self.is_refresh_all = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_before"><code class="name flex">
<span>def <span class="ident">set_refresh_before</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines before the current line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_before(self):
        &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
        self.is_refresh_line = True
        self.is_refresh_line_before = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_line"><code class="name flex">
<span>def <span class="ident">set_refresh_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_line(self):
        &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
        self.is_refresh_line = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_selection"><code class="name flex">
<span>def <span class="ident">set_refresh_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the selection must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_selection(self):
        &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
        selection_start, selection_end = self.text.get_selection()
        if selection_start is not None:
                # self.is_refresh_all = True
                lineStart = selection_start[1]
                if self.sel_line_start &lt; lineStart:
                        lineStart = self.sel_line_start
                lineEnd = selection_end[1]
                if self.sel_line_end &gt; lineEnd:
                        lineEnd = self.sel_line_end
                self.refresh_part = [lineStart, lineEnd]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_scrolling_region"><code class="name flex">
<span>def <span class="ident">set_scrolling_region</span></span>(<span>self, top_line, bottom_line)</span>
</code></dt>
<dd>
<div class="desc"><p>Define VT100 scroll region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_scrolling_region(self, top_line, bottom_line):
        &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
        if top_line &lt; bottom_line:
                self.write(&#34;\x1B[%d;%dr&#34;%(top_line+1,bottom_line+1))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_text"><code class="name flex">
<span>def <span class="ident">set_text</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the text object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text(self, text):
        &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
        self.text = text</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.show_line"><code class="name flex">
<span>def <span class="ident">show_line</span></span>(<span>self, current_line, screen_line, selection_start, selection_end, quick=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Show one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_line(self, current_line, screen_line, selection_start, selection_end, quick=False):
        &#34;&#34;&#34; Show one line &#34;&#34;&#34;
        if quick:
                line_to_display = &#34;&#34;
        else:
                line_to_display = &#34;\x1B[%d;1f\x1B[K&#34;%(screen_line+1)
        count_line = self.text.get_count_lines()
        if current_line &lt; count_line and current_line &gt;= 0:
                line = self.text.get_tab_line(current_line)
                partLine = line[self.column:self.column+self.width]
                # If the line selected
                if selection_start is not None:
                        # If the line not empty
                        if len(partLine) &gt;= 1:
                                # If the line have carriage return at the end
                                if partLine[-1] == &#34;\n&#34;:
                                        # Remove the carriage return
                                        partLine = partLine[:-1]
                        if len(partLine) &gt; 0:
                                dummy, sel_line_start, sel_column_start = selection_start
                                dummy, sel_line_end,   sel_column_end   = selection_end
                                # If the current line is the end of selection
                                if current_line == sel_line_end:
                                        # If the end of selection is outside the visible part
                                        if sel_column_end - self.column &lt; 0:
                                                sel_column_end = 0
                                        else:
                                                sel_column_end -= self.column

                                        # If the start of selection is on the previous lines
                                        if sel_line_start &lt; sel_line_end:
                                                # Select the start of line
                                                partLine = &#34;\x1B[7m&#34; + partLine[:sel_column_end] + &#34;\x1B[m&#34; + partLine[sel_column_end:]
                                        else:
                                                # Unselect the end of line
                                                partLine = partLine[:sel_column_end] + &#34;\x1B[m&#34; + partLine[sel_column_end:]
                                # If the current line is the start of selection
                                if current_line == sel_line_start:
                                        # If the start of selection is outside the visible part
                                        if sel_column_start - self.column &lt; 0:
                                                sel_column_start = 0
                                        else:
                                                sel_column_start -= self.column

                                        # If the end of selection is on the next lines
                                        if sel_line_start &lt; sel_line_end:
                                                # Select the end of line
                                                partLine = partLine[:sel_column_start] + &#34;\x1B[7m&#34; + partLine[sel_column_start:] + &#34;\x1B[m&#34;
                                        else:
                                                # Select the start of line
                                                partLine = partLine[:sel_column_start] + &#34;\x1B[7m&#34; + partLine[sel_column_start:]
                                # If the line is completly selected
                                if current_line &gt; sel_line_start and current_line &lt; sel_line_end:
                                        # Select all the line
                                        partLine = &#34;\x1B[7m&#34; + partLine + &#34;\x1B[m&#34;
                        else:
                                partLine = &#34;&#34;
                        self.write(line_to_display + partLine)
                else:
                        self.write(line_to_display + partLine.rstrip())</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to stdout</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data):
        &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
        sys.stdout.write(data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.shell" href="index.html">lib.shell</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.shell.editor.Edit" href="#lib.shell.editor.Edit">Edit</a></code></h4>
</li>
<li>
<h4><code><a title="lib.shell.editor.Editor" href="#lib.shell.editor.Editor">Editor</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.shell.editor.Editor.execute" href="#lib.shell.editor.Editor.execute">execute</a></code></li>
<li><code><a title="lib.shell.editor.Editor.exit" href="#lib.shell.editor.Editor.exit">exit</a></code></li>
<li><code><a title="lib.shell.editor.Editor.find" href="#lib.shell.editor.Editor.find">find</a></code></li>
<li><code><a title="lib.shell.editor.Editor.find_next" href="#lib.shell.editor.Editor.find_next">find_next</a></code></li>
<li><code><a title="lib.shell.editor.Editor.find_previous" href="#lib.shell.editor.Editor.find_previous">find_previous</a></code></li>
<li><code><a title="lib.shell.editor.Editor.get_key" href="#lib.shell.editor.Editor.get_key">get_key</a></code></li>
<li><code><a title="lib.shell.editor.Editor.goto" href="#lib.shell.editor.Editor.goto">goto</a></code></li>
<li><code><a title="lib.shell.editor.Editor.group_key" href="#lib.shell.editor.Editor.group_key">group_key</a></code></li>
<li><code><a title="lib.shell.editor.Editor.input" href="#lib.shell.editor.Editor.input">input</a></code></li>
<li><code><a title="lib.shell.editor.Editor.refresh" href="#lib.shell.editor.Editor.refresh">refresh</a></code></li>
<li><code><a title="lib.shell.editor.Editor.refresh_header" href="#lib.shell.editor.Editor.refresh_header">refresh_header</a></code></li>
<li><code><a title="lib.shell.editor.Editor.replace" href="#lib.shell.editor.Editor.replace">replace</a></code></li>
<li><code><a title="lib.shell.editor.Editor.replace_current" href="#lib.shell.editor.Editor.replace_current">replace_current</a></code></li>
<li><code><a title="lib.shell.editor.Editor.run" href="#lib.shell.editor.Editor.run">run</a></code></li>
<li><code><a title="lib.shell.editor.Editor.save" href="#lib.shell.editor.Editor.save">save</a></code></li>
<li><code><a title="lib.shell.editor.Editor.toggle_mode" href="#lib.shell.editor.Editor.toggle_mode">toggle_mode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.shell.editor.Text" href="#lib.shell.editor.Text">Text</a></code></h4>
<ul class="">
<li><code><a title="lib.shell.editor.Text.add_char" href="#lib.shell.editor.Text.add_char">add_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrow_down" href="#lib.shell.editor.Text.arrow_down">arrow_down</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrow_left" href="#lib.shell.editor.Text.arrow_left">arrow_left</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrow_right" href="#lib.shell.editor.Text.arrow_right">arrow_right</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrow_up" href="#lib.shell.editor.Text.arrow_up">arrow_up</a></code></li>
<li><code><a title="lib.shell.editor.Text.backspace" href="#lib.shell.editor.Text.backspace">backspace</a></code></li>
<li><code><a title="lib.shell.editor.Text.bottom" href="#lib.shell.editor.Text.bottom">bottom</a></code></li>
<li><code><a title="lib.shell.editor.Text.change_case" href="#lib.shell.editor.Text.change_case">change_case</a></code></li>
<li><code><a title="lib.shell.editor.Text.change_column" href="#lib.shell.editor.Text.change_column">change_column</a></code></li>
<li><code><a title="lib.shell.editor.Text.change_line" href="#lib.shell.editor.Text.change_line">change_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.close_selection" href="#lib.shell.editor.Text.close_selection">close_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.comment" href="#lib.shell.editor.Text.comment">comment</a></code></li>
<li><code><a title="lib.shell.editor.Text.copy" href="#lib.shell.editor.Text.copy">copy</a></code></li>
<li><code><a title="lib.shell.editor.Text.copy_clipboard" href="#lib.shell.editor.Text.copy_clipboard">copy_clipboard</a></code></li>
<li><code><a title="lib.shell.editor.Text.cut" href="#lib.shell.editor.Text.cut">cut</a></code></li>
<li><code><a title="lib.shell.editor.Text.delete" href="#lib.shell.editor.Text.delete">delete</a></code></li>
<li><code><a title="lib.shell.editor.Text.delete_line" href="#lib.shell.editor.Text.delete_line">delete_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.end" href="#lib.shell.editor.Text.end">end</a></code></li>
<li><code><a title="lib.shell.editor.Text.find_next" href="#lib.shell.editor.Text.find_next">find_next</a></code></li>
<li><code><a title="lib.shell.editor.Text.find_previous" href="#lib.shell.editor.Text.find_previous">find_previous</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_count_lines" href="#lib.shell.editor.Text.get_count_lines">get_count_lines</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_cursor_char" href="#lib.shell.editor.Text.get_cursor_char">get_cursor_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_cursor_line" href="#lib.shell.editor.Text.get_cursor_line">get_cursor_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_selection" href="#lib.shell.editor.Text.get_selection">get_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_tab_cursor" href="#lib.shell.editor.Text.get_tab_cursor">get_tab_cursor</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_tab_cursor_column" href="#lib.shell.editor.Text.get_tab_cursor_column">get_tab_cursor_column</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_tab_line" href="#lib.shell.editor.Text.get_tab_line">get_tab_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.goto" href="#lib.shell.editor.Text.goto">goto</a></code></li>
<li><code><a title="lib.shell.editor.Text.hide_selection" href="#lib.shell.editor.Text.hide_selection">hide_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.home" href="#lib.shell.editor.Text.home">home</a></code></li>
<li><code><a title="lib.shell.editor.Text.indent" href="#lib.shell.editor.Text.indent">indent</a></code></li>
<li><code><a title="lib.shell.editor.Text.insert_char" href="#lib.shell.editor.Text.insert_char">insert_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.load" href="#lib.shell.editor.Text.load">load</a></code></li>
<li><code><a title="lib.shell.editor.Text.move_cursor" href="#lib.shell.editor.Text.move_cursor">move_cursor</a></code></li>
<li><code><a title="lib.shell.editor.Text.move_word" href="#lib.shell.editor.Text.move_word">move_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.new_line" href="#lib.shell.editor.Text.new_line">new_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.next_word" href="#lib.shell.editor.Text.next_word">next_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.open_selection" href="#lib.shell.editor.Text.open_selection">open_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.page_down" href="#lib.shell.editor.Text.page_down">page_down</a></code></li>
<li><code><a title="lib.shell.editor.Text.page_up" href="#lib.shell.editor.Text.page_up">page_up</a></code></li>
<li><code><a title="lib.shell.editor.Text.paste" href="#lib.shell.editor.Text.paste">paste</a></code></li>
<li><code><a title="lib.shell.editor.Text.paste_clipboard" href="#lib.shell.editor.Text.paste_clipboard">paste_clipboard</a></code></li>
<li><code><a title="lib.shell.editor.Text.previous_word" href="#lib.shell.editor.Text.previous_word">previous_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.remove_selection" href="#lib.shell.editor.Text.remove_selection">remove_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.replace" href="#lib.shell.editor.Text.replace">replace</a></code></li>
<li><code><a title="lib.shell.editor.Text.replace_char" href="#lib.shell.editor.Text.replace_char">replace_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.save" href="#lib.shell.editor.Text.save">save</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_all" href="#lib.shell.editor.Text.select_all">select_all</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_bottom" href="#lib.shell.editor.Text.select_bottom">select_bottom</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_down" href="#lib.shell.editor.Text.select_down">select_down</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_end" href="#lib.shell.editor.Text.select_end">select_end</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_home" href="#lib.shell.editor.Text.select_home">select_home</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_left" href="#lib.shell.editor.Text.select_left">select_left</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_next_word" href="#lib.shell.editor.Text.select_next_word">select_next_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_page_down" href="#lib.shell.editor.Text.select_page_down">select_page_down</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_page_up" href="#lib.shell.editor.Text.select_page_up">select_page_up</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_previous_word" href="#lib.shell.editor.Text.select_previous_word">select_previous_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_right" href="#lib.shell.editor.Text.select_right">select_right</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_top" href="#lib.shell.editor.Text.select_top">select_top</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_up" href="#lib.shell.editor.Text.select_up">select_up</a></code></li>
<li><code><a title="lib.shell.editor.Text.set_cursor_column" href="#lib.shell.editor.Text.set_cursor_column">set_cursor_column</a></code></li>
<li><code><a title="lib.shell.editor.Text.set_view" href="#lib.shell.editor.Text.set_view">set_view</a></code></li>
<li><code><a title="lib.shell.editor.Text.top" href="#lib.shell.editor.Text.top">top</a></code></li>
<li><code><a title="lib.shell.editor.Text.treat_char" href="#lib.shell.editor.Text.treat_char">treat_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.treat_key" href="#lib.shell.editor.Text.treat_key">treat_key</a></code></li>
<li><code><a title="lib.shell.editor.Text.unindent" href="#lib.shell.editor.Text.unindent">unindent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.shell.editor.View" href="#lib.shell.editor.View">View</a></code></h4>
<ul class="">
<li><code><a title="lib.shell.editor.View.cls" href="#lib.shell.editor.View.cls">cls</a></code></li>
<li><code><a title="lib.shell.editor.View.flush" href="#lib.shell.editor.View.flush">flush</a></code></li>
<li><code><a title="lib.shell.editor.View.get_move_cursor" href="#lib.shell.editor.View.get_move_cursor">get_move_cursor</a></code></li>
<li><code><a title="lib.shell.editor.View.get_screen_position" href="#lib.shell.editor.View.get_screen_position">get_screen_position</a></code></li>
<li><code><a title="lib.shell.editor.View.get_screen_size" href="#lib.shell.editor.View.get_screen_size">get_screen_size</a></code></li>
<li><code><a title="lib.shell.editor.View.hide_selection" href="#lib.shell.editor.View.hide_selection">hide_selection</a></code></li>
<li><code><a title="lib.shell.editor.View.move" href="#lib.shell.editor.View.move">move</a></code></li>
<li><code><a title="lib.shell.editor.View.move_cursor" href="#lib.shell.editor.View.move_cursor">move_cursor</a></code></li>
<li><code><a title="lib.shell.editor.View.refresh" href="#lib.shell.editor.View.refresh">refresh</a></code></li>
<li><code><a title="lib.shell.editor.View.refresh_content" href="#lib.shell.editor.View.refresh_content">refresh_content</a></code></li>
<li><code><a title="lib.shell.editor.View.refresh_line" href="#lib.shell.editor.View.refresh_line">refresh_line</a></code></li>
<li><code><a title="lib.shell.editor.View.reset" href="#lib.shell.editor.View.reset">reset</a></code></li>
<li><code><a title="lib.shell.editor.View.reset_scroll_region" href="#lib.shell.editor.View.reset_scroll_region">reset_scroll_region</a></code></li>
<li><code><a title="lib.shell.editor.View.scroll_down" href="#lib.shell.editor.View.scroll_down">scroll_down</a></code></li>
<li><code><a title="lib.shell.editor.View.scroll_part_down" href="#lib.shell.editor.View.scroll_part_down">scroll_part_down</a></code></li>
<li><code><a title="lib.shell.editor.View.scroll_part_up" href="#lib.shell.editor.View.scroll_part_up">scroll_part_up</a></code></li>
<li><code><a title="lib.shell.editor.View.scroll_up" href="#lib.shell.editor.View.scroll_up">scroll_up</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_after" href="#lib.shell.editor.View.set_refresh_after">set_refresh_after</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_all" href="#lib.shell.editor.View.set_refresh_all">set_refresh_all</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_before" href="#lib.shell.editor.View.set_refresh_before">set_refresh_before</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_line" href="#lib.shell.editor.View.set_refresh_line">set_refresh_line</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_selection" href="#lib.shell.editor.View.set_refresh_selection">set_refresh_selection</a></code></li>
<li><code><a title="lib.shell.editor.View.set_scrolling_region" href="#lib.shell.editor.View.set_scrolling_region">set_scrolling_region</a></code></li>
<li><code><a title="lib.shell.editor.View.set_text" href="#lib.shell.editor.View.set_text">set_text</a></code></li>
<li><code><a title="lib.shell.editor.View.show_line" href="#lib.shell.editor.View.show_line">show_line</a></code></li>
<li><code><a title="lib.shell.editor.View.write" href="#lib.shell.editor.View.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>