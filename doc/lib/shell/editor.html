<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lib.shell.editor API documentation</title>
<meta name="description" content="Class defining a VT100 text editor.
This editor works directly in the board.
This allows you to make quick and easy changes directly on the board, â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.shell.editor</code></h1>
</header>
<section id="section-intro">
<p>Class defining a VT100 text editor.
This editor works directly in the board.
This allows you to make quick and easy changes directly on the board, without having to use synchronization tools.
This editor allows script execution, and displays errors and execution time.</p>
<p>It also works on linux and osx, and can also be used autonomously, download the editor.zip and execute editor.py.</p>
<p>All the keyboard shortcuts are at the start of the script.</p>
<p>On the boards with low memory, it may work, but on very small files, otherwise it may produce an error due to insufficient memory.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python3
# Distributed under Pycameresp License
# Copyright (c) 2023 Remi BERTHOLET
# pylint:disable=multiple-statements
# pylint:disable=too-many-lines
# pylint:disable=consider-using-f-string
# pylint:disable=unspecified-encoding

&#34;&#34;&#34; Class defining a VT100 text editor.
This editor works directly in the board.
This allows you to make quick and easy changes directly on the board, without having to use synchronization tools.
This editor allows script execution, and displays errors and execution time.

It also works on linux and osx, and can also be used autonomously, download the editor.zip and execute editor.py.

All the keyboard shortcuts are at the start of the script.

On the boards with low memory, it may work, but on very small files, otherwise it may produce an error due to insufficient memory.
&#34;&#34;&#34;
import sys
import tools.useful
import tools.logger
import tools.strings
import tools.terminal
import tools.filesystem
import tools.jsonconfig

HORIZONTAL_MOVE = 8    # Scrolling minimal deplacement

SELECTION_START = b&#34;\x1B[7m&#34;
SELECTION_END   = b&#34;\x1B[m&#34;

class EditorConfig(tools.jsonconfig.JsonConfig):
        &#34;&#34;&#34; Editor configuration for shortcuts and tab size&#34;&#34;&#34;
        def __init__(self):
                tools.jsonconfig.JsonConfig.__init__(self)
                self.tabsize              = 4    # Tabulation size

                # For the same action several shortcuts can be used
                # Move shortcuts
                self.key_up               = [&#34;\x1b[A&#34;]
                self.key_down             = [&#34;\x1b[B&#34;]
                self.key_right            = [&#34;\x1b[C&#34;]
                self.key_left             = [&#34;\x1b[D&#34;]
                self.key_home             = [&#34;\x1b[1;3D&#34;, &#34;\x1b[H&#34;, &#34;\x1b\x1b[D&#34;, &#34;\x1b[1~&#34;, &#34;\x1bb&#34;]
                self.key_end              = [&#34;\x1b[1;3C&#34;, &#34;\x1b[F&#34;, &#34;\x1b\x1b[C&#34;, &#34;\x1b[4~&#34;, &#34;\x1bf&#34;]
                self.key_page_up          = [&#34;\x1b[1;3A&#34;, &#34;\x1b[A&#34;, &#34;\x1b\x1b[A&#34;, &#34;\x1b[5~&#34;]
                self.key_page_down        = [&#34;\x1b[1;3B&#34;, &#34;\x1b[B&#34;, &#34;\x1b\x1b[B&#34;, &#34;\x1b[6~&#34;]
                self.key_top              = [&#34;\x1b[1;5H&#34;]
                self.key_bottom           = [&#34;\x1b[1;5F&#34;]
                self.key_next_word        = [&#34;\x1b[1;5C&#34;]
                self.key_previous_word    = [&#34;\x1b[1;5D&#34;]

                # selection shortcuts
                self.key_sel_up           = [&#34;\x1b[1;2A&#34;]
                self.key_sel_down         = [&#34;\x1b[1;2B&#34;]
                self.key_sel_right        = [&#34;\x1b[1;2C&#34;]
                self.key_sel_left         = [&#34;\x1b[1;2D&#34;]
                self.key_sel_page_up      = [&#34;\x1b[1;10A&#34;,&#34;\x1b[1;4A&#34;,&#34;\x1b[5;2~&#34;]
                self.key_sel_page_down    = [&#34;\x1b[1;10B&#34;,&#34;\x1b[1;4B&#34;,&#34;\x1b[6;2~&#34;]
                self.key_sel_home         = [&#34;\x1b[1;2H&#34;,&#34;\x1b[1;10D&#34;]
                self.key_sel_end          = [&#34;\x1b[1;2F&#34;,&#34;\x1b[1;10C&#34;]
                self.key_sel_top          = [&#34;\x1b[1;6H&#34;]
                self.key_sel_bottom       = [&#34;\x1b[1;6F&#34;]
                self.key_sel_next_word    = [&#34;\x1b[1;6C&#34;,&#34;\x1b[1;4C&#34;]
                self.key_sel_prev_word    = [&#34;\x1b[1;6D&#34;,&#34;\x1b[1;4D&#34;]

                self.key_sel_all          = [&#34;\x01&#34;]                              # Select All
                # ctrl-b unused
                self.key_copy             = [&#34;\x03&#34;,&#34;\x1bc&#34;]                      # Copy
                # ctrl-d unused
                self.key_execute          = [&#34;\x05&#34;, &#34;\x1b[15~&#34;]                  # Execute script
                self.key_find             = [&#34;\x06&#34;, &#34;\x1BOQ&#34;]                    # Find
                self.key_goto             = [&#34;\x07&#34;]                              # Goto line
                self.key_backspace        = [&#34;\x08&#34;,&#34;\x7F&#34;]                       # Backspace
                self.key_indent           = [&#34;\x09&#34;]                              # Indent
                # line feed reserved
                # ctrl-k unused
                self.key_del_line         = [&#34;\x0C&#34;]                              # Delete line
                self.key_new_line         = [&#34;\x0D&#34;, &#34;\0x0A&#34;]                     # New line pressed
                self.key_find_next        = [&#34;\x0E&#34;, &#34;\x1bOR&#34;]                    # Find next
                # ctrl-o unused
                self.key_find_previous    = [&#34;\x10&#34;, &#34;\x1b[1;2R&#34;]                 # Find previous
                self.key_comment          = [&#34;\x11&#34;]                              # Comment block
                self.key_replace          = [&#34;\x12&#34;]                              # Replace
                self.key_save             = [&#34;\x13&#34;, &#34;\x1bs&#34;]                     # Save
                self.key_toggle_mode      = [&#34;\x14&#34;]                              # Toggle replace/insert mode
                self.key_change_case      = [&#34;\x15&#34;]                              # Change case
                self.key_paste            = [&#34;\x16&#34;,&#34;\x1bv&#34;]                      # Paste
                # ctrl-w unused
                self.key_cut              = [&#34;\x18&#34;,&#34;\x1bx&#34;]                      # Cut
                # ctrl-y unused
                # ctrl-z unused

                self.key_exit             = [&#34;\x1b&#34;]                              # Exit

                self.key_delete           = [&#34;\x1b[3~&#34;]                           # Delete pressed
                self.key_unindent         = [&#34;\x1b[Z&#34;]                            # Unindent


def is_enough_memory():
        &#34;&#34;&#34; Indicate if it has enough memory &#34;&#34;&#34;
        import gc
        try:
                # pylint: disable=no-member
                memory  = gc.mem_free()
        except:
                memory  = 256*1024
        if memory &lt; 50*1024:
                return False
        return True

class View:
        &#34;&#34;&#34; Class which manage the view of the edit field &#34;&#34;&#34;
        def __init__(self, cfg, view_height, view_top, extension=None):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.line     = 0
                self.column   = 0
                self.cfg      = cfg
                if view_height is None:
                        self.height   = 20
                else:
                        self.height             = view_height

                self.colorize = self.colorize_none
                if is_enough_memory():
                        if extension is not None:
                                if extension.lower() == &#34;.py&#34;:
                                        # pylint: disable=import-error
                                        try:
                                                try:
                                                        from editor_py import Colorizer
                                                except:
                                                        from shell.editor_py import Colorizer
                                                self.colorizer = Colorizer()
                                                self.colorize = self.colorize_syntax
                                        except:
                                                pass

                self.width                  = 80
                self.top                    = view_top
                self.is_refresh_all         = True
                self.is_refresh_line        = False
                self.is_refresh_line_before = False
                self.is_refresh_line_after  = False
                self.refresh_part           = None
                self.text                   = None
                self.tab_cursor_column      = 0
                self.sel_line_start         = None
                self.sel_line_end           = None
                self.screen_height          = 1
                self.screen_width           = 1
                if tools.filesystem.ismicropython():
                        self.write = self.write_byte
                else:
                        self.write = self.write_string

        def write_byte(self, data):
                &#34;&#34;&#34; Write data to stdout in byte (for micropython only) &#34;&#34;&#34;
                sys.stdout.write(data)

        def write_string(self, data):
                &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
                sys.stdout.write(tools.strings.tostrings(data))

        def flush(self):
                &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
                try:
                        sys.stdout.flush()
                except:
                        pass

        def set_text(self, text):
                &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
                self.text = text

        def get_screen_position(self):
                &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
                return (self.text.get_cursor_line() - self.line + self.top, self.tab_cursor_column - self.column)

        def reset(self):
                &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
                self.write(b&#34;\x1B&#34;+b&#34;c&#34;)
                self.flush()

        def reset_scroll_region(self):
                &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
                if self.screen_height &gt; 0:
                        self.set_scrolling_region(0, self.screen_height-1)

        def set_scrolling_region(self, top_line, bottom_line):
                &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
                if top_line &lt; bottom_line:
                        self.write(b&#34;\x1B[%d;%dr&#34;%(top_line+1,bottom_line+1))

        def scroll_up(self):
                &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
                self.set_scrolling_region(self.top, self.height+1)
                self.write(b&#34;\x1B[1S&#34;)

        def scroll_down(self):
                &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
                self.set_scrolling_region(self.top, self.height+1)
                self.write(b&#34;\x1B[1T&#34;)

        def scroll_part_up(self):
                &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
                line, column = self.get_screen_position()
                if line &lt; self.height:
                        self.set_scrolling_region(line +1, self.height+1)
                        self.write(b&#34;\x1B[1S&#34;)
                elif line == self.height:
                        self.write(b&#34;\x1B[%d;1f\x1B[K&#34;%(self.height + 1 + self.top))

        def scroll_part_down(self):
                &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
                line, column = self.get_screen_position()
                if line &lt; self.height:
                        self.set_scrolling_region(line+1, self.height+1)
                        self.write(b&#34;\x1B[1T&#34;)
                else:
                        self.is_refresh_line_after = True

        def move(self):
                &#34;&#34;&#34; Move the view &#34;&#34;&#34;
                self.tab_cursor_column = self.text.get_tab_cursor(self.text.get_cursor_line())
                # Move view port
                if self.tab_cursor_column &lt; self.column:
                        self.is_refresh_all = True
                        if self.tab_cursor_column &gt; HORIZONTAL_MOVE:
                                self.column = self.tab_cursor_column-HORIZONTAL_MOVE
                        else:
                                self.column = 0
                elif self.tab_cursor_column &gt;= self.column + self.width:
                        self.column = self.tab_cursor_column-self.width+HORIZONTAL_MOVE
                        self.is_refresh_all = True
                if self.text.get_cursor_line() &lt; self.line:
                        delta = self.line - self.text.get_cursor_line()
                        self.line = self.text.get_cursor_line()
                        if self.line &lt; 0:
                                self.line = 0
                        if delta &lt;= 1:
                                self.scroll_down()
                                self.is_refresh_line = True
                        else:
                                self.is_refresh_all = True
                elif self.text.get_cursor_line() &gt; self.line + self.height:
                        delta =  self.text.get_cursor_line() - self.line - self.height
                        self.line = self.text.get_cursor_line()-self.height
                        if delta &lt;= 1:
                                self.scroll_up()
                                self.is_refresh_line = True
                        else:
                                self.is_refresh_all = True

        def set_refresh_line(self):
                &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True

        def set_refresh_after(self):
                &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True
                self.is_refresh_line_after = True

        def set_refresh_before(self):
                &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True
                self.is_refresh_line_before = True

        def set_refresh_all(self):
                &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
                self.is_refresh_all = True

        def set_refresh_bottom(self, cursor):
                &#34;&#34;&#34; Refresh from the cursor to the end of screen &#34;&#34;&#34;
                self.refresh_part = [cursor, cursor+self.height+self.height]

        def show_line(self, current_line, screen_line, selection_start, selection_end, quick=False):
                &#34;&#34;&#34; Show one line &#34;&#34;&#34;
                if not quick:
                        clear_line = b&#34;\x1B[%d;1f\x1B[K&#34;%(screen_line+1)
                else:
                        clear_line = b&#34;&#34;
                count_line = self.text.get_count_lines()
                if current_line &lt; count_line and current_line &gt;= 0:
                        # If the line selected
                        if selection_start is not None:
                                _, sel_line_start, sel_column_start = selection_start
                                _, sel_line_end,   sel_column_end   = selection_end
                                # If the line is completly selected
                                if current_line &gt; sel_line_start and current_line &lt; sel_line_end:
                                        part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, True)
                                        if (len(part_line) == 0):
                                                part_line = b&#34; &#34;
                                        self.write(clear_line+SELECTION_START+part_line+SELECTION_END)
                                # If the line is partially selected
                                else:
                                        part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, False)
                                        # part_line = line[self.column:self.column+self.width]
                                        if len(part_line) &gt; 0:
                                                # If the end of selection is outside the visible part
                                                if sel_column_end - self.column &lt; 0:
                                                        sel_column_end = 0
                                                else:
                                                        sel_column_end -= self.column

                                                # If the start of selection is outside the visible part
                                                if sel_column_start - self.column &lt; 0:
                                                        sel_column_start = 0
                                                else:
                                                        sel_column_start -= self.column

                                                # If the selection is on alone line
                                                if current_line == sel_line_end and current_line == sel_line_start:
                                                        self.write(clear_line)
                                                        self.colorize(part_line[:sel_column_start].encode(&#34;utf8&#34;))
                                                        self.write(SELECTION_START+part_line[sel_column_start:sel_column_end].encode(&#34;utf8&#34;)+SELECTION_END)
                                                        self.colorize(part_line[sel_column_end:].encode(&#34;utf8&#34;))
                                                # If current line is on the last selection line
                                                elif current_line == sel_line_end:
                                                        self.write(clear_line+SELECTION_START+part_line[:sel_column_end].encode(&#34;utf8&#34;)+SELECTION_END)
                                                        self.colorize(part_line[sel_column_end:].encode(&#34;utf8&#34;))
                                                # If current line is on the first selection line
                                                elif current_line == sel_line_start:
                                                        self.write(clear_line)
                                                        self.colorize(part_line[:sel_column_start].encode(&#34;utf8&#34;))
                                                        self.write(SELECTION_START+part_line[sel_column_start:].encode(&#34;utf8&#34;)+SELECTION_END)
                                                # Else the line is not selected
                                                else:
                                                        self.write(clear_line)
                                                        self.colorize(part_line.encode(&#34;utf8&#34;))
                                        else:
                                                if current_line &gt;= sel_line_start and current_line &lt;= sel_line_end:
                                                        self.write(clear_line+SELECTION_START+b&#34; &#34;+SELECTION_END)
                                                else:
                                                        self.write(clear_line)
                        else:
                                part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, True)
                                self.write(clear_line)
                                self.colorize(part_line)
                elif current_line == count_line:
                        self.write(clear_line)

        def colorize_none(self, text):
                &#34;&#34;&#34; No colorization &#34;&#34;&#34;
                self.write(text)

        def colorize_syntax(self, text):
                &#34;&#34;&#34; Syntax colorization &#34;&#34;&#34;
                self.colorizer.colorize(text, self)

        def refresh_line(self, selection_start, selection_end):
                &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
                screen_line,     screen_column = self.get_screen_position()
                refreshed = False

                # If the line must be refreshed before the cursor line
                if self.is_refresh_line_before:
                        self.is_refresh_line_before = False
                        self.show_line(self.text.get_cursor_line()-1, screen_line-1, selection_start, selection_end)
                        refreshed = True
                # If the line must be refreshed after the cursor line
                if self.is_refresh_line_after:
                        self.is_refresh_line_after = False
                        self.show_line(self.text.get_cursor_line()+1, screen_line+1, selection_start, selection_end)
                        offset = self.height - screen_line
                        self.show_line(self.text.get_cursor_line()+offset+1, screen_line+offset+1, selection_start, selection_end)
                        refreshed = True
                # If only the cursor line must be refresh
                if self.is_refresh_line:
                        self.is_refresh_line = False
                        self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)
                        refreshed = True

                # If no refresh detected and a selection started
                if selection_start is not None and refreshed is False:
                        # Refresh the selection
                        self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)

        def refresh(self):
                &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if self.refresh_part is not None:
                        self.refresh_content(selection_start, selection_end, self.refresh_part)
                        self.refresh_part = None
                # Refresh all required
                if self.is_refresh_all:
                        self.refresh_content(selection_start, selection_end, True)
                        self.is_refresh_all  = False
                        self.is_refresh_line = False
                else:
                        # If no selection activated
                        if selection_start is None:
                                # Refresh the current line
                                self.refresh_line(selection_start, selection_end)
                        else:
                                # Refresh the selection
                                self.refresh_content(selection_start, selection_end, False)
                self.move_cursor()
                self.flush()

        def refresh_content(self, selection_start, selection_end, all_):
                &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
                # If selection present
                if selection_start is not None:
                        # Get the selection
                        dummy, sel_line_start, sel_column_start = selection_start
                        dummy, sel_line_end,   sel_column_end   = selection_end
                        line_start = sel_line_start
                        line_end   = sel_line_end
                        # The aim of this part is to limit the refresh area
                        # If the precedent display show a selection
                        if self.sel_line_end is not None and self.sel_line_start is not None:
                                # If the start and end of selection is on the sames lines
                                if self.sel_line_end == sel_line_end and self.sel_line_start == sel_line_start:
                                        line_start = line_end = self.text.get_cursor_line()
                                else:
                                        # If the end of selection is after the precedent display
                                        if self.sel_line_end &gt; sel_line_end:
                                                line_end = self.sel_line_end
                                        # If the end of selection is on the same line than the precedent display
                                        elif self.sel_line_end == sel_line_end:
                                                # If the start of selection is before the precedent display
                                                if self.sel_line_start &lt; sel_line_start:
                                                        line_end = sel_line_start
                                                else:
                                                        line_end = self.sel_line_start
                                        # If the start of selection is before the precedent display
                                        if self.sel_line_start &lt; sel_line_start:
                                                line_start = self.sel_line_start
                                        # If the start of selection is on the same line than the precedent display
                                        elif self.sel_line_start == sel_line_start:
                                                # If the end of selection is after the precedent display
                                                if self.sel_line_end &gt; sel_line_end:
                                                        line_start = sel_line_end
                                                else:
                                                        line_start = self.sel_line_end
                else:
                        line_start = 0
                        line_end = self.line + self.height
                current_line = self.line
                screen_line = self.top
                if type(all_) == type([]):
                        line_start, line_end = all_
                        all_ = False
                count_line = self.text.get_count_lines()
                max_line = self.line + self.height
                if all_:
                        # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                        self.move_cursor(screen_line, 0)
                        self.write(b&#34;\x1B[J&#34;)
                        # Refresh all lines visible
                        while current_line &lt; count_line and current_line &lt;= max_line:
                                self.show_line(current_line, screen_line, selection_start, selection_end, True)
                                screen_line  += 1
                                current_line += 1
                                if (current_line &lt; count_line and current_line &lt;= max_line):
                                        self.write(b&#34;\n\r&#34;)
                else:
                        # Refresh all lines visible
                        while current_line &lt; count_line and current_line &lt;= max_line:
                                # If the line is in selection or all must be refreshed
                                if line_start &lt;= current_line &lt;= line_end or all_:
                                        self.show_line(current_line, screen_line, selection_start, selection_end)
                                screen_line  += 1
                                current_line += 1
                        if line_end &gt; max_line:
                                self.cls_end_screen()

                # If selection present
                if selection_start is not None:
                        # Save current selection
                        _, self.sel_line_start, _ = selection_start
                        _, self.sel_line_end,   _ = selection_end

        def hide_selection(self):
                &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if selection_start is not None:
                        self.set_refresh_selection()
                        self.sel_line_start = None
                        self.sel_line_end   = None

        def set_refresh_selection(self):
                &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if selection_start is not None:
                        line_start = selection_start[1]
                        if self.sel_line_start is not None:
                                if self.sel_line_start &lt; line_start:
                                        line_start = self.sel_line_start
                        line_end = selection_end[1]
                        if self.sel_line_end is not None:
                                if self.sel_line_end &gt; line_end:
                                        line_end = self.sel_line_end
                        self.refresh_part = [line_start, line_end]

        def move_cursor(self, screen_line=None, screen_column=None):
                &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
                if screen_line is None and screen_column is None:
                        screen_line, screen_column = self.get_screen_position()
                self.write(b&#34;\x1B[%d;%df&#34;%(screen_line+1, screen_column+1))

        def get_screen_size(self):
                &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
                height, width = tools.terminal.get_screen_size(True)
                self.screen_height = height
                self.screen_width = width
                self.height = height-self.top-1
                self.width  = width
                self.move_cursor()

        def cls(self):
                &#34;&#34;&#34; clear the screen &#34;&#34;&#34;
                self.write(b&#34;\x1B[2J&#34;)
                self.move_cursor(0,0)

        def cls_end_screen(self):
                &#34;&#34;&#34; clear the end of screen &#34;&#34;&#34;
                self.write(b&#34;\x1B[0J&#34;)

        def get_position(self):
                &#34;&#34;&#34; Get the position of view &#34;&#34;&#34;
                return self.line, self.column

class Text:
        &#34;&#34;&#34; Class which manage the text edition &#34;&#34;&#34;
        def __init__(self, cfg, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.lines = [&#34;&#34;]
                self.cursor_line   = 0
                self.cursor_column = 0
                self.tab_cursor_column   = 0
                self.modified     = False
                self.replace_mode  = False
                self.read_only     = read_only
                self.cfg = cfg
                self.view         = None
                self.tab_size      = self.cfg.tabsize
                self.selection_start = None
                self.selection_end   = None
                self.selection = []
                self.filename = None
                self.MOVE_KEYS = self.cfg.key_up+self.cfg.key_down+self.cfg.key_left+self.cfg.key_right+self.cfg.key_home+self.cfg.key_end+self.cfg.key_page_up+self.cfg.key_page_down+self.cfg.key_top+self.cfg.key_bottom+self.cfg.key_next_word+self.cfg.key_previous_word
                self.SELECT_KEYS = self.cfg.key_sel_up+self.cfg.key_sel_down+self.cfg.key_sel_right+self.cfg.key_sel_left+self.cfg.key_sel_home+self.cfg.key_sel_end+self.cfg.key_sel_top+self.cfg.key_sel_bottom+self.cfg.key_sel_page_up+self.cfg.key_sel_page_down+self.cfg.key_sel_all+self.cfg.key_sel_next_word+self.cfg.key_sel_prev_word
                self.NOT_READ_ONLY_KEYS = self.cfg.key_copy+self.cfg.key_cut+self.cfg.key_paste+self.cfg.key_indent+self.cfg.key_unindent+self.cfg.key_change_case+self.cfg.key_comment+self.cfg.key_backspace+self.cfg.key_delete+self.cfg.key_new_line+self.cfg.key_del_line
                self.begin_line = 1
                self.begin_column = 1

        def set_view(self, view):
                &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
                self.view = view

        def get_count_lines(self):
                &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
                return len(self.lines)

        def get_cursor_line(self):
                &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
                return self.cursor_line

        def get_tab_cursor(self, current_line, current_column=None):
                &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
                if current_column is None:
                        cursor_column = self.cursor_column
                else:
                        cursor_column = current_column
                line = self.lines[current_line]
                if &#34;\t&#34; in line:
                        tab_cursor_column   = 0
                        column = 0
                        len_line = len(line)
                        while column &lt; cursor_column:
                                if line[column] == &#34;\t&#34;:
                                        pos = tab_cursor_column%self.tab_size
                                        tab_cursor_column += self.tab_size-pos
                                        column          += 1
                                else:
                                        tab = line.find(&#34;\t&#34;,column)
                                        if tab &gt; 0:
                                                partSize = tab - column
                                        else:
                                                partSize = len_line - column
                                        if column + partSize &gt; cursor_column:
                                                partSize = cursor_column - column
                                        tab_cursor_column += partSize
                                        column          += partSize
                        return tab_cursor_column
                else:
                        return cursor_column

        def get_tab_line(self, current_line, start_column, end_column, binary = True):
                &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
                accent = False
                line = self.lines[current_line]
                if &#34;\t&#34; in line:
                        tab_line = b&#34;&#34;
                        cursor   = 0
                        len_line = len(line)
                        column = 0
                        while column &lt; len_line:
                                char = line[column]
                                if char == &#34;\t&#34;:
                                        pos = cursor%self.tab_size
                                        cursor += self.tab_size-pos
                                        tab_line          += b&#34; &#34;*(self.tab_size-pos)
                                        column            += 1
                                else:
                                        tab = line.find(&#34;\t&#34;,column)
                                        if tab &lt; 0:
                                                tab = len_line
                                        part = line[column:tab]
                                        cursor += len(part)
                                        bin_part = part.encode(&#34;utf8&#34;)
                                        tab_line          += bin_part
                                        column            += len(part)
                                        if len(part) != len(bin_part):
                                                accent = True

                        tab_line = tab_line.replace(b&#34;\n&#34;,b&#34;&#34;)
                        if binary is False:
                                tab_line = tab_line.decode(&#34;utf8&#34;)
                else:
                        if binary:
                                tab_line = line.encode(&#34;utf8&#34;)
                                if len(line) != len(tab_line):
                                        accent = True
                                tab_line = tab_line.replace(b&#34;\n&#34;,b&#34;&#34;)
                        else:
                                tab_line = line
                                tab_line = tab_line.replace(&#34;\n&#34;,&#34;&#34;)

                if binary and accent:
                        result = tab_line.decode(&#34;utf8&#34;)[start_column:end_column].encode(&#34;utf8&#34;)
                else:
                        result = tab_line[start_column:end_column]

                return result

        def get_tab_cursor_column(self):
                &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
                line = self.lines[self.cursor_line]
                column = 0
                self.tab_cursor_column = 0
                while column &lt; self.cursor_column:
                        if line[column] == &#34;\t&#34;:
                                pos = self.tab_cursor_column%self.tab_size
                                self.tab_cursor_column += self.tab_size-pos
                                column += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        delta = tab - column
                                        if column + delta &gt; self.cursor_column:
                                                delta = self.cursor_column - column
                                                self.tab_cursor_column += delta
                                                column += delta
                                        else:
                                                self.tab_cursor_column += delta
                                                column += delta
                                else:
                                        delta = self.cursor_column - column
                                        self.tab_cursor_column += delta
                                        column += delta

        def set_cursor_column(self):
                &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
                line = self.lines[self.cursor_line]
                column = 0
                tab_cursor_column = 0
                len_line = len(line)
                column = 0
                while column &lt; len_line:
                        char = line[column]
                        # If the previous position found exactly in the current line
                        if tab_cursor_column == self.tab_cursor_column:
                                self.cursor_column = column
                                break
                        # If the previous position not found in the current line
                        if tab_cursor_column &gt; self.tab_cursor_column:
                                # Keep last existing position
                                self.cursor_column = column
                                break
                        # If tabulation found
                        if char == &#34;\t&#34;:
                                tab_cursor_column += self.tab_size-(tab_cursor_column%self.tab_size)
                                column += 1
                        else:
                                # Optimization to accelerate the cursor position
                                tab = line.find(&#34;\t&#34;, column)

                                # Tabulation found
                                if tab &gt; 0:
                                        delta = tab - column
                                        # If the tabulation position is after the previous tabulation cursor
                                        if delta + tab_cursor_column &gt; self.tab_cursor_column:
                                                # Move the cursor to the left
                                                self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                                break
                                        else:
                                                # Another tabulation found, move it after
                                                tab_cursor_column += delta
                                                column += delta
                                # Tabulation not found
                                else:
                                        # Move the cursor to the end of line
                                        self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                        break
                else:
                        if len(line) &gt;= 1:
                                self.cursor_column = len(line)-1
                        else:
                                self.cursor_column = 0

        def getFilename(self):
                &#34;&#34;&#34; Return the filename &#34;&#34;&#34;
                return self.filename

        def load(self, filename):
                &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
                self.filename = None
                try:
                        self.lines = []
                        self.filename = filename
                        file = open(filename, &#34;r&#34;)
                        line = file.readline()
                        while line != &#34;&#34;:
                                self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                                line = file.readline()
                        file.close()
                        if len(self.lines) == 0:
                                self.lines = [&#34;&#34;]
                except MemoryError:
                        # pylint: disable=raise-missing-from
                        raise MemoryError()
                except OSError:
                        self.lines = [&#34;&#34;]
                        # File not existing
                except Exception as err:
                        tools.logger.syslog(err)
                        self.lines = [&#34;&#34;]

        def save(self, filename=None):
                &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
                result = False
                if self.read_only is False:
                        if filename is None:
                                filename = self.filename
                        if filename is not None:
                                try:
                                        file = open(filename, &#34;w&#34;)
                                        for line in self.lines:
                                                file.write(line)
                                        file.close()
                                        self.modified = False
                                        result = True
                                except Exception as err:
                                        tools.logger.syslog(err)
                return result

        def change_line(self, moveLine):
                &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
                # If cursor is before the first line
                if moveLine + self.cursor_line &lt; 0:
                        # Set the cursor to the first line
                        self.cursor_line = 0
                        self.cursor_column = 0
                        self.change_column(0)
                # If the cursor is after the last line
                elif moveLine + self.cursor_line &gt;= len(self.lines):
                        self.cursor_line = len(self.lines) -1
                        self.cursor_column = len(self.lines[self.cursor_line])
                        self.change_column(0)
                # else the cursor is in the lines of text
                else:
                        self.cursor_line += moveLine
                        if len(self.lines) - 1 == self.cursor_line:
                                len_line = len(self.lines[self.cursor_line])
                        else:
                                len_line = len(self.lines[self.cursor_line])-1

                        self.set_cursor_column()
                        # If the new cursor position is outside the line of text
                        if self.cursor_column &gt; len_line:
                                self.change_column(tools.terminal.MAXINT)

                if self.selection_start is not None:
                        self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]
                self.view.move()

        def change_column(self, move_column, with_move_view=True):
                &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
                cursor_line   = self.cursor_line
                cursor_column = self.cursor_column
                # If the cursor go to the previous line
                if move_column + self.cursor_column &lt; 0:
                        # If start of line
                        if abs(move_column) &gt; 1:
                                self.cursor_column = 0
                        # If move to the left and must go to previous line
                        elif self.cursor_line &gt; 0:
                                self.cursor_line -= 1
                                self.cursor_column = len(self.lines[self.cursor_line])-1
                # If the cursor is at the end of line
                elif move_column + self.cursor_column &gt; len(self.lines[self.cursor_line])-1:
                        # If the cursor is on the last line of file
                        if abs(move_column) &gt; 1 or self.cursor_line+1 == len(self.lines):
                                # If the file is empty
                                if self.lines[self.cursor_line] == &#34;&#34;:
                                        self.cursor_column = 0
                                        self.tab_cursor_column = 0
                                # If the last line of contains return char
                                elif self.lines[self.cursor_line][-1] == &#34;\n&#34;:
                                        # Move cursor before return
                                        self.cursor_column = len(self.lines[self.cursor_line])-1
                                else:
                                        # Move cursor after the last char
                                        self.cursor_column = len(self.lines[self.cursor_line])

                        # If the cursor is on the end of line and must change of line
                        elif self.cursor_line+1 &lt; len(self.lines):
                                self.cursor_line += 1
                                self.cursor_column = 0
                                self.tab_cursor_column = 0
                # Normal move of cursor
                else:
                        # Next or previous column
                        self.cursor_column += move_column
                if abs(move_column) &gt; 0:
                        self.get_tab_cursor_column()
                self.close_selection()
                if with_move_view:
                        self.view.move()
                if self.cursor_column == cursor_column and self.cursor_line == cursor_line:
                        return False
                else:
                        return True

        def backspace(self, keys=None):
                &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        # The cursor not in the begining of line
                        if self.cursor_column &gt;= 1:
                                line = self.lines[self.cursor_line]
                                line = line[0:self.cursor_column-1:]+ line[self.cursor_column  : :]
                                self.lines[self.cursor_line] = line
                                self.change_column(-1)
                                self.view.set_refresh_line()
                        # The cursor is on the begining of line
                        else:
                                # If the cursor not on the first line
                                if self.cursor_line &gt;= 1:
                                        # Copy the current line to the end of previous line
                                        self.cursor_column = len(self.lines[self.cursor_line-1])
                                        self.lines[self.cursor_line-1] = self.lines[self.cursor_line-1][:-1] + self.lines[self.cursor_line]
                                        del self.lines[self.cursor_line]
                                        self.view.scroll_part_up()
                                        self.cursor_line -= 1
                                        self.view.set_refresh_after()
                                        self.change_column(-1)

        def delete(self, keys=None):
                &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        line = self.lines[self.cursor_line]
                        if self.cursor_column &lt; len(line):
                                # If the line is empty
                                if line[self.cursor_column] == &#34;\n&#34;:
                                        # If the cursor not at end of files
                                        if self.cursor_line &lt; len(self.lines)-1:
                                                # Copy the next line to the current line
                                                self.lines[self.cursor_line] = line[:self.cursor_column] + self.lines[self.cursor_line+1]
                                                del self.lines[self.cursor_line+1]
                                                self.view.scroll_part_up()
                                                self.view.set_refresh_after()
                                # Else the char is deleted in the middle of line
                                else:
                                        line = line[0:self.cursor_column:]+ line[self.cursor_column+1  : :]
                                        self.lines[self.cursor_line] = line
                                        self.change_column(0)
                                        self.view.is_refresh_line = True

        def delete_line(self, keys=None):
                &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
                self.hide_selection()
                self.modified = True
                # If file contains one or none line
                if len(self.lines) &lt;= 1:
                        # Clean the content of file
                        self.lines = [&#34;&#34;]
                        self.cursor_column = 0
                        self.cursor_line = 0
                        self.change_column(0)
                # If the current line is not the last of file
                elif self.cursor_line &lt; len(self.lines):
                        # Delete the line
                        self.cursor_column = 0
                        del self.lines[self.cursor_line]
                        self.view.scroll_part_up()
                        if self.cursor_line &gt;= len(self.lines):
                                self.cursor_line = len(self.lines)-1
                        self.change_column(0)
                self.view.set_refresh_after()

        def new_line(self, keys=None):
                &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
                self.modified = True
                self.remove_selection()
                line1 = self.lines[self.cursor_line][:self.cursor_column]+&#34;\n&#34;
                line2 = self.lines[self.cursor_line][self.cursor_column:]
                self.lines[self.cursor_line]=line1
                self.lines.insert(self.cursor_line+1, line2)
                self.view.scroll_part_down()
                self.change_column(1)
                self.view.set_refresh_before()

        def insert_char(self, char):
                &#34;&#34;&#34; Insert character &#34;&#34;&#34;
                self.modified = True
                self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column:]
                self.change_column(len(char))
                self.view.set_refresh_line()

        def replace_char(self, char):
                &#34;&#34;&#34; Replace character &#34;&#34;&#34;
                self.modified = True
                if self.cursor_line == len(self.lines)-1 and self.cursor_column &gt;= len(self.lines[self.cursor_line])-1:
                        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char
                        self.change_column(1)
                        self.view.set_refresh_line()
                # If it is the last char in the line
                elif self.lines[self.cursor_line][self.cursor_column] == &#34;\n&#34;:
                        # Append char to the line
                        self.insert_char(char)
                # Else the char must be replaced in the line
                else:
                        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column+1:]
                        self.change_column(1)
                        self.view.set_refresh_line()

        def open_selection(self):
                &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
                if self.selection_start is None:
                        self.selection_start = [self.cursor_column, self.cursor_line, self.get_tab_cursor(self.cursor_line, self.cursor_column)]

        def close_selection(self):
                &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
                if self.selection_start is not None:
                        self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]

        def select_all(self, keys=None):
                &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
                self.selection_start = [0,0,0]
                lastLine = len(self.lines)-1
                lastColumn = len(self.lines[lastLine])
                self.move_cursor(lastLine, lastColumn)
                self.selection_end  = [lastColumn, lastLine, self.get_tab_cursor(lastLine, lastColumn)]
                self.view.set_refresh_all()

        def get_selection(self):
                &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
                if self.selection_start is not None and self.selection_end is not None:
                        if self.selection_start[1] &gt; self.selection_end[1]:
                                return self.selection_end, self.selection_start
                        elif self.selection_start[1] &lt; self.selection_end[1]:
                                return self.selection_start, self.selection_end
                        elif self.selection_start[0] &lt; self.selection_end[0]:
                                return self.selection_start, self.selection_end
                        else:
                                return self.selection_end, self.selection_start
                else:
                        return None, None

        def arrow_up(self, keys=None):
                &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line(-1)

        def arrow_down(self, keys=None):
                &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line(1)

        def arrow_left(self, keys=None):
                &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(-len(keys))

        def arrow_right(self, keys=None):
                &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(len(keys))

        def select_up(self, keys=None):
                &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
                self.open_selection()
                self.change_line(-1)

        def select_down(self, keys=None):
                &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
                self.open_selection()
                self.change_line(1)

        def select_left(self, keys=None):
                &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(-len(keys))

        def select_right(self, keys=None):
                &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(len(keys))

        def select_home(self, keys=None):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(-tools.terminal.MAXINT)

        def select_end(self, keys=None):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(tools.terminal.MAXINT)

        def select_page_up(self, keys=None):
                &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
                self.open_selection()
                self.change_line((-(self.view.height)) * len(keys))
                self.change_column(-tools.terminal.MAXINT)

        def select_page_down(self, keys=None):
                &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
                self.open_selection()
                self.change_line((self.view.height) * len(keys))
                self.change_column(tools.terminal.MAXINT)

        def select_next_word(self, keys=None):
                &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
                self.open_selection()
                self.move_word(1)

        def select_previous_word(self, keys=None):
                &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
                self.open_selection()
                self.move_word(-1)

        def select_top(self, keys=None):
                &#34;&#34;&#34; Manage select to the first line of text &#34;&#34;&#34;
                self.open_selection()
                self.change_line(-tools.terminal.MAXINT)

        def select_bottom(self, keys=None):
                &#34;&#34;&#34; Manage select to the last line of text &#34;&#34;&#34;
                self.open_selection()
                self.change_line(tools.terminal.MAXINT)

        def page_up(self, keys=None):
                &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line((-(self.view.height)) * len(keys))

        def page_down(self, keys=None):
                &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line((self.view.height) * len(keys))

        def home(self, keys=None):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(-tools.terminal.MAXINT)

        def end(self, keys=None):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(tools.terminal.MAXINT)

        def add_char(self, keys=None):
                &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
                result = False

                if tools.strings.isascii(keys[0]):
                        self.remove_selection()
                        for char in keys:
                                if tools.strings.isascii(char):
                                        if self.replace_mode:
                                                self.replace_char(char)
                                        else:
                                                self.insert_char(char)
                                        result = True
                # if result is False:
                        # print(tools.strings.dump(keys[0]))
                return result

        def find_next(self, text):
                &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
                result = False
                # Get the selection
                selection_start, selection_end = self.get_selection()

                # Hide the selection
                self.hide_selection()

                # Set the start of search at the cursor position
                current_line   = self.cursor_line
                current_column = self.cursor_column

                # If selection activated
                if selection_start is not None and selection_end is not None:
                        # If selection is on one line
                        if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                                # If selection is exactly the size of text
                                if selection_start[0] == current_column:
                                        # Move the start of search after the text selected
                                        current_column = selection_end[0]

                # Find the text in next lines
                while current_line &lt; len(self.lines):
                        # Search text
                        pos = self.lines[current_line].find(text, current_column)

                        # If text found
                        if pos &gt;= 0:
                                # Move the cursor to the text found
                                self.cursor_line = current_line
                                self.cursor_column = pos + len(text)
                                self.change_column(0)
                                self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                                self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                                result = True
                                break
                        else:
                                # Set the search position at the begin of next line
                                current_column = 0
                                current_line += 1
                self.view.move()
                return result

        def find_previous(self, text):
                &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
                result = False
                # Get the selection
                selection_start, selection_end = self.get_selection()

                # Hide the selection
                self.hide_selection()

                # Set the start of search at the cursor position
                current_line   = self.cursor_line
                current_column = self.cursor_column

                # If selection activated
                if selection_start is not None and selection_end is not None:
                        # If selection is on one line
                        if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                                # If selection is exactly the size of text
                                if selection_end[0] - selection_start[0] == len(text):
                                        # Move the start of search before the text selected
                                        current_column = selection_start[0]

                # While the line before the first line not reached
                while current_line &gt;= 0:
                        # Get the current line
                        line = self.lines[current_line]

                        # If the current column is negative
                        if current_column &lt; 0:
                                # Set the end of line
                                current_column = len(line)

                        # Search the text in reverse
                        pos = line.rfind(text, 0, current_column)

                        # If text found
                        if pos &gt;= 0:
                                self.cursor_line = current_line
                                self.cursor_column = pos
                                self.change_column(0)
                                self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                                self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                                result = True
                                break
                        else:
                                # Set the search position at the end of line
                                current_column = -1
                                current_line -= 1
                self.view.move()
                return result

        def hide_selection(self):
                &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
                self.view.hide_selection()
                self.selection_start = self.selection_end = None

        def goto(self, line, column=None, clear_selection=True):
                &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
                if clear_selection:
                        self.hide_selection()
                if line &lt; 0:
                        self.cursor_line = len(self.lines)-1
                elif line &lt; 1:
                        self.cursor_line = 1
                elif line &lt;= len(self.lines):
                        self.cursor_line = line - 1
                else:
                        self.cursor_line = len(self.lines)-1
                        if column is not None:
                                column = tools.terminal.MAXINT
                self.cursor_column = 0

                if column is not None:
                        if column &gt; 1:
                                cur_line = self.cursor_line
                                self.change_column(0, with_move_view=False)
                                for i in range(len(self.lines[self.cursor_line]) + 1):
                                        self.change_column(1, with_move_view=False)
                                        if self.tab_cursor_column &gt;= column-1:
                                                break

                                        if self.cursor_line != cur_line:
                                                self.change_column(-1, with_move_view=False)
                                                break

                self.view.move()

        def copy_clipboard(self):
                &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
                result = []
                if self.selection_start is not None:
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end
                        result = []
                        if sel_line_start == sel_line_end:
                                result.append(self.lines[sel_line_start][sel_column_start:sel_column_end])
                        else:
                                for line in range(sel_line_start, sel_line_end+1):
                                        if line == sel_line_start:
                                                part = self.lines[line][sel_column_start:]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][sel_column_start:])
                                        elif line == sel_line_end:
                                                part = self.lines[line][:sel_column_end]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][:sel_column_end])
                                        else:
                                                result.append(self.lines[line])
                return result

        def remove_selection(self):
                &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
                if self.selection_start is not None:
                        self.modified = True
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, _ = selection_start
                        sel_column_end,   sel_line_end,   _ = selection_end
                        start = self.lines[sel_line_start][:sel_column_start]
                        end   = self.lines[sel_line_end  ][sel_column_end:]
                        self.lines[sel_line_start] = start + end
                        if sel_line_start &lt; sel_line_end:
                                for line in range(sel_line_end, sel_line_start,-1):
                                        del self.lines[line]
                        self.move_cursor(sel_line_start, sel_column_start)
                        self.hide_selection()
                        if sel_line_end == sel_line_start:
                                self.view.set_refresh_line()
                        else:
                                self.view.set_refresh_bottom(sel_line_start)
                        return True
                return False

        def paste_clipboard(self, selection):
                &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
                if selection != [] and selection != [&#34;&#34;]:
                        start_line = self.cursor_line
                        # Split the line with insertion
                        start = self.lines[self.cursor_line][:self.cursor_column]
                        end   = self.lines[self.cursor_line][self.cursor_column:]

                        # Paste the first line
                        self.lines[self.cursor_line] = start + selection[0]

                        self.cursor_line += 1

                        # Insert all lines from clipboard
                        for line in selection[1:-1]:
                                self.lines.insert(self.cursor_line, line)
                                self.cursor_line += 1

                        # If the last line of clipboard is not empty
                        if len(selection[-1]) &gt;= 1:
                                # If the last line of clipboard contains carriage return at the end
                                if selection[-1][-1] == &#34;\n&#34;:
                                        if len(selection) &gt; 1:
                                                # Add the new line
                                                self.lines.insert(self.cursor_line, selection[-1])
                                                self.cursor_line += 1

                                        # Add the part after the insertion
                                        self.lines.insert(self.cursor_line, end)
                                        self.cursor_column = 0
                                        if len(selection) &gt;= self.view.height:
                                                self.view.set_refresh_all()
                                        else:
                                                self.view.set_refresh_bottom(start_line)
                                else:
                                        # If many lines with last line without carriage return at the end
                                        if len(selection) &gt; 1:
                                                self.lines.insert(self.cursor_line, selection[-1] + end)
                                                self.cursor_column = len(selection[-1])
                                                if len(selection) &gt;= self.view.height:
                                                        self.view.set_refresh_all()
                                                else:
                                                        self.view.set_refresh_bottom(start_line)
                                        else:
                                                # Only one line without carriage return
                                                self.cursor_line -= 1
                                                self.lines[self.cursor_line] += end
                                                self.cursor_column = len(start) + len(selection[-1])
                                                self.view.set_refresh_line()
                        self.move_cursor(self.cursor_line, self.cursor_column)

        def move_cursor(self, line, column):
                &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
                self.cursor_line   = line
                self.cursor_column = column
                self.change_column(0)
                self.get_tab_cursor_column()

        def copy(self, keys=None):
                &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
                self.selection = self.copy_clipboard()

        def cut(self, keys=None):
                &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
                self.modified = True
                self.selection = self.copy_clipboard()
                self.remove_selection()

        def paste(self, keys=None):
                &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
                self.modified = True
                self.remove_selection()
                self.paste_clipboard(self.selection)
                self.hide_selection()

        def change_case(self, keys=None):
                &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
                selection = self.copy_clipboard()
                if len(selection) &gt; 0:
                        self.modified = True
                        selection_start = self.selection_start
                        selection_end   = self.selection_end

                        self.remove_selection()
                        isUpper = None
                        for line in selection:
                                for char in line:
                                        if tools.strings.isupper(char):
                                                isUpper = True
                                                break
                                        elif tools.strings.islower(char):
                                                isUpper = False
                                                break
                                if isUpper is not None:
                                        break
                        # pylint:disable=consider-using-enumerate
                        for line in range(len(selection)):
                                if isUpper:
                                        selection[line] = selection[line].lower()
                                else:
                                        selection[line] = selection[line].upper()
                        self.paste_clipboard(selection)
                        self.view.set_refresh_selection()
                        self.selection_start = selection_start
                        self.selection_end   = selection_end

        def comment(self, keys=None):
                &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
                self.modified = True

                # If selection
                if self.selection_start is not None:
                        selection_start, selection_end = self.get_selection()
                        _, sel_line_start, _ = selection_start
                        _, sel_line_end,   _ = selection_end

                        # Add tabulation
                        for line in range(sel_line_start, sel_line_end+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] != &#39;#&#39;:
                                                self.lines[line] = &#34;#&#34; + self.lines[line]
                                        else:
                                                if len(self.lines[line]) &gt;= 1:
                                                        self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selection_start = [0,sel_line_start, 0]

                        # Get the length of last selected line
                        len_line_end =  len(self.lines[sel_line_end])

                        # Move the end of selection at the end of line selected
                        self.selection_end   = [len_line_end-1, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end-1)]
                        self.view.set_refresh_selection()
                else:
                        if len(self.lines[self.cursor_line]) &gt;= 1:
                                # If nothing selected
                                if self.lines[self.cursor_line][0] == &#34;#&#34;:
                                        self.lines[self.cursor_line] = self.lines[self.cursor_line][1:]
                                        if self.cursor_column &gt; 0:
                                                self.change_column(-1)
                                else:
                                        self.lines[self.cursor_line] = &#34;#&#34; + self.lines[self.cursor_line]
                                        self.change_column(1)
                        self.view.set_refresh_line()

        def indent(self, keys=None):
                &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
                # If nothing selected
                if self.selection_start is None:
                        self.add_char(keys)
                else:
                        self.modified = True
                        # Indent selection
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end

                        # If a part of line selected
                        if sel_line_start == sel_line_end and not (sel_column_start == 0 and sel_column_end == len(self.lines[sel_line_end])-1):
                                self.add_char(self.cfg.key_indent)
                        else:
                                # If the last line selected is at beginning of line
                                if sel_column_end == 0:
                                        # This line must not be indented
                                        sel_line_end -= 1

                                # Add tabulation
                                for line in range(sel_line_start, sel_line_end+1):
                                        self.lines[line] = &#34;\t&#34; + self.lines[line]

                                # Move the start selection to the start of first selected line
                                self.selection_start = [0,sel_line_start, 0]

                                # If the last line selected is not at beginning of line
                                if sel_column_end &gt; 0:
                                        # Get the length of last selected line
                                        len_line_end =  len(self.lines[sel_line_end])

                                        # If the end of selection is not on the last line
                                        if sel_line_end &lt; len(self.lines)-1:
                                                len_line_end -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selection_end  = [0, sel_line_end+1, 0]
                        self.view.set_refresh_selection()

        def unindent(self, keys=None):
                &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
                # If nothing selected
                if self.selection_start is None:
                        self.backspace()
                else:
                        self.modified = True

                        # Unindent selection
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end

                        # If the selection is only alone line
                        if sel_line_start == sel_line_end:
                                self.hide_selection()
                        else:
                                # If the last line selected is at beginning of line
                                if sel_column_end == 0:
                                        # This line must not be indented
                                        sel_line_end -= 1

                                # Remove indentation
                                for line in range(sel_line_start, sel_line_end+1):
                                        if len(self.lines[line]) &gt;= 1:
                                                if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                        self.lines[line] = self.lines[line][1:]

                                # Move the start selection to the start of first selected line
                                self.selection_start = [0,sel_line_start, 0]

                                # If the last line selected is not at beginning of line
                                if sel_column_end &gt; 0:
                                        # Get the length of last selected line
                                        len_line_end =  len(self.lines[sel_line_end])

                                        # If the end of selection is not on the last line
                                        if sel_line_end &lt; len(self.lines)-1:
                                                len_line_end -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selection_end  = [0, sel_line_end+1, 0]
                        self.view.set_refresh_selection()

        def replace(self, old, new):
                &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
                if self.read_only is False:
                        selection = self.copy_clipboard()
                        if len(selection) == 1:
                                if selection[0] == old:
                                        self.delete()
                                        self.insert_char(new)
                                        return True
                return False

        def get_cursor_char(self):
                &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
                try:
                        return self.lines[self.cursor_line][self.cursor_column]
                except:
                        return None

        def move_word(self, direction):
                &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
                state = 0
                while self.change_column(direction):
                        current_char = self.get_cursor_char()
                        if current_char is None:
                                break
                        elif tools.strings.ispunctuation(current_char):
                                if state == 0:
                                        state = 2
                                elif state == 1:
                                        break
                        elif tools.strings.isalpha(current_char):
                                if state == 0:
                                        state = 1
                                elif state == 2:
                                        break
                        elif tools.strings.isspace(current_char):
                                if state == 1:
                                        break
                                if state == 2:
                                        break

        def next_word(self, keys=None):
                &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
                self.hide_selection()
                self.move_word(1)
                self.view.move()

        def previous_word(self, keys=None):
                &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
                self.hide_selection()
                self.move_word(-1)
                self.view.move()

        def top(self, keys=None):
                &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
                self.goto(1)

        def bottom(self, keys=None):
                &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
                self.goto(tools.terminal.MAXINT)

        def treat_char(self, keys=None):
                &#34;&#34;&#34; Treat character entered &#34;&#34;&#34;
                char = ord(keys[0][0])
                if self.read_only is False:
                        if char &gt;= 0x20 and char != 0x7F:
                                self.add_char(keys)
                                return True
                return False

        def treat_key(self, keys=None):
                &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
                key_callback = None
                if self.treat_char(keys) is False:
                        # Move in the edit field
                        if keys[0] in self.MOVE_KEYS:
                                if   keys[0] in self.cfg.key_left:            key_callback = self.arrow_left
                                elif keys[0] in self.cfg.key_right:           key_callback = self.arrow_right
                                elif keys[0] in self.cfg.key_up  :            key_callback = self.arrow_up
                                elif keys[0] in self.cfg.key_down:            key_callback = self.arrow_down
                                elif keys[0] in self.cfg.key_home:            key_callback = self.home
                                elif keys[0] in self.cfg.key_end:             key_callback = self.end
                                elif keys[0] in self.cfg.key_page_up:         key_callback = self.page_up
                                elif keys[0] in self.cfg.key_page_down:       key_callback = self.page_down
                                elif keys[0] in self.cfg.key_top:             key_callback = self.top
                                elif keys[0] in self.cfg.key_bottom:          key_callback = self.bottom
                                elif keys[0] in self.cfg.key_next_word:       key_callback = self.next_word
                                elif keys[0] in self.cfg.key_previous_word:   key_callback = self.previous_word
                        elif keys[0] in self.SELECT_KEYS:
                                # Selection the edit field
                                if   keys[0] in self.cfg.key_sel_right:    key_callback = self.select_right
                                elif keys[0] in self.cfg.key_sel_left:     key_callback = self.select_left
                                elif keys[0] in self.cfg.key_sel_up:       key_callback = self.select_up
                                elif keys[0] in self.cfg.key_sel_down:     key_callback = self.select_down
                                elif keys[0] in self.cfg.key_sel_home:     key_callback = self.select_home
                                elif keys[0] in self.cfg.key_sel_end:      key_callback = self.select_end
                                elif keys[0] in self.cfg.key_sel_top:      key_callback = self.select_top
                                elif keys[0] in self.cfg.key_sel_bottom:   key_callback = self.select_bottom
                                elif keys[0] in self.cfg.key_sel_page_up:  key_callback = self.select_page_up
                                elif keys[0] in self.cfg.key_sel_page_down:key_callback = self.select_page_down
                                elif keys[0] in self.cfg.key_sel_all:      key_callback = self.select_all
                                elif keys[0] in self.cfg.key_sel_next_word:key_callback = self.select_next_word
                                elif keys[0] in self.cfg.key_sel_prev_word:key_callback = self.select_previous_word

                        # If the edit is not in read only
                        elif self.read_only is False:
                                if keys[0] in self.NOT_READ_ONLY_KEYS:
                                        # Modification in the edit field
                                        if   keys[0] in self.cfg.key_copy:        key_callback = self.copy
                                        elif keys[0] in self.cfg.key_cut:         key_callback = self.cut
                                        elif keys[0] in self.cfg.key_paste:       key_callback = self.paste
                                        elif keys[0] in self.cfg.key_indent:      key_callback = self.indent
                                        elif keys[0] in self.cfg.key_unindent:    key_callback = self.unindent
                                        elif keys[0] in self.cfg.key_change_case: key_callback = self.change_case
                                        elif keys[0] in self.cfg.key_comment:     key_callback = self.comment
                                        elif keys[0] in self.cfg.key_backspace:   key_callback = self.backspace
                                        elif keys[0] in self.cfg.key_delete:      key_callback = self.delete
                                        elif keys[0] in self.cfg.key_new_line:    key_callback = self.new_line
                                        elif keys[0] in self.cfg.key_del_line:    key_callback = self.delete_line
                        # else: self.add_char(keys)
                        if key_callback is not None:
                                key_callback(keys)
                        else:
                                if len(keys[0]) &gt; 3:
                                        # If camflasher mouse selection
                                        if keys[0][0:2] == &#34;\x1B[&#34; and keys[0][-1] in [&#34;x&#34;,&#34;y&#34;]:
                                                try:
                                                        pos = keys[0][2:-1]
                                                        line, column = pos.split(&#34;;&#34;)
                                                        self.begin_line, self.begin_column = self.view.get_position()
                                                        if keys[0][-1] == &#34;x&#34;:
                                                                self.goto(int(line)+self.begin_line,int(column)+self.begin_column, True)
                                                                self.open_selection()
                                                                self.close_selection()
                                                        else:
                                                                self.goto(int(line)+self.begin_line,int(column)+self.begin_column, False)
                                                                self.close_selection()
                                                except Exception as err:
                                                        pass

class Edit:
        &#34;&#34;&#34; Class which aggregate the View and Text &#34;&#34;&#34;
        def __init__(self, cfg, view_top=1, view_height=None, read_only=False, extension=None):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.view = View(cfg, view_height, view_top, extension=extension)
                self.text = Text(cfg, read_only)
                self.text.set_view(self.view)
                self.view.set_text(self.text)

class Editor:
        &#34;&#34;&#34; Class which manage a complete editor &#34;&#34;&#34;
        def __init__(self, filename, no_color=False, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.cfg = EditorConfig()
                if self.cfg.load(tobytes=False, errorlog=False) is False:
                        self.cfg.save()

                self.displayed_filename = tools.filesystem.split(filename)[1]
                if no_color:
                        extension = &#34;&#34;
                else:
                        extension = tools.filesystem.splitext(filename)[1]
                self.edit = Edit(self.cfg, read_only=read_only, extension=extension)
                self.edit.text.load(filename)
                self.is_refresh_header = True
                self.find_text = None
                self.replace_text = None
                self.keys= []
                self.loop = None
                self.key_callback = None
                self.precedent_callback = None
                self.trace = None
                if tools.filesystem.ismicropython() is False:
                        if filename == &#34;newfile.py&#34;:
                                self.trace = open(self.cfg.config_root() + &#34;/key.txt&#34;,&#34;w&#34;)

                if (not tools.filesystem.exists(filename) and read_only is True) or tools.filesystem.isdir(filename):
                        print(&#34;Cannot open &#39;%s&#39;&#34;%self.displayed_filename)
                else:
                        try:
                                self.run()
                        except Exception as err:
                                self.edit.view.cls()
                                tools.logger.syslog(err)
                                print(&#34;Failed edit &#39;%s&#39;&#34;%self.displayed_filename)

        def refresh_header(self):
                &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
                if self.is_refresh_header:
                        self.edit.view.move_cursor(0, 0)
                        filename = &#34;\u25C1 File: %s&#34;%(self.displayed_filename)
                        if self.edit.text.read_only is False:
                                filename += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                                end = &#34; Mode: %s &#34;%(&#34;Replace&#34; if self.edit.text.replace_mode else &#34;Insert&#34;)
                        else:
                                end = &#34; Read only &#34; if self.edit.text.read_only else &#34;&#34;
                        end = &#34;L%d C%d &#34;%(self.edit.text.cursor_line+1, self.edit.view.tab_cursor_column+1) + end + &#34;\u25B7&#34;

                        header = &#34;\x1B[7m%s%s%s\x1B[m&#34;%(filename, &#34; &#34;*(self.edit.view.width - len(filename) - len(end)), end)
                        self.edit.view.write(header)
                        self.edit.view.move_cursor()
                        self.is_refresh_header = False

        def refresh(self):
                &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
                self.refresh_header()
                self.edit.view.refresh()

        def toggle_mode(self, keys=None):
                &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
                if self.edit.text.replace_mode:
                        self.edit.text.replace_mode = False
                else:
                        self.edit.text.replace_mode = True
                self.is_refresh_header = True

        def save(self, keys=None, filename=None):
                &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
                self.edit.text.save(filename)
                self.is_refresh_header = True

        def exit(self, keys=None):
                &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
                self.edit.view.cls()
                if self.edit.text.modified:
                        self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.displayed_filename)
                        self.edit.view.flush()
                        while 1:
                                key = tools.terminal.getch()
                                if key == &#34;Y&#34; or key == &#34;y&#34;:
                                        if self.edit.text.save():
                                                self.edit.view.write(&#34;Saved\n&#34;)
                                                self.edit.view.flush()
                                        else:
                                                self.edit.view.write(&#34;Failed to save\n&#34;)
                                                self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == &#34;N&#34; or key == &#34;n&#34;:
                                        self.edit.view.write(&#34;Not saved\n&#34;)
                                        self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == &#34;\x1B&#34;:
                                        self.edit.view.set_refresh_all()
                                        self.is_refresh_header = True
                                        break
                else:
                        self.loop = False

        def input(self, text, help_=None):
                &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
                edit_ = Edit(cfg=self.cfg, view_top=4, view_height=1, read_only=False)
                edit_.view.cls()
                edit_.view.move_cursor(3,0)
                edit_.view.write(text)
                edit_.view.move_cursor(1,0)
                if help_ is not None:
                        for item in help_:
                                key, text = item
                                edit_.view.write(&#34;\x1B[7m%s\x1B[m:%s \t&#34;%(key, text))
                result = None
                while 1:
                        edit_.view.refresh()
                        key = self.get_key()
                        if key[0] in self.cfg.key_new_line:
                                result = edit_.text.lines[0]
                                break
                        elif key[0] in &#34;\x1B&#34;:
                                break
                        else:
                                edit_.text.treat_key(key)
                return result

        def find(self, keys=None):
                &#34;&#34;&#34; Find a text &#34;&#34;&#34;
                self.find_text = self.input(&#34;Find :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;),(&#34;Shift-F3 or Ctrl-P&#34;,&#34;Previous&#34;),(&#34;F3 or Ctrl-N&#34;,&#34;Next&#34;)])
                self.find_next()
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True
                self.replace_text = None

        def replace(self, keys=None):
                &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
                self.find_text    = self.input(&#34;Find to replace :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;)])
                if self.find_text:
                        self.replace_text = self.input(&#34;Replace with :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;),(&#34;Shift-F3 or Ctrl-P&#34;,&#34;Previous&#34;),(&#34;F3 or Ctrl-N&#34;,&#34;Next&#34;),(&#34;Enter&#34;,&#34;Replace current&#34;)])
                        self.find_next()

                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def replace_current(self, keys=None):
                &#34;&#34;&#34; Replace current &#34;&#34;&#34;
                if self.find_text and self.replace_text:
                        if self.edit.text.replace(self.find_text, self.replace_text):
                                self.find_next()

        def replace_all(self, keys=None):
                &#34;&#34;&#34; Replace replace all &#34;&#34;&#34;
                if self.find_text and self.replace_text:
                        self.edit.text.top()
                        while self.find_next():
                                self.edit.text.replace(self.find_text, self.replace_text)
                        self.edit.view.set_refresh_all()

        def find_next(self, keys=None):
                &#34;&#34;&#34; Find next text &#34;&#34;&#34;
                result = False
                if self.find_text:
                        result = self.edit.text.find_next(self.find_text)
                return result

        def find_previous(self, keys=None):
                &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
                result = False
                if self.find_text:
                        result = self.edit.text.find_previous(self.find_text)
                return result

        def goto(self, keys=None):
                &#34;&#34;&#34; Goto line &#34;&#34;&#34;
                lineNumber = self.input(&#34;Goto line :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;)])
                try:
                        lineNumber = int(lineNumber)
                        self.edit.text.goto(int(lineNumber))
                except:
                        pass
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def group_key(self):
                &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
                result = [self.keys.pop(0)]
                while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                        if self.keys[0] == result[0]:
                                result.append(self.keys.pop(0))
                        else:
                                if tools.strings.isascii(result[0]) and tools.strings.isascii(self.keys[0]):
                                        result.append(self.keys.pop(0))
                                else:
                                        break
                return result

        def get_key(self, duration=tools.terminal.MAXINT):
                &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
                if len(self.keys) == 0:
                        while True:
                                try:
                                        key = tools.terminal.getch(duration=duration)
                                except KeyboardInterrupt:
                                        key = &#34;\x03&#34;

                                self.keys.append(key)
                                if tools.terminal.kbhit() is False or len(self.keys) &gt; 5:
                                        break
                return self.group_key()

        def execute(self, keys=None):
                &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
                self.save()
                loop = True
                while loop:
                        self.edit.view.reset_scroll_region()
                        self.edit.view.cls()
                        self.edit.view.flush()
                        startTime = tools.strings.ticks()
                        try:
                                error_line = tools.useful.run(self.displayed_filename)
                        except KeyboardInterrupt:
                                error_line = None

                        if error_line is not None:
                                self.edit.text.goto(error_line)

                        endTime = tools.strings.ticks()
                        print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                        while 1:
                                keys = self.get_key()
                                if keys[0] in self.cfg.key_new_line:
                                        loop = False
                                        break
                                elif keys[0] in self.cfg.key_execute:
                                        break
                                # else:
                                        # print(tools.strings.dump(keys[0]))
                self.edit.view.cls()
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def run(self):
                &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
                try:
                        self.edit.view.cls()
                        self.edit.view.get_screen_size()
                        self.loop = True
                        self.EDIT_KEYS = self.cfg.key_toggle_mode+self.cfg.key_find+self.cfg.key_replace+self.cfg.key_find_previous+self.cfg.key_find_next+self.cfg.key_exit+self.cfg.key_goto+self.cfg.key_save+self.cfg.key_execute
                        while(self.loop):
                                try:
                                        self.refresh()
                                        keys = self.get_key(duration=0.4)
                                        if len(keys[0]) == 0:
                                                self.is_refresh_header = True
                                                self.refresh_header()
                                                keys = self.get_key()

                                        if keys == [&#34;\x1B[23~&#34;]:
                                                keys = [&#34;\x1B[15;5x&#34;]
                                        if keys == [&#34;\x1B[24~&#34;]:
                                                keys = [&#34;\x1B[20;5y&#34;]

                                        if self.trace is not None:
                                                for key in keys:
                                                        self.trace.write(tools.strings.dump(key, withColor=False) + &#34;\n&#34;)
                                                        self.trace.flush()
                                        modified = self.edit.text.modified
                                        self.precedent_callback = self.key_callback
                                        self.key_callback = None

                                        if ord(keys[0][0]) &lt; 0x20:
                                                if keys[0] in self.EDIT_KEYS:
                                                        if   keys[0] in self.cfg.key_toggle_mode:    self.key_callback = self.toggle_mode
                                                        elif keys[0] in self.cfg.key_find:           self.key_callback = self.find
                                                        elif keys[0] in self.cfg.key_replace:        self.key_callback = self.replace
                                                        elif keys[0] in self.cfg.key_find_previous:  self.key_callback = self.find_previous
                                                        elif keys[0] in self.cfg.key_find_next:      self.key_callback = self.find_next
                                                        elif keys[0] in self.cfg.key_exit:           self.key_callback = self.exit
                                                        elif keys[0] in self.cfg.key_goto:           self.key_callback = self.goto
                                                        elif keys[0] in self.cfg.key_save:           self.key_callback = self.save
                                                        elif keys[0] in self.cfg.key_execute:        self.key_callback = self.execute

                                        # If a replacement is in progress and new line pressed
                                        if keys[0] in self.cfg.key_new_line:
                                                if self.precedent_callback is not None:
                                                        # The next check is compatible with micropython
                                                        if self.precedent_callback.__name__ in [self.find_next.__name__, self.find_previous.__name__, self.replace.__name__, self.replace_current.__name__]:
                                                                if self.replace_text is not None:
                                                                        # Replace current found
                                                                        self.key_callback = self.replace_current
                                        # If a replacement is in progress and select all pressed
                                        if keys[0] in self.cfg.key_sel_all:
                                                if self.precedent_callback is not None:
                                                        # The next check is compatible with micropython
                                                        if self.precedent_callback.__name__ in [self.find_next.__name__, self.find_previous.__name__, self.replace.__name__, self.replace_current.__name__]:
                                                                if self.replace_text is not None:
                                                                        # Replace all
                                                                        self.key_callback = self.replace_all

                                        if self.key_callback is not None:
                                                self.key_callback(keys)
                                        else:
                                                self.edit.text.treat_key(keys)
                                        if modified != self.edit.text.modified:
                                                self.is_refresh_header = True
                                except KeyboardInterrupt:
                                        pass
                        self.edit.view.reset_scroll_region()
                        self.edit.view.reset()
                except Exception as err:
                        print(tools.logger.exception(err))
                        filename = self.edit.text.getFilename() + &#34;_backup&#34;
                        self.save(filename=filename)
                        print(&#34;After the crash, a copy of the file was saved in &#39;%s&#39;&#34;%filename)

def main():
        &#34;&#34;&#34; Main function &#34;&#34;&#34;
        if len(sys.argv) &gt; 1:
                filename = sys.argv[1]
        else:
                filename = &#34;newfile.py&#34;
        edit = Editor(filename, read_only=False)

if __name__ == &#34;__main__&#34;:
        main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lib.shell.editor.is_enough_memory"><code class="name flex">
<span>def <span class="ident">is_enough_memory</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicate if it has enough memory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_enough_memory():
        &#34;&#34;&#34; Indicate if it has enough memory &#34;&#34;&#34;
        import gc
        try:
                # pylint: disable=no-member
                memory  = gc.mem_free()
        except:
                memory  = 256*1024
        if memory &lt; 50*1024:
                return False
        return True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
        &#34;&#34;&#34; Main function &#34;&#34;&#34;
        if len(sys.argv) &gt; 1:
                filename = sys.argv[1]
        else:
                filename = &#34;newfile.py&#34;
        edit = Editor(filename, read_only=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.shell.editor.Edit"><code class="flex name class">
<span>class <span class="ident">Edit</span></span>
<span>(</span><span>cfg, view_top=1, view_height=None, read_only=False, extension=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which aggregate the View and Text </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edit:
        &#34;&#34;&#34; Class which aggregate the View and Text &#34;&#34;&#34;
        def __init__(self, cfg, view_top=1, view_height=None, read_only=False, extension=None):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.view = View(cfg, view_height, view_top, extension=extension)
                self.text = Text(cfg, read_only)
                self.text.set_view(self.view)
                self.view.set_text(self.text)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor"><code class="flex name class">
<span>class <span class="ident">Editor</span></span>
<span>(</span><span>filename, no_color=False, read_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage a complete editor </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Editor:
        &#34;&#34;&#34; Class which manage a complete editor &#34;&#34;&#34;
        def __init__(self, filename, no_color=False, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.cfg = EditorConfig()
                if self.cfg.load(tobytes=False, errorlog=False) is False:
                        self.cfg.save()

                self.displayed_filename = tools.filesystem.split(filename)[1]
                if no_color:
                        extension = &#34;&#34;
                else:
                        extension = tools.filesystem.splitext(filename)[1]
                self.edit = Edit(self.cfg, read_only=read_only, extension=extension)
                self.edit.text.load(filename)
                self.is_refresh_header = True
                self.find_text = None
                self.replace_text = None
                self.keys= []
                self.loop = None
                self.key_callback = None
                self.precedent_callback = None
                self.trace = None
                if tools.filesystem.ismicropython() is False:
                        if filename == &#34;newfile.py&#34;:
                                self.trace = open(self.cfg.config_root() + &#34;/key.txt&#34;,&#34;w&#34;)

                if (not tools.filesystem.exists(filename) and read_only is True) or tools.filesystem.isdir(filename):
                        print(&#34;Cannot open &#39;%s&#39;&#34;%self.displayed_filename)
                else:
                        try:
                                self.run()
                        except Exception as err:
                                self.edit.view.cls()
                                tools.logger.syslog(err)
                                print(&#34;Failed edit &#39;%s&#39;&#34;%self.displayed_filename)

        def refresh_header(self):
                &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
                if self.is_refresh_header:
                        self.edit.view.move_cursor(0, 0)
                        filename = &#34;\u25C1 File: %s&#34;%(self.displayed_filename)
                        if self.edit.text.read_only is False:
                                filename += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                                end = &#34; Mode: %s &#34;%(&#34;Replace&#34; if self.edit.text.replace_mode else &#34;Insert&#34;)
                        else:
                                end = &#34; Read only &#34; if self.edit.text.read_only else &#34;&#34;
                        end = &#34;L%d C%d &#34;%(self.edit.text.cursor_line+1, self.edit.view.tab_cursor_column+1) + end + &#34;\u25B7&#34;

                        header = &#34;\x1B[7m%s%s%s\x1B[m&#34;%(filename, &#34; &#34;*(self.edit.view.width - len(filename) - len(end)), end)
                        self.edit.view.write(header)
                        self.edit.view.move_cursor()
                        self.is_refresh_header = False

        def refresh(self):
                &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
                self.refresh_header()
                self.edit.view.refresh()

        def toggle_mode(self, keys=None):
                &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
                if self.edit.text.replace_mode:
                        self.edit.text.replace_mode = False
                else:
                        self.edit.text.replace_mode = True
                self.is_refresh_header = True

        def save(self, keys=None, filename=None):
                &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
                self.edit.text.save(filename)
                self.is_refresh_header = True

        def exit(self, keys=None):
                &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
                self.edit.view.cls()
                if self.edit.text.modified:
                        self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.displayed_filename)
                        self.edit.view.flush()
                        while 1:
                                key = tools.terminal.getch()
                                if key == &#34;Y&#34; or key == &#34;y&#34;:
                                        if self.edit.text.save():
                                                self.edit.view.write(&#34;Saved\n&#34;)
                                                self.edit.view.flush()
                                        else:
                                                self.edit.view.write(&#34;Failed to save\n&#34;)
                                                self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == &#34;N&#34; or key == &#34;n&#34;:
                                        self.edit.view.write(&#34;Not saved\n&#34;)
                                        self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == &#34;\x1B&#34;:
                                        self.edit.view.set_refresh_all()
                                        self.is_refresh_header = True
                                        break
                else:
                        self.loop = False

        def input(self, text, help_=None):
                &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
                edit_ = Edit(cfg=self.cfg, view_top=4, view_height=1, read_only=False)
                edit_.view.cls()
                edit_.view.move_cursor(3,0)
                edit_.view.write(text)
                edit_.view.move_cursor(1,0)
                if help_ is not None:
                        for item in help_:
                                key, text = item
                                edit_.view.write(&#34;\x1B[7m%s\x1B[m:%s \t&#34;%(key, text))
                result = None
                while 1:
                        edit_.view.refresh()
                        key = self.get_key()
                        if key[0] in self.cfg.key_new_line:
                                result = edit_.text.lines[0]
                                break
                        elif key[0] in &#34;\x1B&#34;:
                                break
                        else:
                                edit_.text.treat_key(key)
                return result

        def find(self, keys=None):
                &#34;&#34;&#34; Find a text &#34;&#34;&#34;
                self.find_text = self.input(&#34;Find :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;),(&#34;Shift-F3 or Ctrl-P&#34;,&#34;Previous&#34;),(&#34;F3 or Ctrl-N&#34;,&#34;Next&#34;)])
                self.find_next()
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True
                self.replace_text = None

        def replace(self, keys=None):
                &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
                self.find_text    = self.input(&#34;Find to replace :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;)])
                if self.find_text:
                        self.replace_text = self.input(&#34;Replace with :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;),(&#34;Shift-F3 or Ctrl-P&#34;,&#34;Previous&#34;),(&#34;F3 or Ctrl-N&#34;,&#34;Next&#34;),(&#34;Enter&#34;,&#34;Replace current&#34;)])
                        self.find_next()

                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def replace_current(self, keys=None):
                &#34;&#34;&#34; Replace current &#34;&#34;&#34;
                if self.find_text and self.replace_text:
                        if self.edit.text.replace(self.find_text, self.replace_text):
                                self.find_next()

        def replace_all(self, keys=None):
                &#34;&#34;&#34; Replace replace all &#34;&#34;&#34;
                if self.find_text and self.replace_text:
                        self.edit.text.top()
                        while self.find_next():
                                self.edit.text.replace(self.find_text, self.replace_text)
                        self.edit.view.set_refresh_all()

        def find_next(self, keys=None):
                &#34;&#34;&#34; Find next text &#34;&#34;&#34;
                result = False
                if self.find_text:
                        result = self.edit.text.find_next(self.find_text)
                return result

        def find_previous(self, keys=None):
                &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
                result = False
                if self.find_text:
                        result = self.edit.text.find_previous(self.find_text)
                return result

        def goto(self, keys=None):
                &#34;&#34;&#34; Goto line &#34;&#34;&#34;
                lineNumber = self.input(&#34;Goto line :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;)])
                try:
                        lineNumber = int(lineNumber)
                        self.edit.text.goto(int(lineNumber))
                except:
                        pass
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def group_key(self):
                &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
                result = [self.keys.pop(0)]
                while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                        if self.keys[0] == result[0]:
                                result.append(self.keys.pop(0))
                        else:
                                if tools.strings.isascii(result[0]) and tools.strings.isascii(self.keys[0]):
                                        result.append(self.keys.pop(0))
                                else:
                                        break
                return result

        def get_key(self, duration=tools.terminal.MAXINT):
                &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
                if len(self.keys) == 0:
                        while True:
                                try:
                                        key = tools.terminal.getch(duration=duration)
                                except KeyboardInterrupt:
                                        key = &#34;\x03&#34;

                                self.keys.append(key)
                                if tools.terminal.kbhit() is False or len(self.keys) &gt; 5:
                                        break
                return self.group_key()

        def execute(self, keys=None):
                &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
                self.save()
                loop = True
                while loop:
                        self.edit.view.reset_scroll_region()
                        self.edit.view.cls()
                        self.edit.view.flush()
                        startTime = tools.strings.ticks()
                        try:
                                error_line = tools.useful.run(self.displayed_filename)
                        except KeyboardInterrupt:
                                error_line = None

                        if error_line is not None:
                                self.edit.text.goto(error_line)

                        endTime = tools.strings.ticks()
                        print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                        while 1:
                                keys = self.get_key()
                                if keys[0] in self.cfg.key_new_line:
                                        loop = False
                                        break
                                elif keys[0] in self.cfg.key_execute:
                                        break
                                # else:
                                        # print(tools.strings.dump(keys[0]))
                self.edit.view.cls()
                self.edit.view.set_refresh_all()
                self.is_refresh_header = True

        def run(self):
                &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
                try:
                        self.edit.view.cls()
                        self.edit.view.get_screen_size()
                        self.loop = True
                        self.EDIT_KEYS = self.cfg.key_toggle_mode+self.cfg.key_find+self.cfg.key_replace+self.cfg.key_find_previous+self.cfg.key_find_next+self.cfg.key_exit+self.cfg.key_goto+self.cfg.key_save+self.cfg.key_execute
                        while(self.loop):
                                try:
                                        self.refresh()
                                        keys = self.get_key(duration=0.4)
                                        if len(keys[0]) == 0:
                                                self.is_refresh_header = True
                                                self.refresh_header()
                                                keys = self.get_key()

                                        if keys == [&#34;\x1B[23~&#34;]:
                                                keys = [&#34;\x1B[15;5x&#34;]
                                        if keys == [&#34;\x1B[24~&#34;]:
                                                keys = [&#34;\x1B[20;5y&#34;]

                                        if self.trace is not None:
                                                for key in keys:
                                                        self.trace.write(tools.strings.dump(key, withColor=False) + &#34;\n&#34;)
                                                        self.trace.flush()
                                        modified = self.edit.text.modified
                                        self.precedent_callback = self.key_callback
                                        self.key_callback = None

                                        if ord(keys[0][0]) &lt; 0x20:
                                                if keys[0] in self.EDIT_KEYS:
                                                        if   keys[0] in self.cfg.key_toggle_mode:    self.key_callback = self.toggle_mode
                                                        elif keys[0] in self.cfg.key_find:           self.key_callback = self.find
                                                        elif keys[0] in self.cfg.key_replace:        self.key_callback = self.replace
                                                        elif keys[0] in self.cfg.key_find_previous:  self.key_callback = self.find_previous
                                                        elif keys[0] in self.cfg.key_find_next:      self.key_callback = self.find_next
                                                        elif keys[0] in self.cfg.key_exit:           self.key_callback = self.exit
                                                        elif keys[0] in self.cfg.key_goto:           self.key_callback = self.goto
                                                        elif keys[0] in self.cfg.key_save:           self.key_callback = self.save
                                                        elif keys[0] in self.cfg.key_execute:        self.key_callback = self.execute

                                        # If a replacement is in progress and new line pressed
                                        if keys[0] in self.cfg.key_new_line:
                                                if self.precedent_callback is not None:
                                                        # The next check is compatible with micropython
                                                        if self.precedent_callback.__name__ in [self.find_next.__name__, self.find_previous.__name__, self.replace.__name__, self.replace_current.__name__]:
                                                                if self.replace_text is not None:
                                                                        # Replace current found
                                                                        self.key_callback = self.replace_current
                                        # If a replacement is in progress and select all pressed
                                        if keys[0] in self.cfg.key_sel_all:
                                                if self.precedent_callback is not None:
                                                        # The next check is compatible with micropython
                                                        if self.precedent_callback.__name__ in [self.find_next.__name__, self.find_previous.__name__, self.replace.__name__, self.replace_current.__name__]:
                                                                if self.replace_text is not None:
                                                                        # Replace all
                                                                        self.key_callback = self.replace_all

                                        if self.key_callback is not None:
                                                self.key_callback(keys)
                                        else:
                                                self.edit.text.treat_key(keys)
                                        if modified != self.edit.text.modified:
                                                self.is_refresh_header = True
                                except KeyboardInterrupt:
                                        pass
                        self.edit.view.reset_scroll_region()
                        self.edit.view.reset()
                except Exception as err:
                        print(tools.logger.exception(err))
                        filename = self.edit.text.getFilename() + &#34;_backup&#34;
                        self.save(filename=filename)
                        print(&#34;After the crash, a copy of the file was saved in &#39;%s&#39;&#34;%filename)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.Editor.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the python script edited</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, keys=None):
        &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
        self.save()
        loop = True
        while loop:
                self.edit.view.reset_scroll_region()
                self.edit.view.cls()
                self.edit.view.flush()
                startTime = tools.strings.ticks()
                try:
                        error_line = tools.useful.run(self.displayed_filename)
                except KeyboardInterrupt:
                        error_line = None

                if error_line is not None:
                        self.edit.text.goto(error_line)

                endTime = tools.strings.ticks()
                print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                while 1:
                        keys = self.get_key()
                        if keys[0] in self.cfg.key_new_line:
                                loop = False
                                break
                        elif keys[0] in self.cfg.key_execute:
                                break
                        # else:
                                # print(tools.strings.dump(keys[0]))
        self.edit.view.cls()
        self.edit.view.set_refresh_all()
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit from editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit(self, keys=None):
        &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
        self.edit.view.cls()
        if self.edit.text.modified:
                self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.displayed_filename)
                self.edit.view.flush()
                while 1:
                        key = tools.terminal.getch()
                        if key == &#34;Y&#34; or key == &#34;y&#34;:
                                if self.edit.text.save():
                                        self.edit.view.write(&#34;Saved\n&#34;)
                                        self.edit.view.flush()
                                else:
                                        self.edit.view.write(&#34;Failed to save\n&#34;)
                                        self.edit.view.flush()
                                self.loop = False
                                break
                        elif key == &#34;N&#34; or key == &#34;n&#34;:
                                self.edit.view.write(&#34;Not saved\n&#34;)
                                self.edit.view.flush()
                                self.loop = False
                                break
                        elif key == &#34;\x1B&#34;:
                                self.edit.view.set_refresh_all()
                                self.is_refresh_header = True
                                break
        else:
                self.loop = False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find a text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, keys=None):
        &#34;&#34;&#34; Find a text &#34;&#34;&#34;
        self.find_text = self.input(&#34;Find :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;),(&#34;Shift-F3 or Ctrl-P&#34;,&#34;Previous&#34;),(&#34;F3 or Ctrl-N&#34;,&#34;Next&#34;)])
        self.find_next()
        self.edit.view.set_refresh_all()
        self.is_refresh_header = True
        self.replace_text = None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.find_next"><code class="name flex">
<span>def <span class="ident">find_next</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find next text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_next(self, keys=None):
        &#34;&#34;&#34; Find next text &#34;&#34;&#34;
        result = False
        if self.find_text:
                result = self.edit.text.find_next(self.find_text)
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.find_previous"><code class="name flex">
<span>def <span class="ident">find_previous</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Find previous text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_previous(self, keys=None):
        &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
        result = False
        if self.find_text:
                result = self.edit.text.find_previous(self.find_text)
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.get_key"><code class="name flex">
<span>def <span class="ident">get_key</span></span>(<span>self, duration=100000000)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a key pressed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_key(self, duration=tools.terminal.MAXINT):
        &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
        if len(self.keys) == 0:
                while True:
                        try:
                                key = tools.terminal.getch(duration=duration)
                        except KeyboardInterrupt:
                                key = &#34;\x03&#34;

                        self.keys.append(key)
                        if tools.terminal.kbhit() is False or len(self.keys) &gt; 5:
                                break
        return self.group_key()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Goto line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self, keys=None):
        &#34;&#34;&#34; Goto line &#34;&#34;&#34;
        lineNumber = self.input(&#34;Goto line :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;)])
        try:
                lineNumber = int(lineNumber)
                self.edit.text.goto(int(lineNumber))
        except:
                pass
        self.edit.view.set_refresh_all()
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.group_key"><code class="name flex">
<span>def <span class="ident">group_key</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Group similar key to optimize move of cursor and edition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_key(self):
        &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
        result = [self.keys.pop(0)]
        while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                if self.keys[0] == result[0]:
                        result.append(self.keys.pop(0))
                else:
                        if tools.strings.isascii(result[0]) and tools.strings.isascii(self.keys[0]):
                                result.append(self.keys.pop(0))
                        else:
                                break
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.input"><code class="name flex">
<span>def <span class="ident">input</span></span>(<span>self, text, help_=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Input value, used to get a line number, or text searched</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input(self, text, help_=None):
        &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
        edit_ = Edit(cfg=self.cfg, view_top=4, view_height=1, read_only=False)
        edit_.view.cls()
        edit_.view.move_cursor(3,0)
        edit_.view.write(text)
        edit_.view.move_cursor(1,0)
        if help_ is not None:
                for item in help_:
                        key, text = item
                        edit_.view.write(&#34;\x1B[7m%s\x1B[m:%s \t&#34;%(key, text))
        result = None
        while 1:
                edit_.view.refresh()
                key = self.get_key()
                if key[0] in self.cfg.key_new_line:
                        result = edit_.text.lines[0]
                        break
                elif key[0] in &#34;\x1B&#34;:
                        break
                else:
                        edit_.text.treat_key(key)
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
        &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
        self.refresh_header()
        self.edit.view.refresh()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.refresh_header"><code class="name flex">
<span>def <span class="ident">refresh_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the header of editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_header(self):
        &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
        if self.is_refresh_header:
                self.edit.view.move_cursor(0, 0)
                filename = &#34;\u25C1 File: %s&#34;%(self.displayed_filename)
                if self.edit.text.read_only is False:
                        filename += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                        end = &#34; Mode: %s &#34;%(&#34;Replace&#34; if self.edit.text.replace_mode else &#34;Insert&#34;)
                else:
                        end = &#34; Read only &#34; if self.edit.text.read_only else &#34;&#34;
                end = &#34;L%d C%d &#34;%(self.edit.text.cursor_line+1, self.edit.view.tab_cursor_column+1) + end + &#34;\u25B7&#34;

                header = &#34;\x1B[7m%s%s%s\x1B[m&#34;%(filename, &#34; &#34;*(self.edit.view.width - len(filename) - len(end)), end)
                self.edit.view.write(header)
                self.edit.view.move_cursor()
                self.is_refresh_header = False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace a text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, keys=None):
        &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
        self.find_text    = self.input(&#34;Find to replace :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;)])
        if self.find_text:
                self.replace_text = self.input(&#34;Replace with :&#34;,[(&#34;Esc&#34;,&#34;Abort&#34;),(&#34;Shift-F3 or Ctrl-P&#34;,&#34;Previous&#34;),(&#34;F3 or Ctrl-N&#34;,&#34;Next&#34;),(&#34;Enter&#34;,&#34;Replace current&#34;)])
                self.find_next()

        self.edit.view.set_refresh_all()
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.replace_all"><code class="name flex">
<span>def <span class="ident">replace_all</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace replace all</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_all(self, keys=None):
        &#34;&#34;&#34; Replace replace all &#34;&#34;&#34;
        if self.find_text and self.replace_text:
                self.edit.text.top()
                while self.find_next():
                        self.edit.text.replace(self.find_text, self.replace_text)
                self.edit.view.set_refresh_all()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.replace_current"><code class="name flex">
<span>def <span class="ident">replace_current</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace current</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_current(self, keys=None):
        &#34;&#34;&#34; Replace current &#34;&#34;&#34;
        if self.find_text and self.replace_text:
                if self.edit.text.replace(self.find_text, self.replace_text):
                        self.find_next()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Core of the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
        &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
        try:
                self.edit.view.cls()
                self.edit.view.get_screen_size()
                self.loop = True
                self.EDIT_KEYS = self.cfg.key_toggle_mode+self.cfg.key_find+self.cfg.key_replace+self.cfg.key_find_previous+self.cfg.key_find_next+self.cfg.key_exit+self.cfg.key_goto+self.cfg.key_save+self.cfg.key_execute
                while(self.loop):
                        try:
                                self.refresh()
                                keys = self.get_key(duration=0.4)
                                if len(keys[0]) == 0:
                                        self.is_refresh_header = True
                                        self.refresh_header()
                                        keys = self.get_key()

                                if keys == [&#34;\x1B[23~&#34;]:
                                        keys = [&#34;\x1B[15;5x&#34;]
                                if keys == [&#34;\x1B[24~&#34;]:
                                        keys = [&#34;\x1B[20;5y&#34;]

                                if self.trace is not None:
                                        for key in keys:
                                                self.trace.write(tools.strings.dump(key, withColor=False) + &#34;\n&#34;)
                                                self.trace.flush()
                                modified = self.edit.text.modified
                                self.precedent_callback = self.key_callback
                                self.key_callback = None

                                if ord(keys[0][0]) &lt; 0x20:
                                        if keys[0] in self.EDIT_KEYS:
                                                if   keys[0] in self.cfg.key_toggle_mode:    self.key_callback = self.toggle_mode
                                                elif keys[0] in self.cfg.key_find:           self.key_callback = self.find
                                                elif keys[0] in self.cfg.key_replace:        self.key_callback = self.replace
                                                elif keys[0] in self.cfg.key_find_previous:  self.key_callback = self.find_previous
                                                elif keys[0] in self.cfg.key_find_next:      self.key_callback = self.find_next
                                                elif keys[0] in self.cfg.key_exit:           self.key_callback = self.exit
                                                elif keys[0] in self.cfg.key_goto:           self.key_callback = self.goto
                                                elif keys[0] in self.cfg.key_save:           self.key_callback = self.save
                                                elif keys[0] in self.cfg.key_execute:        self.key_callback = self.execute

                                # If a replacement is in progress and new line pressed
                                if keys[0] in self.cfg.key_new_line:
                                        if self.precedent_callback is not None:
                                                # The next check is compatible with micropython
                                                if self.precedent_callback.__name__ in [self.find_next.__name__, self.find_previous.__name__, self.replace.__name__, self.replace_current.__name__]:
                                                        if self.replace_text is not None:
                                                                # Replace current found
                                                                self.key_callback = self.replace_current
                                # If a replacement is in progress and select all pressed
                                if keys[0] in self.cfg.key_sel_all:
                                        if self.precedent_callback is not None:
                                                # The next check is compatible with micropython
                                                if self.precedent_callback.__name__ in [self.find_next.__name__, self.find_previous.__name__, self.replace.__name__, self.replace_current.__name__]:
                                                        if self.replace_text is not None:
                                                                # Replace all
                                                                self.key_callback = self.replace_all

                                if self.key_callback is not None:
                                        self.key_callback(keys)
                                else:
                                        self.edit.text.treat_key(keys)
                                if modified != self.edit.text.modified:
                                        self.is_refresh_header = True
                        except KeyboardInterrupt:
                                pass
                self.edit.view.reset_scroll_region()
                self.edit.view.reset()
        except Exception as err:
                print(tools.logger.exception(err))
                filename = self.edit.text.getFilename() + &#34;_backup&#34;
                self.save(filename=filename)
                print(&#34;After the crash, a copy of the file was saved in &#39;%s&#39;&#34;%filename)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, keys=None, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the file edited</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, keys=None, filename=None):
        &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
        self.edit.text.save(filename)
        self.is_refresh_header = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.toggle_mode"><code class="name flex">
<span>def <span class="ident">toggle_mode</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the replace mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_mode(self, keys=None):
        &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
        if self.edit.text.replace_mode:
                self.edit.text.replace_mode = False
        else:
                self.edit.text.replace_mode = True
        self.is_refresh_header = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.shell.editor.EditorConfig"><code class="flex name class">
<span>class <span class="ident">EditorConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Editor configuration for shortcuts and tab size</p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EditorConfig(tools.jsonconfig.JsonConfig):
        &#34;&#34;&#34; Editor configuration for shortcuts and tab size&#34;&#34;&#34;
        def __init__(self):
                tools.jsonconfig.JsonConfig.__init__(self)
                self.tabsize              = 4    # Tabulation size

                # For the same action several shortcuts can be used
                # Move shortcuts
                self.key_up               = [&#34;\x1b[A&#34;]
                self.key_down             = [&#34;\x1b[B&#34;]
                self.key_right            = [&#34;\x1b[C&#34;]
                self.key_left             = [&#34;\x1b[D&#34;]
                self.key_home             = [&#34;\x1b[1;3D&#34;, &#34;\x1b[H&#34;, &#34;\x1b\x1b[D&#34;, &#34;\x1b[1~&#34;, &#34;\x1bb&#34;]
                self.key_end              = [&#34;\x1b[1;3C&#34;, &#34;\x1b[F&#34;, &#34;\x1b\x1b[C&#34;, &#34;\x1b[4~&#34;, &#34;\x1bf&#34;]
                self.key_page_up          = [&#34;\x1b[1;3A&#34;, &#34;\x1b[A&#34;, &#34;\x1b\x1b[A&#34;, &#34;\x1b[5~&#34;]
                self.key_page_down        = [&#34;\x1b[1;3B&#34;, &#34;\x1b[B&#34;, &#34;\x1b\x1b[B&#34;, &#34;\x1b[6~&#34;]
                self.key_top              = [&#34;\x1b[1;5H&#34;]
                self.key_bottom           = [&#34;\x1b[1;5F&#34;]
                self.key_next_word        = [&#34;\x1b[1;5C&#34;]
                self.key_previous_word    = [&#34;\x1b[1;5D&#34;]

                # selection shortcuts
                self.key_sel_up           = [&#34;\x1b[1;2A&#34;]
                self.key_sel_down         = [&#34;\x1b[1;2B&#34;]
                self.key_sel_right        = [&#34;\x1b[1;2C&#34;]
                self.key_sel_left         = [&#34;\x1b[1;2D&#34;]
                self.key_sel_page_up      = [&#34;\x1b[1;10A&#34;,&#34;\x1b[1;4A&#34;,&#34;\x1b[5;2~&#34;]
                self.key_sel_page_down    = [&#34;\x1b[1;10B&#34;,&#34;\x1b[1;4B&#34;,&#34;\x1b[6;2~&#34;]
                self.key_sel_home         = [&#34;\x1b[1;2H&#34;,&#34;\x1b[1;10D&#34;]
                self.key_sel_end          = [&#34;\x1b[1;2F&#34;,&#34;\x1b[1;10C&#34;]
                self.key_sel_top          = [&#34;\x1b[1;6H&#34;]
                self.key_sel_bottom       = [&#34;\x1b[1;6F&#34;]
                self.key_sel_next_word    = [&#34;\x1b[1;6C&#34;,&#34;\x1b[1;4C&#34;]
                self.key_sel_prev_word    = [&#34;\x1b[1;6D&#34;,&#34;\x1b[1;4D&#34;]

                self.key_sel_all          = [&#34;\x01&#34;]                              # Select All
                # ctrl-b unused
                self.key_copy             = [&#34;\x03&#34;,&#34;\x1bc&#34;]                      # Copy
                # ctrl-d unused
                self.key_execute          = [&#34;\x05&#34;, &#34;\x1b[15~&#34;]                  # Execute script
                self.key_find             = [&#34;\x06&#34;, &#34;\x1BOQ&#34;]                    # Find
                self.key_goto             = [&#34;\x07&#34;]                              # Goto line
                self.key_backspace        = [&#34;\x08&#34;,&#34;\x7F&#34;]                       # Backspace
                self.key_indent           = [&#34;\x09&#34;]                              # Indent
                # line feed reserved
                # ctrl-k unused
                self.key_del_line         = [&#34;\x0C&#34;]                              # Delete line
                self.key_new_line         = [&#34;\x0D&#34;, &#34;\0x0A&#34;]                     # New line pressed
                self.key_find_next        = [&#34;\x0E&#34;, &#34;\x1bOR&#34;]                    # Find next
                # ctrl-o unused
                self.key_find_previous    = [&#34;\x10&#34;, &#34;\x1b[1;2R&#34;]                 # Find previous
                self.key_comment          = [&#34;\x11&#34;]                              # Comment block
                self.key_replace          = [&#34;\x12&#34;]                              # Replace
                self.key_save             = [&#34;\x13&#34;, &#34;\x1bs&#34;]                     # Save
                self.key_toggle_mode      = [&#34;\x14&#34;]                              # Toggle replace/insert mode
                self.key_change_case      = [&#34;\x15&#34;]                              # Change case
                self.key_paste            = [&#34;\x16&#34;,&#34;\x1bv&#34;]                      # Paste
                # ctrl-w unused
                self.key_cut              = [&#34;\x18&#34;,&#34;\x1bx&#34;]                      # Cut
                # ctrl-y unused
                # ctrl-z unused

                self.key_exit             = [&#34;\x1b&#34;]                              # Exit

                self.key_delete           = [&#34;\x1b[3~&#34;]                           # Delete pressed
                self.key_unindent         = [&#34;\x1b[Z&#34;]                            # Unindent</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tools.jsonconfig.JsonConfig</li>
</ul>
</dd>
<dt id="lib.shell.editor.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
<span>(</span><span>cfg, read_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage the text edition </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Text:
        &#34;&#34;&#34; Class which manage the text edition &#34;&#34;&#34;
        def __init__(self, cfg, read_only=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.lines = [&#34;&#34;]
                self.cursor_line   = 0
                self.cursor_column = 0
                self.tab_cursor_column   = 0
                self.modified     = False
                self.replace_mode  = False
                self.read_only     = read_only
                self.cfg = cfg
                self.view         = None
                self.tab_size      = self.cfg.tabsize
                self.selection_start = None
                self.selection_end   = None
                self.selection = []
                self.filename = None
                self.MOVE_KEYS = self.cfg.key_up+self.cfg.key_down+self.cfg.key_left+self.cfg.key_right+self.cfg.key_home+self.cfg.key_end+self.cfg.key_page_up+self.cfg.key_page_down+self.cfg.key_top+self.cfg.key_bottom+self.cfg.key_next_word+self.cfg.key_previous_word
                self.SELECT_KEYS = self.cfg.key_sel_up+self.cfg.key_sel_down+self.cfg.key_sel_right+self.cfg.key_sel_left+self.cfg.key_sel_home+self.cfg.key_sel_end+self.cfg.key_sel_top+self.cfg.key_sel_bottom+self.cfg.key_sel_page_up+self.cfg.key_sel_page_down+self.cfg.key_sel_all+self.cfg.key_sel_next_word+self.cfg.key_sel_prev_word
                self.NOT_READ_ONLY_KEYS = self.cfg.key_copy+self.cfg.key_cut+self.cfg.key_paste+self.cfg.key_indent+self.cfg.key_unindent+self.cfg.key_change_case+self.cfg.key_comment+self.cfg.key_backspace+self.cfg.key_delete+self.cfg.key_new_line+self.cfg.key_del_line
                self.begin_line = 1
                self.begin_column = 1

        def set_view(self, view):
                &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
                self.view = view

        def get_count_lines(self):
                &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
                return len(self.lines)

        def get_cursor_line(self):
                &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
                return self.cursor_line

        def get_tab_cursor(self, current_line, current_column=None):
                &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
                if current_column is None:
                        cursor_column = self.cursor_column
                else:
                        cursor_column = current_column
                line = self.lines[current_line]
                if &#34;\t&#34; in line:
                        tab_cursor_column   = 0
                        column = 0
                        len_line = len(line)
                        while column &lt; cursor_column:
                                if line[column] == &#34;\t&#34;:
                                        pos = tab_cursor_column%self.tab_size
                                        tab_cursor_column += self.tab_size-pos
                                        column          += 1
                                else:
                                        tab = line.find(&#34;\t&#34;,column)
                                        if tab &gt; 0:
                                                partSize = tab - column
                                        else:
                                                partSize = len_line - column
                                        if column + partSize &gt; cursor_column:
                                                partSize = cursor_column - column
                                        tab_cursor_column += partSize
                                        column          += partSize
                        return tab_cursor_column
                else:
                        return cursor_column

        def get_tab_line(self, current_line, start_column, end_column, binary = True):
                &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
                accent = False
                line = self.lines[current_line]
                if &#34;\t&#34; in line:
                        tab_line = b&#34;&#34;
                        cursor   = 0
                        len_line = len(line)
                        column = 0
                        while column &lt; len_line:
                                char = line[column]
                                if char == &#34;\t&#34;:
                                        pos = cursor%self.tab_size
                                        cursor += self.tab_size-pos
                                        tab_line          += b&#34; &#34;*(self.tab_size-pos)
                                        column            += 1
                                else:
                                        tab = line.find(&#34;\t&#34;,column)
                                        if tab &lt; 0:
                                                tab = len_line
                                        part = line[column:tab]
                                        cursor += len(part)
                                        bin_part = part.encode(&#34;utf8&#34;)
                                        tab_line          += bin_part
                                        column            += len(part)
                                        if len(part) != len(bin_part):
                                                accent = True

                        tab_line = tab_line.replace(b&#34;\n&#34;,b&#34;&#34;)
                        if binary is False:
                                tab_line = tab_line.decode(&#34;utf8&#34;)
                else:
                        if binary:
                                tab_line = line.encode(&#34;utf8&#34;)
                                if len(line) != len(tab_line):
                                        accent = True
                                tab_line = tab_line.replace(b&#34;\n&#34;,b&#34;&#34;)
                        else:
                                tab_line = line
                                tab_line = tab_line.replace(&#34;\n&#34;,&#34;&#34;)

                if binary and accent:
                        result = tab_line.decode(&#34;utf8&#34;)[start_column:end_column].encode(&#34;utf8&#34;)
                else:
                        result = tab_line[start_column:end_column]

                return result

        def get_tab_cursor_column(self):
                &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
                line = self.lines[self.cursor_line]
                column = 0
                self.tab_cursor_column = 0
                while column &lt; self.cursor_column:
                        if line[column] == &#34;\t&#34;:
                                pos = self.tab_cursor_column%self.tab_size
                                self.tab_cursor_column += self.tab_size-pos
                                column += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        delta = tab - column
                                        if column + delta &gt; self.cursor_column:
                                                delta = self.cursor_column - column
                                                self.tab_cursor_column += delta
                                                column += delta
                                        else:
                                                self.tab_cursor_column += delta
                                                column += delta
                                else:
                                        delta = self.cursor_column - column
                                        self.tab_cursor_column += delta
                                        column += delta

        def set_cursor_column(self):
                &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
                line = self.lines[self.cursor_line]
                column = 0
                tab_cursor_column = 0
                len_line = len(line)
                column = 0
                while column &lt; len_line:
                        char = line[column]
                        # If the previous position found exactly in the current line
                        if tab_cursor_column == self.tab_cursor_column:
                                self.cursor_column = column
                                break
                        # If the previous position not found in the current line
                        if tab_cursor_column &gt; self.tab_cursor_column:
                                # Keep last existing position
                                self.cursor_column = column
                                break
                        # If tabulation found
                        if char == &#34;\t&#34;:
                                tab_cursor_column += self.tab_size-(tab_cursor_column%self.tab_size)
                                column += 1
                        else:
                                # Optimization to accelerate the cursor position
                                tab = line.find(&#34;\t&#34;, column)

                                # Tabulation found
                                if tab &gt; 0:
                                        delta = tab - column
                                        # If the tabulation position is after the previous tabulation cursor
                                        if delta + tab_cursor_column &gt; self.tab_cursor_column:
                                                # Move the cursor to the left
                                                self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                                break
                                        else:
                                                # Another tabulation found, move it after
                                                tab_cursor_column += delta
                                                column += delta
                                # Tabulation not found
                                else:
                                        # Move the cursor to the end of line
                                        self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                        break
                else:
                        if len(line) &gt;= 1:
                                self.cursor_column = len(line)-1
                        else:
                                self.cursor_column = 0

        def getFilename(self):
                &#34;&#34;&#34; Return the filename &#34;&#34;&#34;
                return self.filename

        def load(self, filename):
                &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
                self.filename = None
                try:
                        self.lines = []
                        self.filename = filename
                        file = open(filename, &#34;r&#34;)
                        line = file.readline()
                        while line != &#34;&#34;:
                                self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                                line = file.readline()
                        file.close()
                        if len(self.lines) == 0:
                                self.lines = [&#34;&#34;]
                except MemoryError:
                        # pylint: disable=raise-missing-from
                        raise MemoryError()
                except OSError:
                        self.lines = [&#34;&#34;]
                        # File not existing
                except Exception as err:
                        tools.logger.syslog(err)
                        self.lines = [&#34;&#34;]

        def save(self, filename=None):
                &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
                result = False
                if self.read_only is False:
                        if filename is None:
                                filename = self.filename
                        if filename is not None:
                                try:
                                        file = open(filename, &#34;w&#34;)
                                        for line in self.lines:
                                                file.write(line)
                                        file.close()
                                        self.modified = False
                                        result = True
                                except Exception as err:
                                        tools.logger.syslog(err)
                return result

        def change_line(self, moveLine):
                &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
                # If cursor is before the first line
                if moveLine + self.cursor_line &lt; 0:
                        # Set the cursor to the first line
                        self.cursor_line = 0
                        self.cursor_column = 0
                        self.change_column(0)
                # If the cursor is after the last line
                elif moveLine + self.cursor_line &gt;= len(self.lines):
                        self.cursor_line = len(self.lines) -1
                        self.cursor_column = len(self.lines[self.cursor_line])
                        self.change_column(0)
                # else the cursor is in the lines of text
                else:
                        self.cursor_line += moveLine
                        if len(self.lines) - 1 == self.cursor_line:
                                len_line = len(self.lines[self.cursor_line])
                        else:
                                len_line = len(self.lines[self.cursor_line])-1

                        self.set_cursor_column()
                        # If the new cursor position is outside the line of text
                        if self.cursor_column &gt; len_line:
                                self.change_column(tools.terminal.MAXINT)

                if self.selection_start is not None:
                        self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]
                self.view.move()

        def change_column(self, move_column, with_move_view=True):
                &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
                cursor_line   = self.cursor_line
                cursor_column = self.cursor_column
                # If the cursor go to the previous line
                if move_column + self.cursor_column &lt; 0:
                        # If start of line
                        if abs(move_column) &gt; 1:
                                self.cursor_column = 0
                        # If move to the left and must go to previous line
                        elif self.cursor_line &gt; 0:
                                self.cursor_line -= 1
                                self.cursor_column = len(self.lines[self.cursor_line])-1
                # If the cursor is at the end of line
                elif move_column + self.cursor_column &gt; len(self.lines[self.cursor_line])-1:
                        # If the cursor is on the last line of file
                        if abs(move_column) &gt; 1 or self.cursor_line+1 == len(self.lines):
                                # If the file is empty
                                if self.lines[self.cursor_line] == &#34;&#34;:
                                        self.cursor_column = 0
                                        self.tab_cursor_column = 0
                                # If the last line of contains return char
                                elif self.lines[self.cursor_line][-1] == &#34;\n&#34;:
                                        # Move cursor before return
                                        self.cursor_column = len(self.lines[self.cursor_line])-1
                                else:
                                        # Move cursor after the last char
                                        self.cursor_column = len(self.lines[self.cursor_line])

                        # If the cursor is on the end of line and must change of line
                        elif self.cursor_line+1 &lt; len(self.lines):
                                self.cursor_line += 1
                                self.cursor_column = 0
                                self.tab_cursor_column = 0
                # Normal move of cursor
                else:
                        # Next or previous column
                        self.cursor_column += move_column
                if abs(move_column) &gt; 0:
                        self.get_tab_cursor_column()
                self.close_selection()
                if with_move_view:
                        self.view.move()
                if self.cursor_column == cursor_column and self.cursor_line == cursor_line:
                        return False
                else:
                        return True

        def backspace(self, keys=None):
                &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        # The cursor not in the begining of line
                        if self.cursor_column &gt;= 1:
                                line = self.lines[self.cursor_line]
                                line = line[0:self.cursor_column-1:]+ line[self.cursor_column  : :]
                                self.lines[self.cursor_line] = line
                                self.change_column(-1)
                                self.view.set_refresh_line()
                        # The cursor is on the begining of line
                        else:
                                # If the cursor not on the first line
                                if self.cursor_line &gt;= 1:
                                        # Copy the current line to the end of previous line
                                        self.cursor_column = len(self.lines[self.cursor_line-1])
                                        self.lines[self.cursor_line-1] = self.lines[self.cursor_line-1][:-1] + self.lines[self.cursor_line]
                                        del self.lines[self.cursor_line]
                                        self.view.scroll_part_up()
                                        self.cursor_line -= 1
                                        self.view.set_refresh_after()
                                        self.change_column(-1)

        def delete(self, keys=None):
                &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
                self.modified = True
                if self.remove_selection() is False:
                        line = self.lines[self.cursor_line]
                        if self.cursor_column &lt; len(line):
                                # If the line is empty
                                if line[self.cursor_column] == &#34;\n&#34;:
                                        # If the cursor not at end of files
                                        if self.cursor_line &lt; len(self.lines)-1:
                                                # Copy the next line to the current line
                                                self.lines[self.cursor_line] = line[:self.cursor_column] + self.lines[self.cursor_line+1]
                                                del self.lines[self.cursor_line+1]
                                                self.view.scroll_part_up()
                                                self.view.set_refresh_after()
                                # Else the char is deleted in the middle of line
                                else:
                                        line = line[0:self.cursor_column:]+ line[self.cursor_column+1  : :]
                                        self.lines[self.cursor_line] = line
                                        self.change_column(0)
                                        self.view.is_refresh_line = True

        def delete_line(self, keys=None):
                &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
                self.hide_selection()
                self.modified = True
                # If file contains one or none line
                if len(self.lines) &lt;= 1:
                        # Clean the content of file
                        self.lines = [&#34;&#34;]
                        self.cursor_column = 0
                        self.cursor_line = 0
                        self.change_column(0)
                # If the current line is not the last of file
                elif self.cursor_line &lt; len(self.lines):
                        # Delete the line
                        self.cursor_column = 0
                        del self.lines[self.cursor_line]
                        self.view.scroll_part_up()
                        if self.cursor_line &gt;= len(self.lines):
                                self.cursor_line = len(self.lines)-1
                        self.change_column(0)
                self.view.set_refresh_after()

        def new_line(self, keys=None):
                &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
                self.modified = True
                self.remove_selection()
                line1 = self.lines[self.cursor_line][:self.cursor_column]+&#34;\n&#34;
                line2 = self.lines[self.cursor_line][self.cursor_column:]
                self.lines[self.cursor_line]=line1
                self.lines.insert(self.cursor_line+1, line2)
                self.view.scroll_part_down()
                self.change_column(1)
                self.view.set_refresh_before()

        def insert_char(self, char):
                &#34;&#34;&#34; Insert character &#34;&#34;&#34;
                self.modified = True
                self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column:]
                self.change_column(len(char))
                self.view.set_refresh_line()

        def replace_char(self, char):
                &#34;&#34;&#34; Replace character &#34;&#34;&#34;
                self.modified = True
                if self.cursor_line == len(self.lines)-1 and self.cursor_column &gt;= len(self.lines[self.cursor_line])-1:
                        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char
                        self.change_column(1)
                        self.view.set_refresh_line()
                # If it is the last char in the line
                elif self.lines[self.cursor_line][self.cursor_column] == &#34;\n&#34;:
                        # Append char to the line
                        self.insert_char(char)
                # Else the char must be replaced in the line
                else:
                        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column+1:]
                        self.change_column(1)
                        self.view.set_refresh_line()

        def open_selection(self):
                &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
                if self.selection_start is None:
                        self.selection_start = [self.cursor_column, self.cursor_line, self.get_tab_cursor(self.cursor_line, self.cursor_column)]

        def close_selection(self):
                &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
                if self.selection_start is not None:
                        self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]

        def select_all(self, keys=None):
                &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
                self.selection_start = [0,0,0]
                lastLine = len(self.lines)-1
                lastColumn = len(self.lines[lastLine])
                self.move_cursor(lastLine, lastColumn)
                self.selection_end  = [lastColumn, lastLine, self.get_tab_cursor(lastLine, lastColumn)]
                self.view.set_refresh_all()

        def get_selection(self):
                &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
                if self.selection_start is not None and self.selection_end is not None:
                        if self.selection_start[1] &gt; self.selection_end[1]:
                                return self.selection_end, self.selection_start
                        elif self.selection_start[1] &lt; self.selection_end[1]:
                                return self.selection_start, self.selection_end
                        elif self.selection_start[0] &lt; self.selection_end[0]:
                                return self.selection_start, self.selection_end
                        else:
                                return self.selection_end, self.selection_start
                else:
                        return None, None

        def arrow_up(self, keys=None):
                &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line(-1)

        def arrow_down(self, keys=None):
                &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line(1)

        def arrow_left(self, keys=None):
                &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(-len(keys))

        def arrow_right(self, keys=None):
                &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(len(keys))

        def select_up(self, keys=None):
                &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
                self.open_selection()
                self.change_line(-1)

        def select_down(self, keys=None):
                &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
                self.open_selection()
                self.change_line(1)

        def select_left(self, keys=None):
                &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(-len(keys))

        def select_right(self, keys=None):
                &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(len(keys))

        def select_home(self, keys=None):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(-tools.terminal.MAXINT)

        def select_end(self, keys=None):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.open_selection()
                self.change_column(tools.terminal.MAXINT)

        def select_page_up(self, keys=None):
                &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
                self.open_selection()
                self.change_line((-(self.view.height)) * len(keys))
                self.change_column(-tools.terminal.MAXINT)

        def select_page_down(self, keys=None):
                &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
                self.open_selection()
                self.change_line((self.view.height) * len(keys))
                self.change_column(tools.terminal.MAXINT)

        def select_next_word(self, keys=None):
                &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
                self.open_selection()
                self.move_word(1)

        def select_previous_word(self, keys=None):
                &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
                self.open_selection()
                self.move_word(-1)

        def select_top(self, keys=None):
                &#34;&#34;&#34; Manage select to the first line of text &#34;&#34;&#34;
                self.open_selection()
                self.change_line(-tools.terminal.MAXINT)

        def select_bottom(self, keys=None):
                &#34;&#34;&#34; Manage select to the last line of text &#34;&#34;&#34;
                self.open_selection()
                self.change_line(tools.terminal.MAXINT)

        def page_up(self, keys=None):
                &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line((-(self.view.height)) * len(keys))

        def page_down(self, keys=None):
                &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
                self.hide_selection()
                self.change_line((self.view.height) * len(keys))

        def home(self, keys=None):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(-tools.terminal.MAXINT)

        def end(self, keys=None):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.hide_selection()
                self.change_column(tools.terminal.MAXINT)

        def add_char(self, keys=None):
                &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
                result = False

                if tools.strings.isascii(keys[0]):
                        self.remove_selection()
                        for char in keys:
                                if tools.strings.isascii(char):
                                        if self.replace_mode:
                                                self.replace_char(char)
                                        else:
                                                self.insert_char(char)
                                        result = True
                # if result is False:
                        # print(tools.strings.dump(keys[0]))
                return result

        def find_next(self, text):
                &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
                result = False
                # Get the selection
                selection_start, selection_end = self.get_selection()

                # Hide the selection
                self.hide_selection()

                # Set the start of search at the cursor position
                current_line   = self.cursor_line
                current_column = self.cursor_column

                # If selection activated
                if selection_start is not None and selection_end is not None:
                        # If selection is on one line
                        if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                                # If selection is exactly the size of text
                                if selection_start[0] == current_column:
                                        # Move the start of search after the text selected
                                        current_column = selection_end[0]

                # Find the text in next lines
                while current_line &lt; len(self.lines):
                        # Search text
                        pos = self.lines[current_line].find(text, current_column)

                        # If text found
                        if pos &gt;= 0:
                                # Move the cursor to the text found
                                self.cursor_line = current_line
                                self.cursor_column = pos + len(text)
                                self.change_column(0)
                                self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                                self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                                result = True
                                break
                        else:
                                # Set the search position at the begin of next line
                                current_column = 0
                                current_line += 1
                self.view.move()
                return result

        def find_previous(self, text):
                &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
                result = False
                # Get the selection
                selection_start, selection_end = self.get_selection()

                # Hide the selection
                self.hide_selection()

                # Set the start of search at the cursor position
                current_line   = self.cursor_line
                current_column = self.cursor_column

                # If selection activated
                if selection_start is not None and selection_end is not None:
                        # If selection is on one line
                        if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                                # If selection is exactly the size of text
                                if selection_end[0] - selection_start[0] == len(text):
                                        # Move the start of search before the text selected
                                        current_column = selection_start[0]

                # While the line before the first line not reached
                while current_line &gt;= 0:
                        # Get the current line
                        line = self.lines[current_line]

                        # If the current column is negative
                        if current_column &lt; 0:
                                # Set the end of line
                                current_column = len(line)

                        # Search the text in reverse
                        pos = line.rfind(text, 0, current_column)

                        # If text found
                        if pos &gt;= 0:
                                self.cursor_line = current_line
                                self.cursor_column = pos
                                self.change_column(0)
                                self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                                self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                                result = True
                                break
                        else:
                                # Set the search position at the end of line
                                current_column = -1
                                current_line -= 1
                self.view.move()
                return result

        def hide_selection(self):
                &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
                self.view.hide_selection()
                self.selection_start = self.selection_end = None

        def goto(self, line, column=None, clear_selection=True):
                &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
                if clear_selection:
                        self.hide_selection()
                if line &lt; 0:
                        self.cursor_line = len(self.lines)-1
                elif line &lt; 1:
                        self.cursor_line = 1
                elif line &lt;= len(self.lines):
                        self.cursor_line = line - 1
                else:
                        self.cursor_line = len(self.lines)-1
                        if column is not None:
                                column = tools.terminal.MAXINT
                self.cursor_column = 0

                if column is not None:
                        if column &gt; 1:
                                cur_line = self.cursor_line
                                self.change_column(0, with_move_view=False)
                                for i in range(len(self.lines[self.cursor_line]) + 1):
                                        self.change_column(1, with_move_view=False)
                                        if self.tab_cursor_column &gt;= column-1:
                                                break

                                        if self.cursor_line != cur_line:
                                                self.change_column(-1, with_move_view=False)
                                                break

                self.view.move()

        def copy_clipboard(self):
                &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
                result = []
                if self.selection_start is not None:
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end
                        result = []
                        if sel_line_start == sel_line_end:
                                result.append(self.lines[sel_line_start][sel_column_start:sel_column_end])
                        else:
                                for line in range(sel_line_start, sel_line_end+1):
                                        if line == sel_line_start:
                                                part = self.lines[line][sel_column_start:]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][sel_column_start:])
                                        elif line == sel_line_end:
                                                part = self.lines[line][:sel_column_end]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][:sel_column_end])
                                        else:
                                                result.append(self.lines[line])
                return result

        def remove_selection(self):
                &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
                if self.selection_start is not None:
                        self.modified = True
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, _ = selection_start
                        sel_column_end,   sel_line_end,   _ = selection_end
                        start = self.lines[sel_line_start][:sel_column_start]
                        end   = self.lines[sel_line_end  ][sel_column_end:]
                        self.lines[sel_line_start] = start + end
                        if sel_line_start &lt; sel_line_end:
                                for line in range(sel_line_end, sel_line_start,-1):
                                        del self.lines[line]
                        self.move_cursor(sel_line_start, sel_column_start)
                        self.hide_selection()
                        if sel_line_end == sel_line_start:
                                self.view.set_refresh_line()
                        else:
                                self.view.set_refresh_bottom(sel_line_start)
                        return True
                return False

        def paste_clipboard(self, selection):
                &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
                if selection != [] and selection != [&#34;&#34;]:
                        start_line = self.cursor_line
                        # Split the line with insertion
                        start = self.lines[self.cursor_line][:self.cursor_column]
                        end   = self.lines[self.cursor_line][self.cursor_column:]

                        # Paste the first line
                        self.lines[self.cursor_line] = start + selection[0]

                        self.cursor_line += 1

                        # Insert all lines from clipboard
                        for line in selection[1:-1]:
                                self.lines.insert(self.cursor_line, line)
                                self.cursor_line += 1

                        # If the last line of clipboard is not empty
                        if len(selection[-1]) &gt;= 1:
                                # If the last line of clipboard contains carriage return at the end
                                if selection[-1][-1] == &#34;\n&#34;:
                                        if len(selection) &gt; 1:
                                                # Add the new line
                                                self.lines.insert(self.cursor_line, selection[-1])
                                                self.cursor_line += 1

                                        # Add the part after the insertion
                                        self.lines.insert(self.cursor_line, end)
                                        self.cursor_column = 0
                                        if len(selection) &gt;= self.view.height:
                                                self.view.set_refresh_all()
                                        else:
                                                self.view.set_refresh_bottom(start_line)
                                else:
                                        # If many lines with last line without carriage return at the end
                                        if len(selection) &gt; 1:
                                                self.lines.insert(self.cursor_line, selection[-1] + end)
                                                self.cursor_column = len(selection[-1])
                                                if len(selection) &gt;= self.view.height:
                                                        self.view.set_refresh_all()
                                                else:
                                                        self.view.set_refresh_bottom(start_line)
                                        else:
                                                # Only one line without carriage return
                                                self.cursor_line -= 1
                                                self.lines[self.cursor_line] += end
                                                self.cursor_column = len(start) + len(selection[-1])
                                                self.view.set_refresh_line()
                        self.move_cursor(self.cursor_line, self.cursor_column)

        def move_cursor(self, line, column):
                &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
                self.cursor_line   = line
                self.cursor_column = column
                self.change_column(0)
                self.get_tab_cursor_column()

        def copy(self, keys=None):
                &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
                self.selection = self.copy_clipboard()

        def cut(self, keys=None):
                &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
                self.modified = True
                self.selection = self.copy_clipboard()
                self.remove_selection()

        def paste(self, keys=None):
                &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
                self.modified = True
                self.remove_selection()
                self.paste_clipboard(self.selection)
                self.hide_selection()

        def change_case(self, keys=None):
                &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
                selection = self.copy_clipboard()
                if len(selection) &gt; 0:
                        self.modified = True
                        selection_start = self.selection_start
                        selection_end   = self.selection_end

                        self.remove_selection()
                        isUpper = None
                        for line in selection:
                                for char in line:
                                        if tools.strings.isupper(char):
                                                isUpper = True
                                                break
                                        elif tools.strings.islower(char):
                                                isUpper = False
                                                break
                                if isUpper is not None:
                                        break
                        # pylint:disable=consider-using-enumerate
                        for line in range(len(selection)):
                                if isUpper:
                                        selection[line] = selection[line].lower()
                                else:
                                        selection[line] = selection[line].upper()
                        self.paste_clipboard(selection)
                        self.view.set_refresh_selection()
                        self.selection_start = selection_start
                        self.selection_end   = selection_end

        def comment(self, keys=None):
                &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
                self.modified = True

                # If selection
                if self.selection_start is not None:
                        selection_start, selection_end = self.get_selection()
                        _, sel_line_start, _ = selection_start
                        _, sel_line_end,   _ = selection_end

                        # Add tabulation
                        for line in range(sel_line_start, sel_line_end+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] != &#39;#&#39;:
                                                self.lines[line] = &#34;#&#34; + self.lines[line]
                                        else:
                                                if len(self.lines[line]) &gt;= 1:
                                                        self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selection_start = [0,sel_line_start, 0]

                        # Get the length of last selected line
                        len_line_end =  len(self.lines[sel_line_end])

                        # Move the end of selection at the end of line selected
                        self.selection_end   = [len_line_end-1, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end-1)]
                        self.view.set_refresh_selection()
                else:
                        if len(self.lines[self.cursor_line]) &gt;= 1:
                                # If nothing selected
                                if self.lines[self.cursor_line][0] == &#34;#&#34;:
                                        self.lines[self.cursor_line] = self.lines[self.cursor_line][1:]
                                        if self.cursor_column &gt; 0:
                                                self.change_column(-1)
                                else:
                                        self.lines[self.cursor_line] = &#34;#&#34; + self.lines[self.cursor_line]
                                        self.change_column(1)
                        self.view.set_refresh_line()

        def indent(self, keys=None):
                &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
                # If nothing selected
                if self.selection_start is None:
                        self.add_char(keys)
                else:
                        self.modified = True
                        # Indent selection
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end

                        # If a part of line selected
                        if sel_line_start == sel_line_end and not (sel_column_start == 0 and sel_column_end == len(self.lines[sel_line_end])-1):
                                self.add_char(self.cfg.key_indent)
                        else:
                                # If the last line selected is at beginning of line
                                if sel_column_end == 0:
                                        # This line must not be indented
                                        sel_line_end -= 1

                                # Add tabulation
                                for line in range(sel_line_start, sel_line_end+1):
                                        self.lines[line] = &#34;\t&#34; + self.lines[line]

                                # Move the start selection to the start of first selected line
                                self.selection_start = [0,sel_line_start, 0]

                                # If the last line selected is not at beginning of line
                                if sel_column_end &gt; 0:
                                        # Get the length of last selected line
                                        len_line_end =  len(self.lines[sel_line_end])

                                        # If the end of selection is not on the last line
                                        if sel_line_end &lt; len(self.lines)-1:
                                                len_line_end -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selection_end  = [0, sel_line_end+1, 0]
                        self.view.set_refresh_selection()

        def unindent(self, keys=None):
                &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
                # If nothing selected
                if self.selection_start is None:
                        self.backspace()
                else:
                        self.modified = True

                        # Unindent selection
                        selection_start, selection_end = self.get_selection()
                        sel_column_start, sel_line_start, dummy = selection_start
                        sel_column_end,   sel_line_end,   dummy = selection_end

                        # If the selection is only alone line
                        if sel_line_start == sel_line_end:
                                self.hide_selection()
                        else:
                                # If the last line selected is at beginning of line
                                if sel_column_end == 0:
                                        # This line must not be indented
                                        sel_line_end -= 1

                                # Remove indentation
                                for line in range(sel_line_start, sel_line_end+1):
                                        if len(self.lines[line]) &gt;= 1:
                                                if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                        self.lines[line] = self.lines[line][1:]

                                # Move the start selection to the start of first selected line
                                self.selection_start = [0,sel_line_start, 0]

                                # If the last line selected is not at beginning of line
                                if sel_column_end &gt; 0:
                                        # Get the length of last selected line
                                        len_line_end =  len(self.lines[sel_line_end])

                                        # If the end of selection is not on the last line
                                        if sel_line_end &lt; len(self.lines)-1:
                                                len_line_end -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selection_end  = [0, sel_line_end+1, 0]
                        self.view.set_refresh_selection()

        def replace(self, old, new):
                &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
                if self.read_only is False:
                        selection = self.copy_clipboard()
                        if len(selection) == 1:
                                if selection[0] == old:
                                        self.delete()
                                        self.insert_char(new)
                                        return True
                return False

        def get_cursor_char(self):
                &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
                try:
                        return self.lines[self.cursor_line][self.cursor_column]
                except:
                        return None

        def move_word(self, direction):
                &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
                state = 0
                while self.change_column(direction):
                        current_char = self.get_cursor_char()
                        if current_char is None:
                                break
                        elif tools.strings.ispunctuation(current_char):
                                if state == 0:
                                        state = 2
                                elif state == 1:
                                        break
                        elif tools.strings.isalpha(current_char):
                                if state == 0:
                                        state = 1
                                elif state == 2:
                                        break
                        elif tools.strings.isspace(current_char):
                                if state == 1:
                                        break
                                if state == 2:
                                        break

        def next_word(self, keys=None):
                &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
                self.hide_selection()
                self.move_word(1)
                self.view.move()

        def previous_word(self, keys=None):
                &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
                self.hide_selection()
                self.move_word(-1)
                self.view.move()

        def top(self, keys=None):
                &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
                self.goto(1)

        def bottom(self, keys=None):
                &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
                self.goto(tools.terminal.MAXINT)

        def treat_char(self, keys=None):
                &#34;&#34;&#34; Treat character entered &#34;&#34;&#34;
                char = ord(keys[0][0])
                if self.read_only is False:
                        if char &gt;= 0x20 and char != 0x7F:
                                self.add_char(keys)
                                return True
                return False

        def treat_key(self, keys=None):
                &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
                key_callback = None
                if self.treat_char(keys) is False:
                        # Move in the edit field
                        if keys[0] in self.MOVE_KEYS:
                                if   keys[0] in self.cfg.key_left:            key_callback = self.arrow_left
                                elif keys[0] in self.cfg.key_right:           key_callback = self.arrow_right
                                elif keys[0] in self.cfg.key_up  :            key_callback = self.arrow_up
                                elif keys[0] in self.cfg.key_down:            key_callback = self.arrow_down
                                elif keys[0] in self.cfg.key_home:            key_callback = self.home
                                elif keys[0] in self.cfg.key_end:             key_callback = self.end
                                elif keys[0] in self.cfg.key_page_up:         key_callback = self.page_up
                                elif keys[0] in self.cfg.key_page_down:       key_callback = self.page_down
                                elif keys[0] in self.cfg.key_top:             key_callback = self.top
                                elif keys[0] in self.cfg.key_bottom:          key_callback = self.bottom
                                elif keys[0] in self.cfg.key_next_word:       key_callback = self.next_word
                                elif keys[0] in self.cfg.key_previous_word:   key_callback = self.previous_word
                        elif keys[0] in self.SELECT_KEYS:
                                # Selection the edit field
                                if   keys[0] in self.cfg.key_sel_right:    key_callback = self.select_right
                                elif keys[0] in self.cfg.key_sel_left:     key_callback = self.select_left
                                elif keys[0] in self.cfg.key_sel_up:       key_callback = self.select_up
                                elif keys[0] in self.cfg.key_sel_down:     key_callback = self.select_down
                                elif keys[0] in self.cfg.key_sel_home:     key_callback = self.select_home
                                elif keys[0] in self.cfg.key_sel_end:      key_callback = self.select_end
                                elif keys[0] in self.cfg.key_sel_top:      key_callback = self.select_top
                                elif keys[0] in self.cfg.key_sel_bottom:   key_callback = self.select_bottom
                                elif keys[0] in self.cfg.key_sel_page_up:  key_callback = self.select_page_up
                                elif keys[0] in self.cfg.key_sel_page_down:key_callback = self.select_page_down
                                elif keys[0] in self.cfg.key_sel_all:      key_callback = self.select_all
                                elif keys[0] in self.cfg.key_sel_next_word:key_callback = self.select_next_word
                                elif keys[0] in self.cfg.key_sel_prev_word:key_callback = self.select_previous_word

                        # If the edit is not in read only
                        elif self.read_only is False:
                                if keys[0] in self.NOT_READ_ONLY_KEYS:
                                        # Modification in the edit field
                                        if   keys[0] in self.cfg.key_copy:        key_callback = self.copy
                                        elif keys[0] in self.cfg.key_cut:         key_callback = self.cut
                                        elif keys[0] in self.cfg.key_paste:       key_callback = self.paste
                                        elif keys[0] in self.cfg.key_indent:      key_callback = self.indent
                                        elif keys[0] in self.cfg.key_unindent:    key_callback = self.unindent
                                        elif keys[0] in self.cfg.key_change_case: key_callback = self.change_case
                                        elif keys[0] in self.cfg.key_comment:     key_callback = self.comment
                                        elif keys[0] in self.cfg.key_backspace:   key_callback = self.backspace
                                        elif keys[0] in self.cfg.key_delete:      key_callback = self.delete
                                        elif keys[0] in self.cfg.key_new_line:    key_callback = self.new_line
                                        elif keys[0] in self.cfg.key_del_line:    key_callback = self.delete_line
                        # else: self.add_char(keys)
                        if key_callback is not None:
                                key_callback(keys)
                        else:
                                if len(keys[0]) &gt; 3:
                                        # If camflasher mouse selection
                                        if keys[0][0:2] == &#34;\x1B[&#34; and keys[0][-1] in [&#34;x&#34;,&#34;y&#34;]:
                                                try:
                                                        pos = keys[0][2:-1]
                                                        line, column = pos.split(&#34;;&#34;)
                                                        self.begin_line, self.begin_column = self.view.get_position()
                                                        if keys[0][-1] == &#34;x&#34;:
                                                                self.goto(int(line)+self.begin_line,int(column)+self.begin_column, True)
                                                                self.open_selection()
                                                                self.close_selection()
                                                        else:
                                                                self.goto(int(line)+self.begin_line,int(column)+self.begin_column, False)
                                                                self.close_selection()
                                                except Exception as err:
                                                        pass</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.Text.add_char"><code class="name flex">
<span>def <span class="ident">add_char</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage other key, add character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_char(self, keys=None):
        &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
        result = False

        if tools.strings.isascii(keys[0]):
                self.remove_selection()
                for char in keys:
                        if tools.strings.isascii(char):
                                if self.replace_mode:
                                        self.replace_char(char)
                                else:
                                        self.insert_char(char)
                                result = True
        # if result is False:
                # print(tools.strings.dump(keys[0]))
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrow_down"><code class="name flex">
<span>def <span class="ident">arrow_down</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow_down(self, keys=None):
        &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
        self.hide_selection()
        self.change_line(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrow_left"><code class="name flex">
<span>def <span class="ident">arrow_left</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow left key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow_left(self, keys=None):
        &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
        self.hide_selection()
        self.change_column(-len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrow_right"><code class="name flex">
<span>def <span class="ident">arrow_right</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow right key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow_right(self, keys=None):
        &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
        self.hide_selection()
        self.change_column(len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrow_up"><code class="name flex">
<span>def <span class="ident">arrow_up</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrow_up(self, keys=None):
        &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
        self.hide_selection()
        self.change_line(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.backspace"><code class="name flex">
<span>def <span class="ident">backspace</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the backspace key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backspace(self, keys=None):
        &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
        self.modified = True
        if self.remove_selection() is False:
                # The cursor not in the begining of line
                if self.cursor_column &gt;= 1:
                        line = self.lines[self.cursor_line]
                        line = line[0:self.cursor_column-1:]+ line[self.cursor_column  : :]
                        self.lines[self.cursor_line] = line
                        self.change_column(-1)
                        self.view.set_refresh_line()
                # The cursor is on the begining of line
                else:
                        # If the cursor not on the first line
                        if self.cursor_line &gt;= 1:
                                # Copy the current line to the end of previous line
                                self.cursor_column = len(self.lines[self.cursor_line-1])
                                self.lines[self.cursor_line-1] = self.lines[self.cursor_line-1][:-1] + self.lines[self.cursor_line]
                                del self.lines[self.cursor_line]
                                self.view.scroll_part_up()
                                self.cursor_line -= 1
                                self.view.set_refresh_after()
                                self.change_column(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.bottom"><code class="name flex">
<span>def <span class="ident">bottom</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the last line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bottom(self, keys=None):
        &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
        self.goto(tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.change_case"><code class="name flex">
<span>def <span class="ident">change_case</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the case of selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_case(self, keys=None):
        &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
        selection = self.copy_clipboard()
        if len(selection) &gt; 0:
                self.modified = True
                selection_start = self.selection_start
                selection_end   = self.selection_end

                self.remove_selection()
                isUpper = None
                for line in selection:
                        for char in line:
                                if tools.strings.isupper(char):
                                        isUpper = True
                                        break
                                elif tools.strings.islower(char):
                                        isUpper = False
                                        break
                        if isUpper is not None:
                                break
                # pylint:disable=consider-using-enumerate
                for line in range(len(selection)):
                        if isUpper:
                                selection[line] = selection[line].lower()
                        else:
                                selection[line] = selection[line].upper()
                self.paste_clipboard(selection)
                self.view.set_refresh_selection()
                self.selection_start = selection_start
                self.selection_end   = selection_end</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.change_column"><code class="name flex">
<span>def <span class="ident">change_column</span></span>(<span>self, move_column, with_move_view=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor on another column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_column(self, move_column, with_move_view=True):
        &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
        cursor_line   = self.cursor_line
        cursor_column = self.cursor_column
        # If the cursor go to the previous line
        if move_column + self.cursor_column &lt; 0:
                # If start of line
                if abs(move_column) &gt; 1:
                        self.cursor_column = 0
                # If move to the left and must go to previous line
                elif self.cursor_line &gt; 0:
                        self.cursor_line -= 1
                        self.cursor_column = len(self.lines[self.cursor_line])-1
        # If the cursor is at the end of line
        elif move_column + self.cursor_column &gt; len(self.lines[self.cursor_line])-1:
                # If the cursor is on the last line of file
                if abs(move_column) &gt; 1 or self.cursor_line+1 == len(self.lines):
                        # If the file is empty
                        if self.lines[self.cursor_line] == &#34;&#34;:
                                self.cursor_column = 0
                                self.tab_cursor_column = 0
                        # If the last line of contains return char
                        elif self.lines[self.cursor_line][-1] == &#34;\n&#34;:
                                # Move cursor before return
                                self.cursor_column = len(self.lines[self.cursor_line])-1
                        else:
                                # Move cursor after the last char
                                self.cursor_column = len(self.lines[self.cursor_line])

                # If the cursor is on the end of line and must change of line
                elif self.cursor_line+1 &lt; len(self.lines):
                        self.cursor_line += 1
                        self.cursor_column = 0
                        self.tab_cursor_column = 0
        # Normal move of cursor
        else:
                # Next or previous column
                self.cursor_column += move_column
        if abs(move_column) &gt; 0:
                self.get_tab_cursor_column()
        self.close_selection()
        if with_move_view:
                self.view.move()
        if self.cursor_column == cursor_column and self.cursor_line == cursor_line:
                return False
        else:
                return True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.change_line"><code class="name flex">
<span>def <span class="ident">change_line</span></span>(<span>self, moveLine)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor on another line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_line(self, moveLine):
        &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
        # If cursor is before the first line
        if moveLine + self.cursor_line &lt; 0:
                # Set the cursor to the first line
                self.cursor_line = 0
                self.cursor_column = 0
                self.change_column(0)
        # If the cursor is after the last line
        elif moveLine + self.cursor_line &gt;= len(self.lines):
                self.cursor_line = len(self.lines) -1
                self.cursor_column = len(self.lines[self.cursor_line])
                self.change_column(0)
        # else the cursor is in the lines of text
        else:
                self.cursor_line += moveLine
                if len(self.lines) - 1 == self.cursor_line:
                        len_line = len(self.lines[self.cursor_line])
                else:
                        len_line = len(self.lines[self.cursor_line])-1

                self.set_cursor_column()
                # If the new cursor position is outside the line of text
                if self.cursor_column &gt; len_line:
                        self.change_column(tools.terminal.MAXINT)

        if self.selection_start is not None:
                self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.close_selection"><code class="name flex">
<span>def <span class="ident">close_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminate selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_selection(self):
        &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
        if self.selection_start is not None:
                self.selection_end = [self.cursor_column, self.cursor_line,self.get_tab_cursor(self.cursor_line)]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.comment"><code class="name flex">
<span>def <span class="ident">comment</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Comment the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comment(self, keys=None):
        &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
        self.modified = True

        # If selection
        if self.selection_start is not None:
                selection_start, selection_end = self.get_selection()
                _, sel_line_start, _ = selection_start
                _, sel_line_end,   _ = selection_end

                # Add tabulation
                for line in range(sel_line_start, sel_line_end+1):
                        if len(self.lines[line]) &gt;= 1:
                                if self.lines[line][0] != &#39;#&#39;:
                                        self.lines[line] = &#34;#&#34; + self.lines[line]
                                else:
                                        if len(self.lines[line]) &gt;= 1:
                                                self.lines[line] = self.lines[line][1:]

                # Move the start selection to the start of first selected line
                self.selection_start = [0,sel_line_start, 0]

                # Get the length of last selected line
                len_line_end =  len(self.lines[sel_line_end])

                # Move the end of selection at the end of line selected
                self.selection_end   = [len_line_end-1, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end-1)]
                self.view.set_refresh_selection()
        else:
                if len(self.lines[self.cursor_line]) &gt;= 1:
                        # If nothing selected
                        if self.lines[self.cursor_line][0] == &#34;#&#34;:
                                self.lines[self.cursor_line] = self.lines[self.cursor_line][1:]
                                if self.cursor_column &gt; 0:
                                        self.change_column(-1)
                        else:
                                self.lines[self.cursor_line] = &#34;#&#34; + self.lines[self.cursor_line]
                                self.change_column(1)
                self.view.set_refresh_line()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage copy key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, keys=None):
        &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
        self.selection = self.copy_clipboard()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.copy_clipboard"><code class="name flex">
<span>def <span class="ident">copy_clipboard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy selection to clipboard</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_clipboard(self):
        &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
        result = []
        if self.selection_start is not None:
                selection_start, selection_end = self.get_selection()
                sel_column_start, sel_line_start, dummy = selection_start
                sel_column_end,   sel_line_end,   dummy = selection_end
                result = []
                if sel_line_start == sel_line_end:
                        result.append(self.lines[sel_line_start][sel_column_start:sel_column_end])
                else:
                        for line in range(sel_line_start, sel_line_end+1):
                                if line == sel_line_start:
                                        part = self.lines[line][sel_column_start:]
                                        if part != &#34;&#34;:
                                                result.append(self.lines[line][sel_column_start:])
                                elif line == sel_line_end:
                                        part = self.lines[line][:sel_column_end]
                                        if part != &#34;&#34;:
                                                result.append(self.lines[line][:sel_column_end])
                                else:
                                        result.append(self.lines[line])
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.cut"><code class="name flex">
<span>def <span class="ident">cut</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage cut key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut(self, keys=None):
        &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
        self.modified = True
        self.selection = self.copy_clipboard()
        self.remove_selection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the delete key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, keys=None):
        &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
        self.modified = True
        if self.remove_selection() is False:
                line = self.lines[self.cursor_line]
                if self.cursor_column &lt; len(line):
                        # If the line is empty
                        if line[self.cursor_column] == &#34;\n&#34;:
                                # If the cursor not at end of files
                                if self.cursor_line &lt; len(self.lines)-1:
                                        # Copy the next line to the current line
                                        self.lines[self.cursor_line] = line[:self.cursor_column] + self.lines[self.cursor_line+1]
                                        del self.lines[self.cursor_line+1]
                                        self.view.scroll_part_up()
                                        self.view.set_refresh_after()
                        # Else the char is deleted in the middle of line
                        else:
                                line = line[0:self.cursor_column:]+ line[self.cursor_column+1  : :]
                                self.lines[self.cursor_line] = line
                                self.change_column(0)
                                self.view.is_refresh_line = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.delete_line"><code class="name flex">
<span>def <span class="ident">delete_line</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the delete of line key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_line(self, keys=None):
        &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
        self.hide_selection()
        self.modified = True
        # If file contains one or none line
        if len(self.lines) &lt;= 1:
                # Clean the content of file
                self.lines = [&#34;&#34;]
                self.cursor_column = 0
                self.cursor_line = 0
                self.change_column(0)
        # If the current line is not the last of file
        elif self.cursor_line &lt; len(self.lines):
                # Delete the line
                self.cursor_column = 0
                del self.lines[self.cursor_line]
                self.view.scroll_part_up()
                if self.cursor_line &gt;= len(self.lines):
                        self.cursor_line = len(self.lines)-1
                self.change_column(0)
        self.view.set_refresh_after()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage end key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self, keys=None):
        &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
        self.hide_selection()
        self.change_column(tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.find_next"><code class="name flex">
<span>def <span class="ident">find_next</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Find next researched text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_next(self, text):
        &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
        result = False
        # Get the selection
        selection_start, selection_end = self.get_selection()

        # Hide the selection
        self.hide_selection()

        # Set the start of search at the cursor position
        current_line   = self.cursor_line
        current_column = self.cursor_column

        # If selection activated
        if selection_start is not None and selection_end is not None:
                # If selection is on one line
                if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                        # If selection is exactly the size of text
                        if selection_start[0] == current_column:
                                # Move the start of search after the text selected
                                current_column = selection_end[0]

        # Find the text in next lines
        while current_line &lt; len(self.lines):
                # Search text
                pos = self.lines[current_line].find(text, current_column)

                # If text found
                if pos &gt;= 0:
                        # Move the cursor to the text found
                        self.cursor_line = current_line
                        self.cursor_column = pos + len(text)
                        self.change_column(0)
                        self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                        self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                        result = True
                        break
                else:
                        # Set the search position at the begin of next line
                        current_column = 0
                        current_line += 1
        self.view.move()
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.find_previous"><code class="name flex">
<span>def <span class="ident">find_previous</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Find previous researched text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_previous(self, text):
        &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
        result = False
        # Get the selection
        selection_start, selection_end = self.get_selection()

        # Hide the selection
        self.hide_selection()

        # Set the start of search at the cursor position
        current_line   = self.cursor_line
        current_column = self.cursor_column

        # If selection activated
        if selection_start is not None and selection_end is not None:
                # If selection is on one line
                if selection_start[1] == selection_end[1] and current_line == selection_start[1]:
                        # If selection is exactly the size of text
                        if selection_end[0] - selection_start[0] == len(text):
                                # Move the start of search before the text selected
                                current_column = selection_start[0]

        # While the line before the first line not reached
        while current_line &gt;= 0:
                # Get the current line
                line = self.lines[current_line]

                # If the current column is negative
                if current_column &lt; 0:
                        # Set the end of line
                        current_column = len(line)

                # Search the text in reverse
                pos = line.rfind(text, 0, current_column)

                # If text found
                if pos &gt;= 0:
                        self.cursor_line = current_line
                        self.cursor_column = pos
                        self.change_column(0)
                        self.selection_start = [pos, current_line,self.get_tab_cursor(current_line,pos)]
                        self.selection_end   = [pos + len(text), current_line, self.get_tab_cursor(current_line, pos + len(text))]
                        result = True
                        break
                else:
                        # Set the search position at the end of line
                        current_column = -1
                        current_line -= 1
        self.view.move()
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.getFilename"><code class="name flex">
<span>def <span class="ident">getFilename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFilename(self):
        &#34;&#34;&#34; Return the filename &#34;&#34;&#34;
        return self.filename</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_count_lines"><code class="name flex">
<span>def <span class="ident">get_count_lines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the total of lines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_count_lines(self):
        &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
        return len(self.lines)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_cursor_char"><code class="name flex">
<span>def <span class="ident">get_cursor_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the char on the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cursor_char(self):
        &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
        try:
                return self.lines[self.cursor_line][self.cursor_column]
        except:
                return None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_cursor_line"><code class="name flex">
<span>def <span class="ident">get_cursor_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current line of the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cursor_line(self):
        &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
        return self.cursor_line</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_selection"><code class="name flex">
<span>def <span class="ident">get_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get information about selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_selection(self):
        &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
        if self.selection_start is not None and self.selection_end is not None:
                if self.selection_start[1] &gt; self.selection_end[1]:
                        return self.selection_end, self.selection_start
                elif self.selection_start[1] &lt; self.selection_end[1]:
                        return self.selection_start, self.selection_end
                elif self.selection_start[0] &lt; self.selection_end[0]:
                        return self.selection_start, self.selection_end
                else:
                        return self.selection_end, self.selection_start
        else:
                return None, None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_tab_cursor"><code class="name flex">
<span>def <span class="ident">get_tab_cursor</span></span>(<span>self, current_line, current_column=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position of cursor with line with tabulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tab_cursor(self, current_line, current_column=None):
        &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
        if current_column is None:
                cursor_column = self.cursor_column
        else:
                cursor_column = current_column
        line = self.lines[current_line]
        if &#34;\t&#34; in line:
                tab_cursor_column   = 0
                column = 0
                len_line = len(line)
                while column &lt; cursor_column:
                        if line[column] == &#34;\t&#34;:
                                pos = tab_cursor_column%self.tab_size
                                tab_cursor_column += self.tab_size-pos
                                column          += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        partSize = tab - column
                                else:
                                        partSize = len_line - column
                                if column + partSize &gt; cursor_column:
                                        partSize = cursor_column - column
                                tab_cursor_column += partSize
                                column          += partSize
                return tab_cursor_column
        else:
                return cursor_column</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_tab_cursor_column"><code class="name flex">
<span>def <span class="ident">get_tab_cursor_column</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the column of cursor in tabuled line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tab_cursor_column(self):
        &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
        line = self.lines[self.cursor_line]
        column = 0
        self.tab_cursor_column = 0
        while column &lt; self.cursor_column:
                if line[column] == &#34;\t&#34;:
                        pos = self.tab_cursor_column%self.tab_size
                        self.tab_cursor_column += self.tab_size-pos
                        column += 1
                else:
                        tab = line.find(&#34;\t&#34;,column)
                        if tab &gt; 0:
                                delta = tab - column
                                if column + delta &gt; self.cursor_column:
                                        delta = self.cursor_column - column
                                        self.tab_cursor_column += delta
                                        column += delta
                                else:
                                        self.tab_cursor_column += delta
                                        column += delta
                        else:
                                delta = self.cursor_column - column
                                self.tab_cursor_column += delta
                                column += delta</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.get_tab_line"><code class="name flex">
<span>def <span class="ident">get_tab_line</span></span>(<span>self, current_line, start_column, end_column, binary=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the tabuled line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tab_line(self, current_line, start_column, end_column, binary = True):
        &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
        accent = False
        line = self.lines[current_line]
        if &#34;\t&#34; in line:
                tab_line = b&#34;&#34;
                cursor   = 0
                len_line = len(line)
                column = 0
                while column &lt; len_line:
                        char = line[column]
                        if char == &#34;\t&#34;:
                                pos = cursor%self.tab_size
                                cursor += self.tab_size-pos
                                tab_line          += b&#34; &#34;*(self.tab_size-pos)
                                column            += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &lt; 0:
                                        tab = len_line
                                part = line[column:tab]
                                cursor += len(part)
                                bin_part = part.encode(&#34;utf8&#34;)
                                tab_line          += bin_part
                                column            += len(part)
                                if len(part) != len(bin_part):
                                        accent = True

                tab_line = tab_line.replace(b&#34;\n&#34;,b&#34;&#34;)
                if binary is False:
                        tab_line = tab_line.decode(&#34;utf8&#34;)
        else:
                if binary:
                        tab_line = line.encode(&#34;utf8&#34;)
                        if len(line) != len(tab_line):
                                accent = True
                        tab_line = tab_line.replace(b&#34;\n&#34;,b&#34;&#34;)
                else:
                        tab_line = line
                        tab_line = tab_line.replace(&#34;\n&#34;,&#34;&#34;)

        if binary and accent:
                result = tab_line.decode(&#34;utf8&#34;)[start_column:end_column].encode(&#34;utf8&#34;)
        else:
                result = tab_line[start_column:end_column]

        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, line, column=None, clear_selection=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Goto specified line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self, line, column=None, clear_selection=True):
        &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
        if clear_selection:
                self.hide_selection()
        if line &lt; 0:
                self.cursor_line = len(self.lines)-1
        elif line &lt; 1:
                self.cursor_line = 1
        elif line &lt;= len(self.lines):
                self.cursor_line = line - 1
        else:
                self.cursor_line = len(self.lines)-1
                if column is not None:
                        column = tools.terminal.MAXINT
        self.cursor_column = 0

        if column is not None:
                if column &gt; 1:
                        cur_line = self.cursor_line
                        self.change_column(0, with_move_view=False)
                        for i in range(len(self.lines[self.cursor_line]) + 1):
                                self.change_column(1, with_move_view=False)
                                if self.tab_cursor_column &gt;= column-1:
                                        break

                                if self.cursor_line != cur_line:
                                        self.change_column(-1, with_move_view=False)
                                        break

        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.hide_selection"><code class="name flex">
<span>def <span class="ident">hide_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_selection(self):
        &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
        self.view.hide_selection()
        self.selection_start = self.selection_end = None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.home"><code class="name flex">
<span>def <span class="ident">home</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage home key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def home(self, keys=None):
        &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
        self.hide_selection()
        self.change_column(-tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.indent"><code class="name flex">
<span>def <span class="ident">indent</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage tabulation key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indent(self, keys=None):
        &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
        # If nothing selected
        if self.selection_start is None:
                self.add_char(keys)
        else:
                self.modified = True
                # Indent selection
                selection_start, selection_end = self.get_selection()
                sel_column_start, sel_line_start, dummy = selection_start
                sel_column_end,   sel_line_end,   dummy = selection_end

                # If a part of line selected
                if sel_line_start == sel_line_end and not (sel_column_start == 0 and sel_column_end == len(self.lines[sel_line_end])-1):
                        self.add_char(self.cfg.key_indent)
                else:
                        # If the last line selected is at beginning of line
                        if sel_column_end == 0:
                                # This line must not be indented
                                sel_line_end -= 1

                        # Add tabulation
                        for line in range(sel_line_start, sel_line_end+1):
                                self.lines[line] = &#34;\t&#34; + self.lines[line]

                        # Move the start selection to the start of first selected line
                        self.selection_start = [0,sel_line_start, 0]

                        # If the last line selected is not at beginning of line
                        if sel_column_end &gt; 0:
                                # Get the length of last selected line
                                len_line_end =  len(self.lines[sel_line_end])

                                # If the end of selection is not on the last line
                                if sel_line_end &lt; len(self.lines)-1:
                                        len_line_end -= 1

                                # Move the end of selection at the end of line selected
                                self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                        else:
                                # Move the end of selection at the start of the last line selected
                                self.selection_end  = [0, sel_line_end+1, 0]
                self.view.set_refresh_selection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.insert_char"><code class="name flex">
<span>def <span class="ident">insert_char</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert_char(self, char):
        &#34;&#34;&#34; Insert character &#34;&#34;&#34;
        self.modified = True
        self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column:]
        self.change_column(len(char))
        self.view.set_refresh_line()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load file in the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, filename):
        &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
        self.filename = None
        try:
                self.lines = []
                self.filename = filename
                file = open(filename, &#34;r&#34;)
                line = file.readline()
                while line != &#34;&#34;:
                        self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                        line = file.readline()
                file.close()
                if len(self.lines) == 0:
                        self.lines = [&#34;&#34;]
        except MemoryError:
                # pylint: disable=raise-missing-from
                raise MemoryError()
        except OSError:
                self.lines = [&#34;&#34;]
                # File not existing
        except Exception as err:
                tools.logger.syslog(err)
                self.lines = [&#34;&#34;]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.move_cursor"><code class="name flex">
<span>def <span class="ident">move_cursor</span></span>(<span>self, line, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_cursor(self, line, column):
        &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
        self.cursor_line   = line
        self.cursor_column = column
        self.change_column(0)
        self.get_tab_cursor_column()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.move_word"><code class="name flex">
<span>def <span class="ident">move_word</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_word(self, direction):
        &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
        state = 0
        while self.change_column(direction):
                current_char = self.get_cursor_char()
                if current_char is None:
                        break
                elif tools.strings.ispunctuation(current_char):
                        if state == 0:
                                state = 2
                        elif state == 1:
                                break
                elif tools.strings.isalpha(current_char):
                        if state == 0:
                                state = 1
                        elif state == 2:
                                break
                elif tools.strings.isspace(current_char):
                        if state == 1:
                                break
                        if state == 2:
                                break</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.new_line"><code class="name flex">
<span>def <span class="ident">new_line</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the newline key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_line(self, keys=None):
        &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
        self.modified = True
        self.remove_selection()
        line1 = self.lines[self.cursor_line][:self.cursor_column]+&#34;\n&#34;
        line2 = self.lines[self.cursor_line][self.cursor_column:]
        self.lines[self.cursor_line]=line1
        self.lines.insert(self.cursor_line+1, line2)
        self.view.scroll_part_down()
        self.change_column(1)
        self.view.set_refresh_before()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.next_word"><code class="name flex">
<span>def <span class="ident">next_word</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the next word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_word(self, keys=None):
        &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
        self.hide_selection()
        self.move_word(1)
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.open_selection"><code class="name flex">
<span>def <span class="ident">open_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_selection(self):
        &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
        if self.selection_start is None:
                self.selection_start = [self.cursor_column, self.cursor_line, self.get_tab_cursor(self.cursor_line, self.cursor_column)]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.page_down"><code class="name flex">
<span>def <span class="ident">page_down</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage page down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_down(self, keys=None):
        &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
        self.hide_selection()
        self.change_line((self.view.height) * len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.page_up"><code class="name flex">
<span>def <span class="ident">page_up</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage page up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def page_up(self, keys=None):
        &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
        self.hide_selection()
        self.change_line((-(self.view.height)) * len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.paste"><code class="name flex">
<span>def <span class="ident">paste</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage paste key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paste(self, keys=None):
        &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
        self.modified = True
        self.remove_selection()
        self.paste_clipboard(self.selection)
        self.hide_selection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.paste_clipboard"><code class="name flex">
<span>def <span class="ident">paste_clipboard</span></span>(<span>self, selection)</span>
</code></dt>
<dd>
<div class="desc"><p>Paste clipboard at the cursor position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paste_clipboard(self, selection):
        &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
        if selection != [] and selection != [&#34;&#34;]:
                start_line = self.cursor_line
                # Split the line with insertion
                start = self.lines[self.cursor_line][:self.cursor_column]
                end   = self.lines[self.cursor_line][self.cursor_column:]

                # Paste the first line
                self.lines[self.cursor_line] = start + selection[0]

                self.cursor_line += 1

                # Insert all lines from clipboard
                for line in selection[1:-1]:
                        self.lines.insert(self.cursor_line, line)
                        self.cursor_line += 1

                # If the last line of clipboard is not empty
                if len(selection[-1]) &gt;= 1:
                        # If the last line of clipboard contains carriage return at the end
                        if selection[-1][-1] == &#34;\n&#34;:
                                if len(selection) &gt; 1:
                                        # Add the new line
                                        self.lines.insert(self.cursor_line, selection[-1])
                                        self.cursor_line += 1

                                # Add the part after the insertion
                                self.lines.insert(self.cursor_line, end)
                                self.cursor_column = 0
                                if len(selection) &gt;= self.view.height:
                                        self.view.set_refresh_all()
                                else:
                                        self.view.set_refresh_bottom(start_line)
                        else:
                                # If many lines with last line without carriage return at the end
                                if len(selection) &gt; 1:
                                        self.lines.insert(self.cursor_line, selection[-1] + end)
                                        self.cursor_column = len(selection[-1])
                                        if len(selection) &gt;= self.view.height:
                                                self.view.set_refresh_all()
                                        else:
                                                self.view.set_refresh_bottom(start_line)
                                else:
                                        # Only one line without carriage return
                                        self.cursor_line -= 1
                                        self.lines[self.cursor_line] += end
                                        self.cursor_column = len(start) + len(selection[-1])
                                        self.view.set_refresh_line()
                self.move_cursor(self.cursor_line, self.cursor_column)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.previous_word"><code class="name flex">
<span>def <span class="ident">previous_word</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the previous word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previous_word(self, keys=None):
        &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
        self.hide_selection()
        self.move_word(-1)
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.remove_selection"><code class="name flex">
<span>def <span class="ident">remove_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_selection(self):
        &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
        if self.selection_start is not None:
                self.modified = True
                selection_start, selection_end = self.get_selection()
                sel_column_start, sel_line_start, _ = selection_start
                sel_column_end,   sel_line_end,   _ = selection_end
                start = self.lines[sel_line_start][:sel_column_start]
                end   = self.lines[sel_line_end  ][sel_column_end:]
                self.lines[sel_line_start] = start + end
                if sel_line_start &lt; sel_line_end:
                        for line in range(sel_line_end, sel_line_start,-1):
                                del self.lines[line]
                self.move_cursor(sel_line_start, sel_column_start)
                self.hide_selection()
                if sel_line_end == sel_line_start:
                        self.view.set_refresh_line()
                else:
                        self.view.set_refresh_bottom(sel_line_start)
                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, old, new)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, old, new):
        &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
        if self.read_only is False:
                selection = self.copy_clipboard()
                if len(selection) == 1:
                        if selection[0] == old:
                                self.delete()
                                self.insert_char(new)
                                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.replace_char"><code class="name flex">
<span>def <span class="ident">replace_char</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_char(self, char):
        &#34;&#34;&#34; Replace character &#34;&#34;&#34;
        self.modified = True
        if self.cursor_line == len(self.lines)-1 and self.cursor_column &gt;= len(self.lines[self.cursor_line])-1:
                self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char
                self.change_column(1)
                self.view.set_refresh_line()
        # If it is the last char in the line
        elif self.lines[self.cursor_line][self.cursor_column] == &#34;\n&#34;:
                # Append char to the line
                self.insert_char(char)
        # Else the char must be replaced in the line
        else:
                self.lines[self.cursor_line] = self.lines[self.cursor_line][:self.cursor_column] + char + self.lines[self.cursor_line][self.cursor_column+1:]
                self.change_column(1)
                self.view.set_refresh_line()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save text in the file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, filename=None):
        &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
        result = False
        if self.read_only is False:
                if filename is None:
                        filename = self.filename
                if filename is not None:
                        try:
                                file = open(filename, &#34;w&#34;)
                                for line in self.lines:
                                        file.write(line)
                                file.close()
                                self.modified = False
                                result = True
                        except Exception as err:
                                tools.logger.syslog(err)
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_all"><code class="name flex">
<span>def <span class="ident">select_all</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Do a select all</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_all(self, keys=None):
        &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
        self.selection_start = [0,0,0]
        lastLine = len(self.lines)-1
        lastColumn = len(self.lines[lastLine])
        self.move_cursor(lastLine, lastColumn)
        self.selection_end  = [lastColumn, lastLine, self.get_tab_cursor(lastLine, lastColumn)]
        self.view.set_refresh_all()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_bottom"><code class="name flex">
<span>def <span class="ident">select_bottom</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select to the last line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_bottom(self, keys=None):
        &#34;&#34;&#34; Manage select to the last line of text &#34;&#34;&#34;
        self.open_selection()
        self.change_line(tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_down"><code class="name flex">
<span>def <span class="ident">select_down</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_down(self, keys=None):
        &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
        self.open_selection()
        self.change_line(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_end"><code class="name flex">
<span>def <span class="ident">select_end</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage end key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_end(self, keys=None):
        &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
        self.open_selection()
        self.change_column(tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_home"><code class="name flex">
<span>def <span class="ident">select_home</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage home key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_home(self, keys=None):
        &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
        self.open_selection()
        self.change_column(-tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_left"><code class="name flex">
<span>def <span class="ident">select_left</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select left key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_left(self, keys=None):
        &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
        self.open_selection()
        self.change_column(-len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_next_word"><code class="name flex">
<span>def <span class="ident">select_next_word</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select next word key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_next_word(self, keys=None):
        &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
        self.open_selection()
        self.move_word(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_page_down"><code class="name flex">
<span>def <span class="ident">select_page_down</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select page down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_page_down(self, keys=None):
        &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
        self.open_selection()
        self.change_line((self.view.height) * len(keys))
        self.change_column(tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_page_up"><code class="name flex">
<span>def <span class="ident">select_page_up</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select page up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_page_up(self, keys=None):
        &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
        self.open_selection()
        self.change_line((-(self.view.height)) * len(keys))
        self.change_column(-tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_previous_word"><code class="name flex">
<span>def <span class="ident">select_previous_word</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select previous word key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_previous_word(self, keys=None):
        &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
        self.open_selection()
        self.move_word(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_right"><code class="name flex">
<span>def <span class="ident">select_right</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select right key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_right(self, keys=None):
        &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
        self.open_selection()
        self.change_column(len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_top"><code class="name flex">
<span>def <span class="ident">select_top</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select to the first line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_top(self, keys=None):
        &#34;&#34;&#34; Manage select to the first line of text &#34;&#34;&#34;
        self.open_selection()
        self.change_line(-tools.terminal.MAXINT)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.select_up"><code class="name flex">
<span>def <span class="ident">select_up</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_up(self, keys=None):
        &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
        self.open_selection()
        self.change_line(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.set_cursor_column"><code class="name flex">
<span>def <span class="ident">set_cursor_column</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the line change compute the cursor position with tabulation in the line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cursor_column(self):
        &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
        line = self.lines[self.cursor_line]
        column = 0
        tab_cursor_column = 0
        len_line = len(line)
        column = 0
        while column &lt; len_line:
                char = line[column]
                # If the previous position found exactly in the current line
                if tab_cursor_column == self.tab_cursor_column:
                        self.cursor_column = column
                        break
                # If the previous position not found in the current line
                if tab_cursor_column &gt; self.tab_cursor_column:
                        # Keep last existing position
                        self.cursor_column = column
                        break
                # If tabulation found
                if char == &#34;\t&#34;:
                        tab_cursor_column += self.tab_size-(tab_cursor_column%self.tab_size)
                        column += 1
                else:
                        # Optimization to accelerate the cursor position
                        tab = line.find(&#34;\t&#34;, column)

                        # Tabulation found
                        if tab &gt; 0:
                                delta = tab - column
                                # If the tabulation position is after the previous tabulation cursor
                                if delta + tab_cursor_column &gt; self.tab_cursor_column:
                                        # Move the cursor to the left
                                        self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                        break
                                else:
                                        # Another tabulation found, move it after
                                        tab_cursor_column += delta
                                        column += delta
                        # Tabulation not found
                        else:
                                # Move the cursor to the end of line
                                self.cursor_column = column + (self.tab_cursor_column - tab_cursor_column)
                                break
        else:
                if len(line) &gt;= 1:
                        self.cursor_column = len(line)-1
                else:
                        self.cursor_column = 0</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.set_view"><code class="name flex">
<span>def <span class="ident">set_view</span></span>(<span>self, view)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the view attached to the text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_view(self, view):
        &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
        self.view = view</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the first line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top(self, keys=None):
        &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
        self.goto(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.treat_char"><code class="name flex">
<span>def <span class="ident">treat_char</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Treat character entered</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treat_char(self, keys=None):
        &#34;&#34;&#34; Treat character entered &#34;&#34;&#34;
        char = ord(keys[0][0])
        if self.read_only is False:
                if char &gt;= 0x20 and char != 0x7F:
                        self.add_char(keys)
                        return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.treat_key"><code class="name flex">
<span>def <span class="ident">treat_key</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Treat keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treat_key(self, keys=None):
        &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
        key_callback = None
        if self.treat_char(keys) is False:
                # Move in the edit field
                if keys[0] in self.MOVE_KEYS:
                        if   keys[0] in self.cfg.key_left:            key_callback = self.arrow_left
                        elif keys[0] in self.cfg.key_right:           key_callback = self.arrow_right
                        elif keys[0] in self.cfg.key_up  :            key_callback = self.arrow_up
                        elif keys[0] in self.cfg.key_down:            key_callback = self.arrow_down
                        elif keys[0] in self.cfg.key_home:            key_callback = self.home
                        elif keys[0] in self.cfg.key_end:             key_callback = self.end
                        elif keys[0] in self.cfg.key_page_up:         key_callback = self.page_up
                        elif keys[0] in self.cfg.key_page_down:       key_callback = self.page_down
                        elif keys[0] in self.cfg.key_top:             key_callback = self.top
                        elif keys[0] in self.cfg.key_bottom:          key_callback = self.bottom
                        elif keys[0] in self.cfg.key_next_word:       key_callback = self.next_word
                        elif keys[0] in self.cfg.key_previous_word:   key_callback = self.previous_word
                elif keys[0] in self.SELECT_KEYS:
                        # Selection the edit field
                        if   keys[0] in self.cfg.key_sel_right:    key_callback = self.select_right
                        elif keys[0] in self.cfg.key_sel_left:     key_callback = self.select_left
                        elif keys[0] in self.cfg.key_sel_up:       key_callback = self.select_up
                        elif keys[0] in self.cfg.key_sel_down:     key_callback = self.select_down
                        elif keys[0] in self.cfg.key_sel_home:     key_callback = self.select_home
                        elif keys[0] in self.cfg.key_sel_end:      key_callback = self.select_end
                        elif keys[0] in self.cfg.key_sel_top:      key_callback = self.select_top
                        elif keys[0] in self.cfg.key_sel_bottom:   key_callback = self.select_bottom
                        elif keys[0] in self.cfg.key_sel_page_up:  key_callback = self.select_page_up
                        elif keys[0] in self.cfg.key_sel_page_down:key_callback = self.select_page_down
                        elif keys[0] in self.cfg.key_sel_all:      key_callback = self.select_all
                        elif keys[0] in self.cfg.key_sel_next_word:key_callback = self.select_next_word
                        elif keys[0] in self.cfg.key_sel_prev_word:key_callback = self.select_previous_word

                # If the edit is not in read only
                elif self.read_only is False:
                        if keys[0] in self.NOT_READ_ONLY_KEYS:
                                # Modification in the edit field
                                if   keys[0] in self.cfg.key_copy:        key_callback = self.copy
                                elif keys[0] in self.cfg.key_cut:         key_callback = self.cut
                                elif keys[0] in self.cfg.key_paste:       key_callback = self.paste
                                elif keys[0] in self.cfg.key_indent:      key_callback = self.indent
                                elif keys[0] in self.cfg.key_unindent:    key_callback = self.unindent
                                elif keys[0] in self.cfg.key_change_case: key_callback = self.change_case
                                elif keys[0] in self.cfg.key_comment:     key_callback = self.comment
                                elif keys[0] in self.cfg.key_backspace:   key_callback = self.backspace
                                elif keys[0] in self.cfg.key_delete:      key_callback = self.delete
                                elif keys[0] in self.cfg.key_new_line:    key_callback = self.new_line
                                elif keys[0] in self.cfg.key_del_line:    key_callback = self.delete_line
                # else: self.add_char(keys)
                if key_callback is not None:
                        key_callback(keys)
                else:
                        if len(keys[0]) &gt; 3:
                                # If camflasher mouse selection
                                if keys[0][0:2] == &#34;\x1B[&#34; and keys[0][-1] in [&#34;x&#34;,&#34;y&#34;]:
                                        try:
                                                pos = keys[0][2:-1]
                                                line, column = pos.split(&#34;;&#34;)
                                                self.begin_line, self.begin_column = self.view.get_position()
                                                if keys[0][-1] == &#34;x&#34;:
                                                        self.goto(int(line)+self.begin_line,int(column)+self.begin_column, True)
                                                        self.open_selection()
                                                        self.close_selection()
                                                else:
                                                        self.goto(int(line)+self.begin_line,int(column)+self.begin_column, False)
                                                        self.close_selection()
                                        except Exception as err:
                                                pass</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.unindent"><code class="name flex">
<span>def <span class="ident">unindent</span></span>(<span>self, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the unindentation key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unindent(self, keys=None):
        &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
        # If nothing selected
        if self.selection_start is None:
                self.backspace()
        else:
                self.modified = True

                # Unindent selection
                selection_start, selection_end = self.get_selection()
                sel_column_start, sel_line_start, dummy = selection_start
                sel_column_end,   sel_line_end,   dummy = selection_end

                # If the selection is only alone line
                if sel_line_start == sel_line_end:
                        self.hide_selection()
                else:
                        # If the last line selected is at beginning of line
                        if sel_column_end == 0:
                                # This line must not be indented
                                sel_line_end -= 1

                        # Remove indentation
                        for line in range(sel_line_start, sel_line_end+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selection_start = [0,sel_line_start, 0]

                        # If the last line selected is not at beginning of line
                        if sel_column_end &gt; 0:
                                # Get the length of last selected line
                                len_line_end =  len(self.lines[sel_line_end])

                                # If the end of selection is not on the last line
                                if sel_line_end &lt; len(self.lines)-1:
                                        len_line_end -= 1

                                # Move the end of selection at the end of line selected
                                self.selection_end   = [len_line_end, sel_line_end, self.get_tab_cursor(sel_line_end,len_line_end)]
                        else:
                                # Move the end of selection at the start of the last line selected
                                self.selection_end  = [0, sel_line_end+1, 0]
                self.view.set_refresh_selection()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.shell.editor.View"><code class="flex name class">
<span>class <span class="ident">View</span></span>
<span>(</span><span>cfg, view_height, view_top, extension=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage the view of the edit field </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class View:
        &#34;&#34;&#34; Class which manage the view of the edit field &#34;&#34;&#34;
        def __init__(self, cfg, view_height, view_top, extension=None):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.line     = 0
                self.column   = 0
                self.cfg      = cfg
                if view_height is None:
                        self.height   = 20
                else:
                        self.height             = view_height

                self.colorize = self.colorize_none
                if is_enough_memory():
                        if extension is not None:
                                if extension.lower() == &#34;.py&#34;:
                                        # pylint: disable=import-error
                                        try:
                                                try:
                                                        from editor_py import Colorizer
                                                except:
                                                        from shell.editor_py import Colorizer
                                                self.colorizer = Colorizer()
                                                self.colorize = self.colorize_syntax
                                        except:
                                                pass

                self.width                  = 80
                self.top                    = view_top
                self.is_refresh_all         = True
                self.is_refresh_line        = False
                self.is_refresh_line_before = False
                self.is_refresh_line_after  = False
                self.refresh_part           = None
                self.text                   = None
                self.tab_cursor_column      = 0
                self.sel_line_start         = None
                self.sel_line_end           = None
                self.screen_height          = 1
                self.screen_width           = 1
                if tools.filesystem.ismicropython():
                        self.write = self.write_byte
                else:
                        self.write = self.write_string

        def write_byte(self, data):
                &#34;&#34;&#34; Write data to stdout in byte (for micropython only) &#34;&#34;&#34;
                sys.stdout.write(data)

        def write_string(self, data):
                &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
                sys.stdout.write(tools.strings.tostrings(data))

        def flush(self):
                &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
                try:
                        sys.stdout.flush()
                except:
                        pass

        def set_text(self, text):
                &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
                self.text = text

        def get_screen_position(self):
                &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
                return (self.text.get_cursor_line() - self.line + self.top, self.tab_cursor_column - self.column)

        def reset(self):
                &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
                self.write(b&#34;\x1B&#34;+b&#34;c&#34;)
                self.flush()

        def reset_scroll_region(self):
                &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
                if self.screen_height &gt; 0:
                        self.set_scrolling_region(0, self.screen_height-1)

        def set_scrolling_region(self, top_line, bottom_line):
                &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
                if top_line &lt; bottom_line:
                        self.write(b&#34;\x1B[%d;%dr&#34;%(top_line+1,bottom_line+1))

        def scroll_up(self):
                &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
                self.set_scrolling_region(self.top, self.height+1)
                self.write(b&#34;\x1B[1S&#34;)

        def scroll_down(self):
                &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
                self.set_scrolling_region(self.top, self.height+1)
                self.write(b&#34;\x1B[1T&#34;)

        def scroll_part_up(self):
                &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
                line, column = self.get_screen_position()
                if line &lt; self.height:
                        self.set_scrolling_region(line +1, self.height+1)
                        self.write(b&#34;\x1B[1S&#34;)
                elif line == self.height:
                        self.write(b&#34;\x1B[%d;1f\x1B[K&#34;%(self.height + 1 + self.top))

        def scroll_part_down(self):
                &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
                line, column = self.get_screen_position()
                if line &lt; self.height:
                        self.set_scrolling_region(line+1, self.height+1)
                        self.write(b&#34;\x1B[1T&#34;)
                else:
                        self.is_refresh_line_after = True

        def move(self):
                &#34;&#34;&#34; Move the view &#34;&#34;&#34;
                self.tab_cursor_column = self.text.get_tab_cursor(self.text.get_cursor_line())
                # Move view port
                if self.tab_cursor_column &lt; self.column:
                        self.is_refresh_all = True
                        if self.tab_cursor_column &gt; HORIZONTAL_MOVE:
                                self.column = self.tab_cursor_column-HORIZONTAL_MOVE
                        else:
                                self.column = 0
                elif self.tab_cursor_column &gt;= self.column + self.width:
                        self.column = self.tab_cursor_column-self.width+HORIZONTAL_MOVE
                        self.is_refresh_all = True
                if self.text.get_cursor_line() &lt; self.line:
                        delta = self.line - self.text.get_cursor_line()
                        self.line = self.text.get_cursor_line()
                        if self.line &lt; 0:
                                self.line = 0
                        if delta &lt;= 1:
                                self.scroll_down()
                                self.is_refresh_line = True
                        else:
                                self.is_refresh_all = True
                elif self.text.get_cursor_line() &gt; self.line + self.height:
                        delta =  self.text.get_cursor_line() - self.line - self.height
                        self.line = self.text.get_cursor_line()-self.height
                        if delta &lt;= 1:
                                self.scroll_up()
                                self.is_refresh_line = True
                        else:
                                self.is_refresh_all = True

        def set_refresh_line(self):
                &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True

        def set_refresh_after(self):
                &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True
                self.is_refresh_line_after = True

        def set_refresh_before(self):
                &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
                self.is_refresh_line = True
                self.is_refresh_line_before = True

        def set_refresh_all(self):
                &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
                self.is_refresh_all = True

        def set_refresh_bottom(self, cursor):
                &#34;&#34;&#34; Refresh from the cursor to the end of screen &#34;&#34;&#34;
                self.refresh_part = [cursor, cursor+self.height+self.height]

        def show_line(self, current_line, screen_line, selection_start, selection_end, quick=False):
                &#34;&#34;&#34; Show one line &#34;&#34;&#34;
                if not quick:
                        clear_line = b&#34;\x1B[%d;1f\x1B[K&#34;%(screen_line+1)
                else:
                        clear_line = b&#34;&#34;
                count_line = self.text.get_count_lines()
                if current_line &lt; count_line and current_line &gt;= 0:
                        # If the line selected
                        if selection_start is not None:
                                _, sel_line_start, sel_column_start = selection_start
                                _, sel_line_end,   sel_column_end   = selection_end
                                # If the line is completly selected
                                if current_line &gt; sel_line_start and current_line &lt; sel_line_end:
                                        part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, True)
                                        if (len(part_line) == 0):
                                                part_line = b&#34; &#34;
                                        self.write(clear_line+SELECTION_START+part_line+SELECTION_END)
                                # If the line is partially selected
                                else:
                                        part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, False)
                                        # part_line = line[self.column:self.column+self.width]
                                        if len(part_line) &gt; 0:
                                                # If the end of selection is outside the visible part
                                                if sel_column_end - self.column &lt; 0:
                                                        sel_column_end = 0
                                                else:
                                                        sel_column_end -= self.column

                                                # If the start of selection is outside the visible part
                                                if sel_column_start - self.column &lt; 0:
                                                        sel_column_start = 0
                                                else:
                                                        sel_column_start -= self.column

                                                # If the selection is on alone line
                                                if current_line == sel_line_end and current_line == sel_line_start:
                                                        self.write(clear_line)
                                                        self.colorize(part_line[:sel_column_start].encode(&#34;utf8&#34;))
                                                        self.write(SELECTION_START+part_line[sel_column_start:sel_column_end].encode(&#34;utf8&#34;)+SELECTION_END)
                                                        self.colorize(part_line[sel_column_end:].encode(&#34;utf8&#34;))
                                                # If current line is on the last selection line
                                                elif current_line == sel_line_end:
                                                        self.write(clear_line+SELECTION_START+part_line[:sel_column_end].encode(&#34;utf8&#34;)+SELECTION_END)
                                                        self.colorize(part_line[sel_column_end:].encode(&#34;utf8&#34;))
                                                # If current line is on the first selection line
                                                elif current_line == sel_line_start:
                                                        self.write(clear_line)
                                                        self.colorize(part_line[:sel_column_start].encode(&#34;utf8&#34;))
                                                        self.write(SELECTION_START+part_line[sel_column_start:].encode(&#34;utf8&#34;)+SELECTION_END)
                                                # Else the line is not selected
                                                else:
                                                        self.write(clear_line)
                                                        self.colorize(part_line.encode(&#34;utf8&#34;))
                                        else:
                                                if current_line &gt;= sel_line_start and current_line &lt;= sel_line_end:
                                                        self.write(clear_line+SELECTION_START+b&#34; &#34;+SELECTION_END)
                                                else:
                                                        self.write(clear_line)
                        else:
                                part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, True)
                                self.write(clear_line)
                                self.colorize(part_line)
                elif current_line == count_line:
                        self.write(clear_line)

        def colorize_none(self, text):
                &#34;&#34;&#34; No colorization &#34;&#34;&#34;
                self.write(text)

        def colorize_syntax(self, text):
                &#34;&#34;&#34; Syntax colorization &#34;&#34;&#34;
                self.colorizer.colorize(text, self)

        def refresh_line(self, selection_start, selection_end):
                &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
                screen_line,     screen_column = self.get_screen_position()
                refreshed = False

                # If the line must be refreshed before the cursor line
                if self.is_refresh_line_before:
                        self.is_refresh_line_before = False
                        self.show_line(self.text.get_cursor_line()-1, screen_line-1, selection_start, selection_end)
                        refreshed = True
                # If the line must be refreshed after the cursor line
                if self.is_refresh_line_after:
                        self.is_refresh_line_after = False
                        self.show_line(self.text.get_cursor_line()+1, screen_line+1, selection_start, selection_end)
                        offset = self.height - screen_line
                        self.show_line(self.text.get_cursor_line()+offset+1, screen_line+offset+1, selection_start, selection_end)
                        refreshed = True
                # If only the cursor line must be refresh
                if self.is_refresh_line:
                        self.is_refresh_line = False
                        self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)
                        refreshed = True

                # If no refresh detected and a selection started
                if selection_start is not None and refreshed is False:
                        # Refresh the selection
                        self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)

        def refresh(self):
                &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if self.refresh_part is not None:
                        self.refresh_content(selection_start, selection_end, self.refresh_part)
                        self.refresh_part = None
                # Refresh all required
                if self.is_refresh_all:
                        self.refresh_content(selection_start, selection_end, True)
                        self.is_refresh_all  = False
                        self.is_refresh_line = False
                else:
                        # If no selection activated
                        if selection_start is None:
                                # Refresh the current line
                                self.refresh_line(selection_start, selection_end)
                        else:
                                # Refresh the selection
                                self.refresh_content(selection_start, selection_end, False)
                self.move_cursor()
                self.flush()

        def refresh_content(self, selection_start, selection_end, all_):
                &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
                # If selection present
                if selection_start is not None:
                        # Get the selection
                        dummy, sel_line_start, sel_column_start = selection_start
                        dummy, sel_line_end,   sel_column_end   = selection_end
                        line_start = sel_line_start
                        line_end   = sel_line_end
                        # The aim of this part is to limit the refresh area
                        # If the precedent display show a selection
                        if self.sel_line_end is not None and self.sel_line_start is not None:
                                # If the start and end of selection is on the sames lines
                                if self.sel_line_end == sel_line_end and self.sel_line_start == sel_line_start:
                                        line_start = line_end = self.text.get_cursor_line()
                                else:
                                        # If the end of selection is after the precedent display
                                        if self.sel_line_end &gt; sel_line_end:
                                                line_end = self.sel_line_end
                                        # If the end of selection is on the same line than the precedent display
                                        elif self.sel_line_end == sel_line_end:
                                                # If the start of selection is before the precedent display
                                                if self.sel_line_start &lt; sel_line_start:
                                                        line_end = sel_line_start
                                                else:
                                                        line_end = self.sel_line_start
                                        # If the start of selection is before the precedent display
                                        if self.sel_line_start &lt; sel_line_start:
                                                line_start = self.sel_line_start
                                        # If the start of selection is on the same line than the precedent display
                                        elif self.sel_line_start == sel_line_start:
                                                # If the end of selection is after the precedent display
                                                if self.sel_line_end &gt; sel_line_end:
                                                        line_start = sel_line_end
                                                else:
                                                        line_start = self.sel_line_end
                else:
                        line_start = 0
                        line_end = self.line + self.height
                current_line = self.line
                screen_line = self.top
                if type(all_) == type([]):
                        line_start, line_end = all_
                        all_ = False
                count_line = self.text.get_count_lines()
                max_line = self.line + self.height
                if all_:
                        # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                        self.move_cursor(screen_line, 0)
                        self.write(b&#34;\x1B[J&#34;)
                        # Refresh all lines visible
                        while current_line &lt; count_line and current_line &lt;= max_line:
                                self.show_line(current_line, screen_line, selection_start, selection_end, True)
                                screen_line  += 1
                                current_line += 1
                                if (current_line &lt; count_line and current_line &lt;= max_line):
                                        self.write(b&#34;\n\r&#34;)
                else:
                        # Refresh all lines visible
                        while current_line &lt; count_line and current_line &lt;= max_line:
                                # If the line is in selection or all must be refreshed
                                if line_start &lt;= current_line &lt;= line_end or all_:
                                        self.show_line(current_line, screen_line, selection_start, selection_end)
                                screen_line  += 1
                                current_line += 1
                        if line_end &gt; max_line:
                                self.cls_end_screen()

                # If selection present
                if selection_start is not None:
                        # Save current selection
                        _, self.sel_line_start, _ = selection_start
                        _, self.sel_line_end,   _ = selection_end

        def hide_selection(self):
                &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if selection_start is not None:
                        self.set_refresh_selection()
                        self.sel_line_start = None
                        self.sel_line_end   = None

        def set_refresh_selection(self):
                &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
                selection_start, selection_end = self.text.get_selection()
                if selection_start is not None:
                        line_start = selection_start[1]
                        if self.sel_line_start is not None:
                                if self.sel_line_start &lt; line_start:
                                        line_start = self.sel_line_start
                        line_end = selection_end[1]
                        if self.sel_line_end is not None:
                                if self.sel_line_end &gt; line_end:
                                        line_end = self.sel_line_end
                        self.refresh_part = [line_start, line_end]

        def move_cursor(self, screen_line=None, screen_column=None):
                &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
                if screen_line is None and screen_column is None:
                        screen_line, screen_column = self.get_screen_position()
                self.write(b&#34;\x1B[%d;%df&#34;%(screen_line+1, screen_column+1))

        def get_screen_size(self):
                &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
                height, width = tools.terminal.get_screen_size(True)
                self.screen_height = height
                self.screen_width = width
                self.height = height-self.top-1
                self.width  = width
                self.move_cursor()

        def cls(self):
                &#34;&#34;&#34; clear the screen &#34;&#34;&#34;
                self.write(b&#34;\x1B[2J&#34;)
                self.move_cursor(0,0)

        def cls_end_screen(self):
                &#34;&#34;&#34; clear the end of screen &#34;&#34;&#34;
                self.write(b&#34;\x1B[0J&#34;)

        def get_position(self):
                &#34;&#34;&#34; Get the position of view &#34;&#34;&#34;
                return self.line, self.column</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.View.cls"><code class="name flex">
<span>def <span class="ident">cls</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cls(self):
        &#34;&#34;&#34; clear the screen &#34;&#34;&#34;
        self.write(b&#34;\x1B[2J&#34;)
        self.move_cursor(0,0)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.cls_end_screen"><code class="name flex">
<span>def <span class="ident">cls_end_screen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>clear the end of screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cls_end_screen(self):
        &#34;&#34;&#34; clear the end of screen &#34;&#34;&#34;
        self.write(b&#34;\x1B[0J&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.colorize_none"><code class="name flex">
<span>def <span class="ident">colorize_none</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>No colorization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def colorize_none(self, text):
        &#34;&#34;&#34; No colorization &#34;&#34;&#34;
        self.write(text)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.colorize_syntax"><code class="name flex">
<span>def <span class="ident">colorize_syntax</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Syntax colorization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def colorize_syntax(self, text):
        &#34;&#34;&#34; Syntax colorization &#34;&#34;&#34;
        self.colorizer.colorize(text, self)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flush text to stdout</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self):
        &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
        try:
                sys.stdout.flush()
        except:
                pass</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.get_position"><code class="name flex">
<span>def <span class="ident">get_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the position of view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_position(self):
        &#34;&#34;&#34; Get the position of view &#34;&#34;&#34;
        return self.line, self.column</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.get_screen_position"><code class="name flex">
<span>def <span class="ident">get_screen_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the screen position of cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screen_position(self):
        &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
        return (self.text.get_cursor_line() - self.line + self.top, self.tab_cursor_column - self.column)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.get_screen_size"><code class="name flex">
<span>def <span class="ident">get_screen_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the screen size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_screen_size(self):
        &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
        height, width = tools.terminal.get_screen_size(True)
        self.screen_height = height
        self.screen_width = width
        self.height = height-self.top-1
        self.width  = width
        self.move_cursor()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.hide_selection"><code class="name flex">
<span>def <span class="ident">hide_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hide_selection(self):
        &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
        selection_start, selection_end = self.text.get_selection()
        if selection_start is not None:
                self.set_refresh_selection()
                self.sel_line_start = None
                self.sel_line_end   = None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self):
        &#34;&#34;&#34; Move the view &#34;&#34;&#34;
        self.tab_cursor_column = self.text.get_tab_cursor(self.text.get_cursor_line())
        # Move view port
        if self.tab_cursor_column &lt; self.column:
                self.is_refresh_all = True
                if self.tab_cursor_column &gt; HORIZONTAL_MOVE:
                        self.column = self.tab_cursor_column-HORIZONTAL_MOVE
                else:
                        self.column = 0
        elif self.tab_cursor_column &gt;= self.column + self.width:
                self.column = self.tab_cursor_column-self.width+HORIZONTAL_MOVE
                self.is_refresh_all = True
        if self.text.get_cursor_line() &lt; self.line:
                delta = self.line - self.text.get_cursor_line()
                self.line = self.text.get_cursor_line()
                if self.line &lt; 0:
                        self.line = 0
                if delta &lt;= 1:
                        self.scroll_down()
                        self.is_refresh_line = True
                else:
                        self.is_refresh_all = True
        elif self.text.get_cursor_line() &gt; self.line + self.height:
                delta =  self.text.get_cursor_line() - self.line - self.height
                self.line = self.text.get_cursor_line()-self.height
                if delta &lt;= 1:
                        self.scroll_up()
                        self.is_refresh_line = True
                else:
                        self.is_refresh_all = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.move_cursor"><code class="name flex">
<span>def <span class="ident">move_cursor</span></span>(<span>self, screen_line=None, screen_column=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor in the view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_cursor(self, screen_line=None, screen_column=None):
        &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
        if screen_line is None and screen_column is None:
                screen_line, screen_column = self.get_screen_position()
        self.write(b&#34;\x1B[%d;%df&#34;%(screen_line+1, screen_column+1))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
        &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
        selection_start, selection_end = self.text.get_selection()
        if self.refresh_part is not None:
                self.refresh_content(selection_start, selection_end, self.refresh_part)
                self.refresh_part = None
        # Refresh all required
        if self.is_refresh_all:
                self.refresh_content(selection_start, selection_end, True)
                self.is_refresh_all  = False
                self.is_refresh_line = False
        else:
                # If no selection activated
                if selection_start is None:
                        # Refresh the current line
                        self.refresh_line(selection_start, selection_end)
                else:
                        # Refresh the selection
                        self.refresh_content(selection_start, selection_end, False)
        self.move_cursor()
        self.flush()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refresh_content"><code class="name flex">
<span>def <span class="ident">refresh_content</span></span>(<span>self, selection_start, selection_end, all_)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh content</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_content(self, selection_start, selection_end, all_):
        &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
        # If selection present
        if selection_start is not None:
                # Get the selection
                dummy, sel_line_start, sel_column_start = selection_start
                dummy, sel_line_end,   sel_column_end   = selection_end
                line_start = sel_line_start
                line_end   = sel_line_end
                # The aim of this part is to limit the refresh area
                # If the precedent display show a selection
                if self.sel_line_end is not None and self.sel_line_start is not None:
                        # If the start and end of selection is on the sames lines
                        if self.sel_line_end == sel_line_end and self.sel_line_start == sel_line_start:
                                line_start = line_end = self.text.get_cursor_line()
                        else:
                                # If the end of selection is after the precedent display
                                if self.sel_line_end &gt; sel_line_end:
                                        line_end = self.sel_line_end
                                # If the end of selection is on the same line than the precedent display
                                elif self.sel_line_end == sel_line_end:
                                        # If the start of selection is before the precedent display
                                        if self.sel_line_start &lt; sel_line_start:
                                                line_end = sel_line_start
                                        else:
                                                line_end = self.sel_line_start
                                # If the start of selection is before the precedent display
                                if self.sel_line_start &lt; sel_line_start:
                                        line_start = self.sel_line_start
                                # If the start of selection is on the same line than the precedent display
                                elif self.sel_line_start == sel_line_start:
                                        # If the end of selection is after the precedent display
                                        if self.sel_line_end &gt; sel_line_end:
                                                line_start = sel_line_end
                                        else:
                                                line_start = self.sel_line_end
        else:
                line_start = 0
                line_end = self.line + self.height
        current_line = self.line
        screen_line = self.top
        if type(all_) == type([]):
                line_start, line_end = all_
                all_ = False
        count_line = self.text.get_count_lines()
        max_line = self.line + self.height
        if all_:
                # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                self.move_cursor(screen_line, 0)
                self.write(b&#34;\x1B[J&#34;)
                # Refresh all lines visible
                while current_line &lt; count_line and current_line &lt;= max_line:
                        self.show_line(current_line, screen_line, selection_start, selection_end, True)
                        screen_line  += 1
                        current_line += 1
                        if (current_line &lt; count_line and current_line &lt;= max_line):
                                self.write(b&#34;\n\r&#34;)
        else:
                # Refresh all lines visible
                while current_line &lt; count_line and current_line &lt;= max_line:
                        # If the line is in selection or all must be refreshed
                        if line_start &lt;= current_line &lt;= line_end or all_:
                                self.show_line(current_line, screen_line, selection_start, selection_end)
                        screen_line  += 1
                        current_line += 1
                if line_end &gt; max_line:
                        self.cls_end_screen()

        # If selection present
        if selection_start is not None:
                # Save current selection
                _, self.sel_line_start, _ = selection_start
                _, self.sel_line_end,   _ = selection_end</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refresh_line"><code class="name flex">
<span>def <span class="ident">refresh_line</span></span>(<span>self, selection_start, selection_end)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_line(self, selection_start, selection_end):
        &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
        screen_line,     screen_column = self.get_screen_position()
        refreshed = False

        # If the line must be refreshed before the cursor line
        if self.is_refresh_line_before:
                self.is_refresh_line_before = False
                self.show_line(self.text.get_cursor_line()-1, screen_line-1, selection_start, selection_end)
                refreshed = True
        # If the line must be refreshed after the cursor line
        if self.is_refresh_line_after:
                self.is_refresh_line_after = False
                self.show_line(self.text.get_cursor_line()+1, screen_line+1, selection_start, selection_end)
                offset = self.height - screen_line
                self.show_line(self.text.get_cursor_line()+offset+1, screen_line+offset+1, selection_start, selection_end)
                refreshed = True
        # If only the cursor line must be refresh
        if self.is_refresh_line:
                self.is_refresh_line = False
                self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)
                refreshed = True

        # If no refresh detected and a selection started
        if selection_start is not None and refreshed is False:
                # Refresh the selection
                self.show_line(self.text.get_cursor_line(), screen_line, selection_start, selection_end)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset VT100</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
        &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
        self.write(b&#34;\x1B&#34;+b&#34;c&#34;)
        self.flush()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.reset_scroll_region"><code class="name flex">
<span>def <span class="ident">reset_scroll_region</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset VT100 scroll region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_scroll_region(self):
        &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
        if self.screen_height &gt; 0:
                self.set_scrolling_region(0, self.screen_height-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scroll_down"><code class="name flex">
<span>def <span class="ident">scroll_down</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll to down</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_down(self):
        &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
        self.set_scrolling_region(self.top, self.height+1)
        self.write(b&#34;\x1B[1T&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scroll_part_down"><code class="name flex">
<span>def <span class="ident">scroll_part_down</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the lower part</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_part_down(self):
        &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
        line, column = self.get_screen_position()
        if line &lt; self.height:
                self.set_scrolling_region(line+1, self.height+1)
                self.write(b&#34;\x1B[1T&#34;)
        else:
                self.is_refresh_line_after = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scroll_part_up"><code class="name flex">
<span>def <span class="ident">scroll_part_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the upper part</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_part_up(self):
        &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
        line, column = self.get_screen_position()
        if line &lt; self.height:
                self.set_scrolling_region(line +1, self.height+1)
                self.write(b&#34;\x1B[1S&#34;)
        elif line == self.height:
                self.write(b&#34;\x1B[%d;1f\x1B[K&#34;%(self.height + 1 + self.top))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scroll_up"><code class="name flex">
<span>def <span class="ident">scroll_up</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll to up</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_up(self):
        &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
        self.set_scrolling_region(self.top, self.height+1)
        self.write(b&#34;\x1B[1S&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_after"><code class="name flex">
<span>def <span class="ident">set_refresh_after</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines after the current line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_after(self):
        &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
        self.is_refresh_line = True
        self.is_refresh_line_after = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_all"><code class="name flex">
<span>def <span class="ident">set_refresh_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_all(self):
        &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
        self.is_refresh_all = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_before"><code class="name flex">
<span>def <span class="ident">set_refresh_before</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines before the current line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_before(self):
        &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
        self.is_refresh_line = True
        self.is_refresh_line_before = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_bottom"><code class="name flex">
<span>def <span class="ident">set_refresh_bottom</span></span>(<span>self, cursor)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh from the cursor to the end of screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_bottom(self, cursor):
        &#34;&#34;&#34; Refresh from the cursor to the end of screen &#34;&#34;&#34;
        self.refresh_part = [cursor, cursor+self.height+self.height]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_line"><code class="name flex">
<span>def <span class="ident">set_refresh_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_line(self):
        &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
        self.is_refresh_line = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_refresh_selection"><code class="name flex">
<span>def <span class="ident">set_refresh_selection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the selection must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_refresh_selection(self):
        &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
        selection_start, selection_end = self.text.get_selection()
        if selection_start is not None:
                line_start = selection_start[1]
                if self.sel_line_start is not None:
                        if self.sel_line_start &lt; line_start:
                                line_start = self.sel_line_start
                line_end = selection_end[1]
                if self.sel_line_end is not None:
                        if self.sel_line_end &gt; line_end:
                                line_end = self.sel_line_end
                self.refresh_part = [line_start, line_end]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_scrolling_region"><code class="name flex">
<span>def <span class="ident">set_scrolling_region</span></span>(<span>self, top_line, bottom_line)</span>
</code></dt>
<dd>
<div class="desc"><p>Define VT100 scroll region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_scrolling_region(self, top_line, bottom_line):
        &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
        if top_line &lt; bottom_line:
                self.write(b&#34;\x1B[%d;%dr&#34;%(top_line+1,bottom_line+1))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.set_text"><code class="name flex">
<span>def <span class="ident">set_text</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the text object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_text(self, text):
        &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
        self.text = text</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.show_line"><code class="name flex">
<span>def <span class="ident">show_line</span></span>(<span>self, current_line, screen_line, selection_start, selection_end, quick=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Show one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_line(self, current_line, screen_line, selection_start, selection_end, quick=False):
        &#34;&#34;&#34; Show one line &#34;&#34;&#34;
        if not quick:
                clear_line = b&#34;\x1B[%d;1f\x1B[K&#34;%(screen_line+1)
        else:
                clear_line = b&#34;&#34;
        count_line = self.text.get_count_lines()
        if current_line &lt; count_line and current_line &gt;= 0:
                # If the line selected
                if selection_start is not None:
                        _, sel_line_start, sel_column_start = selection_start
                        _, sel_line_end,   sel_column_end   = selection_end
                        # If the line is completly selected
                        if current_line &gt; sel_line_start and current_line &lt; sel_line_end:
                                part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, True)
                                if (len(part_line) == 0):
                                        part_line = b&#34; &#34;
                                self.write(clear_line+SELECTION_START+part_line+SELECTION_END)
                        # If the line is partially selected
                        else:
                                part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, False)
                                # part_line = line[self.column:self.column+self.width]
                                if len(part_line) &gt; 0:
                                        # If the end of selection is outside the visible part
                                        if sel_column_end - self.column &lt; 0:
                                                sel_column_end = 0
                                        else:
                                                sel_column_end -= self.column

                                        # If the start of selection is outside the visible part
                                        if sel_column_start - self.column &lt; 0:
                                                sel_column_start = 0
                                        else:
                                                sel_column_start -= self.column

                                        # If the selection is on alone line
                                        if current_line == sel_line_end and current_line == sel_line_start:
                                                self.write(clear_line)
                                                self.colorize(part_line[:sel_column_start].encode(&#34;utf8&#34;))
                                                self.write(SELECTION_START+part_line[sel_column_start:sel_column_end].encode(&#34;utf8&#34;)+SELECTION_END)
                                                self.colorize(part_line[sel_column_end:].encode(&#34;utf8&#34;))
                                        # If current line is on the last selection line
                                        elif current_line == sel_line_end:
                                                self.write(clear_line+SELECTION_START+part_line[:sel_column_end].encode(&#34;utf8&#34;)+SELECTION_END)
                                                self.colorize(part_line[sel_column_end:].encode(&#34;utf8&#34;))
                                        # If current line is on the first selection line
                                        elif current_line == sel_line_start:
                                                self.write(clear_line)
                                                self.colorize(part_line[:sel_column_start].encode(&#34;utf8&#34;))
                                                self.write(SELECTION_START+part_line[sel_column_start:].encode(&#34;utf8&#34;)+SELECTION_END)
                                        # Else the line is not selected
                                        else:
                                                self.write(clear_line)
                                                self.colorize(part_line.encode(&#34;utf8&#34;))
                                else:
                                        if current_line &gt;= sel_line_start and current_line &lt;= sel_line_end:
                                                self.write(clear_line+SELECTION_START+b&#34; &#34;+SELECTION_END)
                                        else:
                                                self.write(clear_line)
                else:
                        part_line = self.text.get_tab_line(current_line, self.column, self.column+self.width, True)
                        self.write(clear_line)
                        self.colorize(part_line)
        elif current_line == count_line:
                self.write(clear_line)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.write_byte"><code class="name flex">
<span>def <span class="ident">write_byte</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to stdout in byte (for micropython only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_byte(self, data):
        &#34;&#34;&#34; Write data to stdout in byte (for micropython only) &#34;&#34;&#34;
        sys.stdout.write(data)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.write_string"><code class="name flex">
<span>def <span class="ident">write_string</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to stdout</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_string(self, data):
        &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
        sys.stdout.write(tools.strings.tostrings(data))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.shell" href="index.html">lib.shell</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lib.shell.editor.is_enough_memory" href="#lib.shell.editor.is_enough_memory">is_enough_memory</a></code></li>
<li><code><a title="lib.shell.editor.main" href="#lib.shell.editor.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.shell.editor.Edit" href="#lib.shell.editor.Edit">Edit</a></code></h4>
</li>
<li>
<h4><code><a title="lib.shell.editor.Editor" href="#lib.shell.editor.Editor">Editor</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.shell.editor.Editor.execute" href="#lib.shell.editor.Editor.execute">execute</a></code></li>
<li><code><a title="lib.shell.editor.Editor.exit" href="#lib.shell.editor.Editor.exit">exit</a></code></li>
<li><code><a title="lib.shell.editor.Editor.find" href="#lib.shell.editor.Editor.find">find</a></code></li>
<li><code><a title="lib.shell.editor.Editor.find_next" href="#lib.shell.editor.Editor.find_next">find_next</a></code></li>
<li><code><a title="lib.shell.editor.Editor.find_previous" href="#lib.shell.editor.Editor.find_previous">find_previous</a></code></li>
<li><code><a title="lib.shell.editor.Editor.get_key" href="#lib.shell.editor.Editor.get_key">get_key</a></code></li>
<li><code><a title="lib.shell.editor.Editor.goto" href="#lib.shell.editor.Editor.goto">goto</a></code></li>
<li><code><a title="lib.shell.editor.Editor.group_key" href="#lib.shell.editor.Editor.group_key">group_key</a></code></li>
<li><code><a title="lib.shell.editor.Editor.input" href="#lib.shell.editor.Editor.input">input</a></code></li>
<li><code><a title="lib.shell.editor.Editor.refresh" href="#lib.shell.editor.Editor.refresh">refresh</a></code></li>
<li><code><a title="lib.shell.editor.Editor.refresh_header" href="#lib.shell.editor.Editor.refresh_header">refresh_header</a></code></li>
<li><code><a title="lib.shell.editor.Editor.replace" href="#lib.shell.editor.Editor.replace">replace</a></code></li>
<li><code><a title="lib.shell.editor.Editor.replace_all" href="#lib.shell.editor.Editor.replace_all">replace_all</a></code></li>
<li><code><a title="lib.shell.editor.Editor.replace_current" href="#lib.shell.editor.Editor.replace_current">replace_current</a></code></li>
<li><code><a title="lib.shell.editor.Editor.run" href="#lib.shell.editor.Editor.run">run</a></code></li>
<li><code><a title="lib.shell.editor.Editor.save" href="#lib.shell.editor.Editor.save">save</a></code></li>
<li><code><a title="lib.shell.editor.Editor.toggle_mode" href="#lib.shell.editor.Editor.toggle_mode">toggle_mode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.shell.editor.EditorConfig" href="#lib.shell.editor.EditorConfig">EditorConfig</a></code></h4>
</li>
<li>
<h4><code><a title="lib.shell.editor.Text" href="#lib.shell.editor.Text">Text</a></code></h4>
<ul class="">
<li><code><a title="lib.shell.editor.Text.add_char" href="#lib.shell.editor.Text.add_char">add_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrow_down" href="#lib.shell.editor.Text.arrow_down">arrow_down</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrow_left" href="#lib.shell.editor.Text.arrow_left">arrow_left</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrow_right" href="#lib.shell.editor.Text.arrow_right">arrow_right</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrow_up" href="#lib.shell.editor.Text.arrow_up">arrow_up</a></code></li>
<li><code><a title="lib.shell.editor.Text.backspace" href="#lib.shell.editor.Text.backspace">backspace</a></code></li>
<li><code><a title="lib.shell.editor.Text.bottom" href="#lib.shell.editor.Text.bottom">bottom</a></code></li>
<li><code><a title="lib.shell.editor.Text.change_case" href="#lib.shell.editor.Text.change_case">change_case</a></code></li>
<li><code><a title="lib.shell.editor.Text.change_column" href="#lib.shell.editor.Text.change_column">change_column</a></code></li>
<li><code><a title="lib.shell.editor.Text.change_line" href="#lib.shell.editor.Text.change_line">change_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.close_selection" href="#lib.shell.editor.Text.close_selection">close_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.comment" href="#lib.shell.editor.Text.comment">comment</a></code></li>
<li><code><a title="lib.shell.editor.Text.copy" href="#lib.shell.editor.Text.copy">copy</a></code></li>
<li><code><a title="lib.shell.editor.Text.copy_clipboard" href="#lib.shell.editor.Text.copy_clipboard">copy_clipboard</a></code></li>
<li><code><a title="lib.shell.editor.Text.cut" href="#lib.shell.editor.Text.cut">cut</a></code></li>
<li><code><a title="lib.shell.editor.Text.delete" href="#lib.shell.editor.Text.delete">delete</a></code></li>
<li><code><a title="lib.shell.editor.Text.delete_line" href="#lib.shell.editor.Text.delete_line">delete_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.end" href="#lib.shell.editor.Text.end">end</a></code></li>
<li><code><a title="lib.shell.editor.Text.find_next" href="#lib.shell.editor.Text.find_next">find_next</a></code></li>
<li><code><a title="lib.shell.editor.Text.find_previous" href="#lib.shell.editor.Text.find_previous">find_previous</a></code></li>
<li><code><a title="lib.shell.editor.Text.getFilename" href="#lib.shell.editor.Text.getFilename">getFilename</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_count_lines" href="#lib.shell.editor.Text.get_count_lines">get_count_lines</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_cursor_char" href="#lib.shell.editor.Text.get_cursor_char">get_cursor_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_cursor_line" href="#lib.shell.editor.Text.get_cursor_line">get_cursor_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_selection" href="#lib.shell.editor.Text.get_selection">get_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_tab_cursor" href="#lib.shell.editor.Text.get_tab_cursor">get_tab_cursor</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_tab_cursor_column" href="#lib.shell.editor.Text.get_tab_cursor_column">get_tab_cursor_column</a></code></li>
<li><code><a title="lib.shell.editor.Text.get_tab_line" href="#lib.shell.editor.Text.get_tab_line">get_tab_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.goto" href="#lib.shell.editor.Text.goto">goto</a></code></li>
<li><code><a title="lib.shell.editor.Text.hide_selection" href="#lib.shell.editor.Text.hide_selection">hide_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.home" href="#lib.shell.editor.Text.home">home</a></code></li>
<li><code><a title="lib.shell.editor.Text.indent" href="#lib.shell.editor.Text.indent">indent</a></code></li>
<li><code><a title="lib.shell.editor.Text.insert_char" href="#lib.shell.editor.Text.insert_char">insert_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.load" href="#lib.shell.editor.Text.load">load</a></code></li>
<li><code><a title="lib.shell.editor.Text.move_cursor" href="#lib.shell.editor.Text.move_cursor">move_cursor</a></code></li>
<li><code><a title="lib.shell.editor.Text.move_word" href="#lib.shell.editor.Text.move_word">move_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.new_line" href="#lib.shell.editor.Text.new_line">new_line</a></code></li>
<li><code><a title="lib.shell.editor.Text.next_word" href="#lib.shell.editor.Text.next_word">next_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.open_selection" href="#lib.shell.editor.Text.open_selection">open_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.page_down" href="#lib.shell.editor.Text.page_down">page_down</a></code></li>
<li><code><a title="lib.shell.editor.Text.page_up" href="#lib.shell.editor.Text.page_up">page_up</a></code></li>
<li><code><a title="lib.shell.editor.Text.paste" href="#lib.shell.editor.Text.paste">paste</a></code></li>
<li><code><a title="lib.shell.editor.Text.paste_clipboard" href="#lib.shell.editor.Text.paste_clipboard">paste_clipboard</a></code></li>
<li><code><a title="lib.shell.editor.Text.previous_word" href="#lib.shell.editor.Text.previous_word">previous_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.remove_selection" href="#lib.shell.editor.Text.remove_selection">remove_selection</a></code></li>
<li><code><a title="lib.shell.editor.Text.replace" href="#lib.shell.editor.Text.replace">replace</a></code></li>
<li><code><a title="lib.shell.editor.Text.replace_char" href="#lib.shell.editor.Text.replace_char">replace_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.save" href="#lib.shell.editor.Text.save">save</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_all" href="#lib.shell.editor.Text.select_all">select_all</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_bottom" href="#lib.shell.editor.Text.select_bottom">select_bottom</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_down" href="#lib.shell.editor.Text.select_down">select_down</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_end" href="#lib.shell.editor.Text.select_end">select_end</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_home" href="#lib.shell.editor.Text.select_home">select_home</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_left" href="#lib.shell.editor.Text.select_left">select_left</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_next_word" href="#lib.shell.editor.Text.select_next_word">select_next_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_page_down" href="#lib.shell.editor.Text.select_page_down">select_page_down</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_page_up" href="#lib.shell.editor.Text.select_page_up">select_page_up</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_previous_word" href="#lib.shell.editor.Text.select_previous_word">select_previous_word</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_right" href="#lib.shell.editor.Text.select_right">select_right</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_top" href="#lib.shell.editor.Text.select_top">select_top</a></code></li>
<li><code><a title="lib.shell.editor.Text.select_up" href="#lib.shell.editor.Text.select_up">select_up</a></code></li>
<li><code><a title="lib.shell.editor.Text.set_cursor_column" href="#lib.shell.editor.Text.set_cursor_column">set_cursor_column</a></code></li>
<li><code><a title="lib.shell.editor.Text.set_view" href="#lib.shell.editor.Text.set_view">set_view</a></code></li>
<li><code><a title="lib.shell.editor.Text.top" href="#lib.shell.editor.Text.top">top</a></code></li>
<li><code><a title="lib.shell.editor.Text.treat_char" href="#lib.shell.editor.Text.treat_char">treat_char</a></code></li>
<li><code><a title="lib.shell.editor.Text.treat_key" href="#lib.shell.editor.Text.treat_key">treat_key</a></code></li>
<li><code><a title="lib.shell.editor.Text.unindent" href="#lib.shell.editor.Text.unindent">unindent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.shell.editor.View" href="#lib.shell.editor.View">View</a></code></h4>
<ul class="">
<li><code><a title="lib.shell.editor.View.cls" href="#lib.shell.editor.View.cls">cls</a></code></li>
<li><code><a title="lib.shell.editor.View.cls_end_screen" href="#lib.shell.editor.View.cls_end_screen">cls_end_screen</a></code></li>
<li><code><a title="lib.shell.editor.View.colorize_none" href="#lib.shell.editor.View.colorize_none">colorize_none</a></code></li>
<li><code><a title="lib.shell.editor.View.colorize_syntax" href="#lib.shell.editor.View.colorize_syntax">colorize_syntax</a></code></li>
<li><code><a title="lib.shell.editor.View.flush" href="#lib.shell.editor.View.flush">flush</a></code></li>
<li><code><a title="lib.shell.editor.View.get_position" href="#lib.shell.editor.View.get_position">get_position</a></code></li>
<li><code><a title="lib.shell.editor.View.get_screen_position" href="#lib.shell.editor.View.get_screen_position">get_screen_position</a></code></li>
<li><code><a title="lib.shell.editor.View.get_screen_size" href="#lib.shell.editor.View.get_screen_size">get_screen_size</a></code></li>
<li><code><a title="lib.shell.editor.View.hide_selection" href="#lib.shell.editor.View.hide_selection">hide_selection</a></code></li>
<li><code><a title="lib.shell.editor.View.move" href="#lib.shell.editor.View.move">move</a></code></li>
<li><code><a title="lib.shell.editor.View.move_cursor" href="#lib.shell.editor.View.move_cursor">move_cursor</a></code></li>
<li><code><a title="lib.shell.editor.View.refresh" href="#lib.shell.editor.View.refresh">refresh</a></code></li>
<li><code><a title="lib.shell.editor.View.refresh_content" href="#lib.shell.editor.View.refresh_content">refresh_content</a></code></li>
<li><code><a title="lib.shell.editor.View.refresh_line" href="#lib.shell.editor.View.refresh_line">refresh_line</a></code></li>
<li><code><a title="lib.shell.editor.View.reset" href="#lib.shell.editor.View.reset">reset</a></code></li>
<li><code><a title="lib.shell.editor.View.reset_scroll_region" href="#lib.shell.editor.View.reset_scroll_region">reset_scroll_region</a></code></li>
<li><code><a title="lib.shell.editor.View.scroll_down" href="#lib.shell.editor.View.scroll_down">scroll_down</a></code></li>
<li><code><a title="lib.shell.editor.View.scroll_part_down" href="#lib.shell.editor.View.scroll_part_down">scroll_part_down</a></code></li>
<li><code><a title="lib.shell.editor.View.scroll_part_up" href="#lib.shell.editor.View.scroll_part_up">scroll_part_up</a></code></li>
<li><code><a title="lib.shell.editor.View.scroll_up" href="#lib.shell.editor.View.scroll_up">scroll_up</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_after" href="#lib.shell.editor.View.set_refresh_after">set_refresh_after</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_all" href="#lib.shell.editor.View.set_refresh_all">set_refresh_all</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_before" href="#lib.shell.editor.View.set_refresh_before">set_refresh_before</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_bottom" href="#lib.shell.editor.View.set_refresh_bottom">set_refresh_bottom</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_line" href="#lib.shell.editor.View.set_refresh_line">set_refresh_line</a></code></li>
<li><code><a title="lib.shell.editor.View.set_refresh_selection" href="#lib.shell.editor.View.set_refresh_selection">set_refresh_selection</a></code></li>
<li><code><a title="lib.shell.editor.View.set_scrolling_region" href="#lib.shell.editor.View.set_scrolling_region">set_scrolling_region</a></code></li>
<li><code><a title="lib.shell.editor.View.set_text" href="#lib.shell.editor.View.set_text">set_text</a></code></li>
<li><code><a title="lib.shell.editor.View.show_line" href="#lib.shell.editor.View.show_line">show_line</a></code></li>
<li><code><a title="lib.shell.editor.View.write_byte" href="#lib.shell.editor.View.write_byte">write_byte</a></code></li>
<li><code><a title="lib.shell.editor.View.write_string" href="#lib.shell.editor.View.write_string">write_string</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>