<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lib.shell.editor API documentation</title>
<meta name="description" content="Class defining a VT100 text editor.
This editor works directly in the board.
This allows you to make quick and easy changes directly on the board, â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.shell.editor</code></h1>
</header>
<section id="section-intro">
<p>Class defining a VT100 text editor.
This editor works directly in the board.
This allows you to make quick and easy changes directly on the board, without having to use synchronization tools.
This editor allows script execution, and displays errors and execution time.</p>
<p>Editor shortcuts :
<br> - <b>Exit
</b>: Escape
<br> - <b>Move cursor
</b>: Arrows, Home, End, PageUp, PageDown, Ctrl-Home, Ctrl-End, Ctrl-Left, Ctrl-Right
<br> - <b>Selection
</b>: Shift-Arrows, Shift-Home, Shift-End, Alt-Shift-Arrows, Ctrl-Shift-Left, Ctrl-Shift-Right
<br> - <b>Clipboard
</b>: Selection with Ctrl X(Cut), Ctrl-C(Copy), Ctrl-V(Paste)
<br> - <b>Case change
</b>: Selection with Ctrl-U(Toggle majuscule, minuscule)
<br> - <b>Indent
</b>: Selection with Tab(Indent) or Shift-Tab(Unindent)
<br> - <b>Comment block </b>: Selection with Ctrl-Q
<br> - <b>Save
</b>: Ctrl-S
<br> - <b>Find
</b>: Ctrl-F
<br> - <b>Replace
</b>: Ctrl-H
<br> - <b>Toggle mode
</b>: Ctrl-T (Insertion/Replacement)
<br> - <b>Delete line
</b>: Ctrl-L
<br> - <b>Goto line
</b>: Ctrl-G
<br> - <b>Execute
</b>: F5</p>
<p>This editor also works on linux and osx, and can also be used autonomously,
you need to add the useful.py script to its side.
All the keyboard shortcuts are at the start of the script.</p>
<p>On the boards with low memory, it may work, but on very small files, otherwise it may produce an error due to insufficient memory.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python3
# Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
&#34;&#34;&#34; Class defining a VT100 text editor.
This editor works directly in the board. 
This allows you to make quick and easy changes directly on the board, without having to use synchronization tools. 
This editor allows script execution, and displays errors and execution time.

Editor shortcuts : 
&lt;br&gt; - &lt;b&gt;Exit          &lt;/b&gt;: Escape
&lt;br&gt; - &lt;b&gt;Move cursor   &lt;/b&gt;: Arrows, Home, End, PageUp, PageDown, Ctrl-Home, Ctrl-End, Ctrl-Left, Ctrl-Right
&lt;br&gt; - &lt;b&gt;Selection     &lt;/b&gt;: Shift-Arrows, Shift-Home, Shift-End, Alt-Shift-Arrows, Ctrl-Shift-Left, Ctrl-Shift-Right
&lt;br&gt; - &lt;b&gt;Clipboard     &lt;/b&gt;: Selection with Ctrl X(Cut), Ctrl-C(Copy), Ctrl-V(Paste)
&lt;br&gt; - &lt;b&gt;Case change   &lt;/b&gt;: Selection with Ctrl-U(Toggle majuscule, minuscule)
&lt;br&gt; - &lt;b&gt;Indent        &lt;/b&gt;: Selection with Tab(Indent) or Shift-Tab(Unindent)
&lt;br&gt; - &lt;b&gt;Comment block &lt;/b&gt;: Selection with Ctrl-Q
&lt;br&gt; - &lt;b&gt;Save          &lt;/b&gt;: Ctrl-S
&lt;br&gt; - &lt;b&gt;Find          &lt;/b&gt;: Ctrl-F
&lt;br&gt; - &lt;b&gt;Replace       &lt;/b&gt;: Ctrl-H
&lt;br&gt; - &lt;b&gt;Toggle mode   &lt;/b&gt;: Ctrl-T (Insertion/Replacement)
&lt;br&gt; - &lt;b&gt;Delete line   &lt;/b&gt;: Ctrl-L
&lt;br&gt; - &lt;b&gt;Goto line     &lt;/b&gt;: Ctrl-G
&lt;br&gt; - &lt;b&gt;Execute       &lt;/b&gt;: F5

This editor also works on linux and osx, and can also be used autonomously,
you need to add the useful.py script to its side. 
All the keyboard shortcuts are at the start of the script.

On the boards with low memory, it may work, but on very small files, otherwise it may produce an error due to insufficient memory.
&#34;&#34;&#34;
import sys
sys.path.append(&#34;lib&#34;)
try:
        from tools import useful
except:
        import useful

TABSIZE = 4          # Tabulation size
HORIZONTAL_MOVE=8    # Scrolling minimal deplacement

ESCAPE           = &#34;\x1B&#34; 

# Move shortcuts
UP               = [&#34;\x1B[A&#34;]
DOWN             = [&#34;\x1B[B&#34;]
RIGHT            = [&#34;\x1B[C&#34;]
LEFT             = [&#34;\x1B[D&#34;]
HOME             = [&#34;\x1B[1;3D&#34;, &#34;\x1B[H&#34;, &#34;\x1B\x1B[D&#34;, &#34;\x1B[1~&#34;, &#34;\x1Bb&#34;]
END              = [&#34;\x1B[1;3C&#34;, &#34;\x1B[F&#34;, &#34;\x1B\x1B[C&#34;, &#34;\x1B[4~&#34;, &#34;\x1Bf&#34;]
PAGE_UP          = [&#34;\x1B[1;3A&#34;, &#34;\x1B[A&#34;, &#34;\x1B\x1B[A&#34;, &#34;\x1B[5~&#34;]
PAGE_DOWN        = [&#34;\x1B[1;3B&#34;, &#34;\x1B[B&#34;, &#34;\x1B\x1B[B&#34;, &#34;\x1B[6~&#34;]
TOP              = [&#34;\x1B[1;5H&#34;]
BOTTOM           = [&#34;\x1B[1;5F&#34;]
NEXT_WORD        = [&#34;\x1B[1;5C&#34;]
PREVIOUS_WORD    = [&#34;\x1B[1;5D&#34;]

# Selection shortcuts
SELECT_UP        = [&#34;\x1B[1;2A&#34;]
SELECT_DOWN      = [&#34;\x1B[1;2B&#34;]
SELECT_RIGHT     = [&#34;\x1B[1;2C&#34;]
SELECT_LEFT      = [&#34;\x1B[1;2D&#34;]
SELECT_PAGE_UP   = [&#34;\x1B[1;10A&#34;,&#34;\x1B[1;4A&#34;]
SELECT_PAGE_DOWN = [&#34;\x1B[1;10B&#34;,&#34;\x1B[1;4B&#34;]
SELECT_HOME      = [&#34;\x1B[1;2H&#34;,&#34;\x1B[1;10D&#34;]
SELECT_END       = [&#34;\x1B[1;2F&#34;,&#34;\x1B[1;10C&#34;]
SELECT_ALL       = [&#34;\x01&#34;]
SELECT_NEXT_WORD = [&#34;\x1B[1;6C&#34;,&#34;\x1B[1;4C&#34;]
SELECT_PREV_WORD = [&#34;\x1B[1;6D&#34;,&#34;\x1B[1;4D&#34;]

# Clipboard shortcuts
CUT              = [&#34;\x18&#34;,&#34;\x1Bx&#34;]                      # Cut
COPY             = [&#34;\x03&#34;,&#34;\x1Bc&#34;]                      # Copy
PASTE            = [&#34;\x16&#34;,&#34;\x1Bv&#34;]                      # Paste

# Selection modification shortcut
INDENT           = [&#34;\t&#34;]                                # Indent
UNINDENT         = [&#34;\x1B[Z&#34;]                            # Unindent
CHANGE_CASE      = [&#34;\x15&#34;]                              # Change case
COMMENT          = [&#34;\x11&#34;]                              # Comment block

DELETE           = [&#34;\x1B[3~&#34;]                           # Delete pressed
BACKSPACE        = [&#34;\x7F&#34;]                              # Backspace pressed
NEW_LINE         = [&#34;\n&#34;, &#34;\r&#34;]                          # New line pressed

TOGGLE_MODE      = [&#34;\x14&#34;]                              # Toggle replace/insert mode
EXIT             = [ESCAPE]                              # Exit
FIND             = [&#34;\x06&#34;]                              # Find
FIND_NEXT        = [&#34;\x1bOR&#34;]                            # Find next
FIND_PREVIOUS    = [&#34;\x1b[1;2R&#34;]                         # Find previous
GOTO             = [&#34;\x07&#34;]                              # Goto line
SAVE             = [&#34;\x13&#34;,&#34;\x1Bs&#34;]                      # Save
DELETE_LINE      = [&#34;\x0C&#34;]                              # Delete line
REPLACE          = [&#34;\x08&#34;]                              # Replace
REPLACE_CURRENT  = [&#34;\x12&#34;]                              # Replace the selection
EXECUTE          = [&#34;\x1B[15~&#34;]                          # Execute script

class View:
        &#34;&#34;&#34; Class which manage the view of the edit field &#34;&#34;&#34;
        def __init__(self, viewHeight, viewTop):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.line     = 0
                self.column   = 0
                if viewHeight == None:
                        self.height   = 20
                else:
                        self.height          = viewHeight
                self.width               = 80
                self.top                 = viewTop
                self.isRefreshAll        = True
                self.isRefreshLine       = False
                self.isRefreshLineBefore = False
                self.isRefreshLineAfter  = False
                self.refreshPart         = None
                self.text                = None
                self.tabCursorColumn     = 0
                self.selLineStart        = None
                self.selLineEnd          = None

        def write(self, data):
                &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
                sys.stdout.write(data)

        def flush(self):
                &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
                try:
                        sys.stdout.flush()
                except:
                        pass

        def setText(self, text):
                &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
                self.text = text

        def getScreenPosition(self):
                &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
                return (self.text.getCursorLine() - self.line + self.top, self.tabCursorColumn - self.column)

        def reset(self):
                &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
                self.write(&#34;\x1b&#34;&#34;c&#34;)
                self.flush()

        def resetScrollRegion(self):
                &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
                if self.screenHeight &gt; 0:
                        self.setScrollingRegion(0, self.screenHeight-1)

        def setScrollingRegion(self, topLine, bottomLine):
                &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
                if topLine &lt; bottomLine:
                        self.write(&#34;\x1B[%d;%dr&#34;%(topLine+1,bottomLine+1))

        def scrollUp(self):
                &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
                self.setScrollingRegion(self.top, self.height+1)
                self.write(&#34;\x1B[1S&#34;)

        def scrollDown(self):
                &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
                self.setScrollingRegion(self.top, self.height+1)
                self.write(&#34;\x1B[1T&#34;)

        def scrollPartUp(self):
                &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
                line, column = self.getScreenPosition()
                if line &lt; self.height:
                        self.setScrollingRegion(line, self.height+1)
                        self.write(&#34;\x1B[1S&#34;)

        def scrollPartDown(self):
                &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
                line, column = self.getScreenPosition()
                if line &lt; self.height:
                        self.setScrollingRegion(line+1, self.height+1)
                        self.write(&#34;\x1B[1T&#34;)
                else:
                        self.isRefreshLineAfter = True

        def move(self):
                &#34;&#34;&#34; Move the view &#34;&#34;&#34;
                self.tabCursorColumn = self.text.getTabCursor(self.text.getCursorLine())
                # Move view port
                if self.tabCursorColumn &lt; self.column:
                        self.isRefreshAll = True
                        if self.tabCursorColumn &gt; HORIZONTAL_MOVE:
                                self.column = self.tabCursorColumn-HORIZONTAL_MOVE
                        else:
                                self.column = 0
                elif self.tabCursorColumn &gt;= self.column + self.width:
                        self.column = self.tabCursorColumn-self.width+HORIZONTAL_MOVE
                        self.isRefreshAll = True
                if self.text.getCursorLine() &lt; self.line:
                        delta = self.line - self.text.getCursorLine()
                        self.line = self.text.getCursorLine()
                        if self.line &lt; 0:
                                self.line = 0
                        if delta == 1:
                                self.scrollDown()
                                self.isRefreshLine = True
                        else:
                                self.isRefreshAll = True
                elif self.text.getCursorLine() &gt; self.line + self.height:
                        delta =  self.text.getCursorLine() - self.line - self.height
                        self.line = self.text.getCursorLine()-self.height
                        if delta == 1:
                                self.scrollUp()
                                self.isRefreshLine = True
                        else:
                                self.isRefreshAll = True

        def setRefreshLine(self):
                &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
                self.isRefreshLine = True

        def setRefreshAfter(self):
                &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
                self.isRefreshLine = True
                self.isRefreshLineAfter = True

        def setRefreshBefore(self):
                &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
                self.isRefreshLine = True
                self.isRefreshLineBefore = True

        def setRefreshAll(self):
                &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
                self.isRefreshAll = True

        def showLine(self, currentLine, screenLine, selectionStart, selectionEnd):
                &#34;&#34;&#34; Show one line &#34;&#34;&#34;
                self.moveCursor(screenLine, 0)
                self.write(&#34;\x1B[K&#34;)
                if currentLine &lt; self.text.getCountLines() and currentLine &gt;= 0:
                        line = self.text.getTabLine(currentLine)
                        partLine = line[self.column:self.column+self.width]
                        # If the line selected
                        if selectionStart != None:
                                # If the line not empty
                                if len(partLine) &gt;= 1:
                                        # If the line have carriage return at the end
                                        if partLine[-1] == &#34;\n&#34;:
                                                # Remove the carriage return
                                                partLine = partLine[:-1]
                                if len(partLine) &gt; 0:
                                        dummy, selLineStart, selColumnStart = selectionStart
                                        dummy, selLineEnd,   selColumnEnd   = selectionEnd
                                        # If the current line is the end of selection
                                        if currentLine == selLineEnd:
                                                # If the end of selection is outside the visible part
                                                if selColumnEnd - self.column &lt; 0:
                                                        selColumnEnd = 0
                                                else:
                                                        selColumnEnd -= self.column

                                                # If the start of selection is on the previous lines
                                                if selLineStart &lt; selLineEnd:
                                                        # Select the start of line
                                                        partLine = &#34;\x1B[7m&#34; + partLine[:selColumnEnd] + &#34;\x1B[m&#34; + partLine[selColumnEnd:]
                                                else:
                                                        # Unselect the end of line
                                                        partLine = partLine[:selColumnEnd] + &#34;\x1B[m&#34; + partLine[selColumnEnd:]
                                        # If the current line is the start of selection
                                        if currentLine == selLineStart:
                                                # If the start of selection is outside the visible part
                                                if selColumnStart - self.column &lt; 0:
                                                        selColumnStart = 0
                                                else:
                                                        selColumnStart -= self.column

                                                # If the end of selection is on the next lines
                                                if selLineStart &lt; selLineEnd:
                                                        # Select the end of line
                                                        partLine = partLine[:selColumnStart] + &#34;\x1B[7m&#34; + partLine[selColumnStart:] + &#34;\x1B[m&#34;
                                                else:
                                                        # Select the start of line
                                                        partLine = partLine[:selColumnStart] + &#34;\x1B[7m&#34; + partLine[selColumnStart:] 
                                        # If the line is completly selected
                                        if currentLine &gt; selLineStart and currentLine &lt; selLineEnd:
                                                # Select all the line
                                                partLine = &#34;\x1B[7m&#34; + partLine + &#34;\x1B[m&#34;
                                else:
                                        partLine = &#34;&#34;
                                self.write(partLine)
                        else:
                                self.write(partLine.rstrip())

        def refreshLine(self, selectionStart, selectionEnd):
                &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
                screenLine,     screenColumn = self.getScreenPosition()
                refreshed = False

                # If the line must be refreshed before the cursor line
                if self.isRefreshLineBefore:
                        self.isRefreshLineBefore = False
                        self.showLine(self.text.getCursorLine()-1, screenLine-1, selectionStart, selectionEnd)
                        refreshed = True
                # If the line must be refreshed after the cursor line
                if self.isRefreshLineAfter:
                        self.isRefreshLineAfter = False
                        self.showLine(self.text.getCursorLine()+1, screenLine+1, selectionStart, selectionEnd)
                        offset = self.height - screenLine
                        self.showLine(self.text.getCursorLine()+offset+1, screenLine+offset+1, selectionStart, selectionEnd)
                        refreshed = True
                # If only the cursor line must be refresh
                if self.isRefreshLine:
                        self.isRefreshLine = False
                        self.showLine(self.text.getCursorLine(), screenLine, selectionStart, selectionEnd)
                        refreshed = True

                # If no refresh detected and a selection started
                if selectionStart != None and refreshed == False:
                        # Refresh the selection
                        self.showLine(self.text.getCursorLine(), screenLine, selectionStart, selectionEnd)

        def refresh(self):
                &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
                selectionStart, selectionEnd = self.text.getSelection()
                if self.refreshPart != None:
                        self.refreshContent(selectionStart, selectionEnd, self.refreshPart)
                        self.refreshPart = None
                # Refresh all required
                if self.isRefreshAll:
                        self.refreshContent(selectionStart, selectionEnd, True)
                        self.isRefreshAll  = False
                        self.isRefreshLine = False
                else:
                        # If no selection activated
                        if selectionStart == None:
                                # Refresh the current line
                                self.refreshLine(selectionStart, selectionEnd)
                        else:
                                # Refresh the selection
                                self.refreshContent(selectionStart, selectionEnd, False)
                self.moveCursor()
                self.flush()

        def refreshContent(self, selectionStart, selectionEnd, all):
                &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
                # If selection present
                if selectionStart != None:
                        # Get the selection
                        dummy, selLineStart, selColumnStart = selectionStart
                        dummy, selLineEnd,   selColumnEnd   = selectionEnd
                        lineStart = selLineStart
                        lineEnd   = selLineEnd
                        # The aim of this part is to limit the refresh area
                        # If the precedent display show a selection
                        if self.selLineEnd != None and self.selLineStart != None:
                                # If the start and end of selection is on the sames lines
                                if self.selLineEnd == selLineEnd and self.selLineStart == selLineStart:
                                        lineStart = lineEnd = self.text.getCursorLine()
                                else:
                                        # If the end of selection is after the precedent display
                                        if self.selLineEnd &gt; selLineEnd:
                                                lineEnd = self.selLineEnd
                                        # If the end of selection is on the same line than the precedent display
                                        elif self.selLineEnd == selLineEnd:
                                                # If the start of selection is before the precedent display
                                                if self.selLineStart &lt; selLineStart:
                                                        lineEnd = selLineStart
                                                else:
                                                        lineEnd = self.selLineStart
                                        # If the start of selection is before the precedent display
                                        if self.selLineStart &lt; selLineStart:
                                                lineStart = self.selLineStart
                                        # If the start of selection is on the same line than the precedent display
                                        elif self.selLineStart == selLineStart:
                                                # If the end of selection is after the precedent display
                                                if self.selLineEnd &gt; selLineEnd:
                                                        lineStart = selLineEnd
                                                else:
                                                        lineStart = self.selLineEnd
                else:
                        lineStart = 0
                        lineEnd = self.line + self.height
                currentLine = self.line
                screenLine = self.top
                if type(all) == type([]):
                        lineStart, lineEnd = all
                        all = False
                # Refresh all lines visible
                while currentLine &lt; self.text.getCountLines() and currentLine &lt;= self.line + self.height:
                        # If the line is in selection or all must be refreshed
                        if lineStart &lt;= currentLine &lt;= lineEnd or all:
                                self.showLine(currentLine, screenLine, selectionStart, selectionEnd)
                        screenLine  += 1
                        currentLine += 1
                if all == True:
                        # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                        while currentLine &lt;= self.line + self.height:
                                self.moveCursor(screenLine, 0)
                                self.write(&#34;\x1B[K&#34;)
                                screenLine  += 1
                                currentLine += 1
                # If selection present
                if selectionStart != None:
                        # Save current selection
                        dummy, self.selLineStart, dummy = selectionStart
                        dummy, self.selLineEnd,   dummy   = selectionEnd

        def hideSelection(self):
                &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
                selectionStart, selectionEnd = self.text.getSelection()
                if selectionStart != None:
                        self.setRefreshSelection()
                        self.selLineStart = None
                        self.selLineEnd   = None

        def setRefreshSelection(self):
                &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
                selectionStart, selectionEnd = self.text.getSelection()
                if selectionStart != None:
                        # self.isRefreshAll = True
                        lineStart = selectionStart[1]
                        if self.selLineStart &lt; lineStart:
                                lineStart = self.selLineStart
                        lineEnd = selectionEnd[1]
                        if self.selLineEnd &gt; lineEnd:
                                lineEnd = self.selLineEnd
                        self.refreshPart = [lineStart, lineEnd]

        def moveCursor(self, screenLine=None, screenColumn=None):
                &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
                if screenLine == None and screenColumn == None:
                        screenLine, screenColumn = self.getScreenPosition()
                self.write(&#34;\x1B[%d;%df&#34;%(screenLine+1,screenColumn+1))

        def getScreenSize(self):
                &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
                height, width = useful.getScreenSize()
                self.screenHeight = height
                self.screenWidth = width
                self.height = height-self.top-1
                self.width  = width
                self.moveCursor()

        def cls(self):
                &#34;&#34;&#34; Clear the screen &#34;&#34;&#34;
                self.write(&#34;\x1B[2J&#34;)
                self.moveCursor(0,0)

class Text:
        &#34;&#34;&#34; Class which manage the text edition &#34;&#34;&#34;
        def __init__(self, readOnly=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.lines = [&#34;&#34;]
                self.cursorLine   = 0
                self.cursorColumn = 0
                self.tabCursorColumn   = 0
                self.modified     = False
                self.replaceMode  = False
                self.readOnly     = readOnly
                self.view         = None
                self.tabSize      = TABSIZE
                self.selectionStart = None
                self.selectionEnd   = None
                self.selection = []

        def setView(self, view):
                &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
                self.view = view

        def getCountLines(self):
                &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
                return len(self.lines)

        def getCursorLine(self):
                &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
                return self.cursorLine

        def getTabCursor(self, currentLine, currentColumn=None):
                &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
                if currentColumn == None:
                        cursorColumn = self.cursorColumn
                else:
                        cursorColumn = currentColumn
                line = self.lines[currentLine]
                if &#34;\t&#34; in line:
                        tabCursorColumn   = 0
                        column = 0
                        for char in line:
                                if column == cursorColumn:
                                        break
                                if char == &#34;\t&#34;:
                                        pos = tabCursorColumn%self.tabSize
                                        tabCursorColumn += self.tabSize-pos
                                else:
                                        tabCursorColumn += 1
                                column += 1
                        return tabCursorColumn
                else:
                        return cursorColumn

        def getTabLine(self, currentLine = None):
                &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
                line = self.lines[currentLine]
                tabLine = &#34;&#34;
                tabCursorColumn   = 0
                lenLine = len(line)
                column = 0
                while column &lt; lenLine: 
                        char = line[column]
                        if char == &#34;\t&#34;:
                                pos = tabCursorColumn%self.tabSize
                                tabCursorColumn += self.tabSize-pos
                                tabLine         += &#34; &#34;*(self.tabSize-pos)
                                column          += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        part = line[column:tab]
                                else:
                                        part = line[column:]
                                tabCursorColumn += len(part)
                                tabLine         += part
                                column          += len(part)
                return tabLine

        def getTabCursorColumn(self):
                &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
                line = self.lines[self.cursorLine]
                column = 0
                self.tabCursorColumn = 0
                while column &lt; self.cursorColumn:
                        if line[column] == &#34;\t&#34;:
                                pos = self.tabCursorColumn%self.tabSize
                                self.tabCursorColumn += self.tabSize-pos
                                column += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        delta = tab - column
                                        if column + delta &gt; self.cursorColumn:
                                                delta = self.cursorColumn - column
                                                self.tabCursorColumn += delta
                                                column += delta
                                        else:
                                                self.tabCursorColumn += delta
                                                column += delta
                                else:
                                        delta = self.cursorColumn - column
                                        self.tabCursorColumn += delta
                                        column += delta

        def setCursorColumn(self):
                &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
                line = self.lines[self.cursorLine]
                column = 0
                tabCursorColumn = 0
                lenLine = len(line)
                column = 0
                while column &lt; lenLine: 
                        char = line[column]
                        # If the previous position found exactly in the current line
                        if tabCursorColumn == self.tabCursorColumn:
                                self.cursorColumn = column
                                break
                        # If the previous position not found in the current line
                        if tabCursorColumn &gt; self.tabCursorColumn:
                                # Keep last existing position
                                self.cursorColumn = column
                                break
                        # If tabulation found
                        if char == &#34;\t&#34;:
                                tabCursorColumn += self.tabSize-(tabCursorColumn%self.tabSize)
                                column += 1
                        else:
                                # Optimization to accelerate the cursor position
                                tab = line.find(&#34;\t&#34;, column)

                                # Tabulation found
                                if tab &gt; 0:
                                        delta = tab - column
                                        # If the tabulation position is after the previous tabulation cursor
                                        if delta + tabCursorColumn &gt; self.tabCursorColumn:
                                                # Move the cursor to the left
                                                self.cursorColumn = column + (self.tabCursorColumn - tabCursorColumn)
                                                break
                                        else:
                                                # Another tabulation found, move it after
                                                tabCursorColumn += delta
                                                column += delta
                                # Tabulation not found
                                else:
                                        # Move the cursor to the end of line
                                        self.cursorColumn = column + (self.tabCursorColumn - tabCursorColumn)
                                        break
                else:
                        if len(line) &gt;= 1:
                                self.cursorColumn = len(line)-1
                        else:
                                self.cursorColumn = 0

        def load(self, filename):
                &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
                self.filename = None
                try:
                        self.lines = []
                        self.filename = filename
                        file = open(filename, &#34;r&#34;)
                        line = file.readline()
                        while line != &#34;&#34;:
                                self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                                line = file.readline()
                        file.close()
                        if len(self.lines) == 0:
                                self.lines = [&#34;&#34;]
                except MemoryError:
                        raise MemoryError()
                except OSError:
                        self.lines = [&#34;&#34;]
                        # File not existing
                except Exception as error:
                        print(useful.exception(error))
                        self.lines = [&#34;&#34;]

        def save(self):
                &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
                result = False
                if self.readOnly == False:
                        if self.filename != None:
                                try:
                                        file = open(self.filename, &#34;w&#34;)
                                        for line in self.lines:
                                                file.write(line)
                                        file.close()
                                        self.modified = False
                                        result = True
                                except Exception as error:
                                        print(useful.exception(error))
                return result

        def changeLine(self, moveLine):
                &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
                # If cursor is before the first line
                if moveLine + self.cursorLine &lt; 0:
                        # Set the cursor to the first line
                        self.cursorLine = 0
                        self.setCursorColumn()
                        self.changeColumn(0)
                # If the cursor is after the last line
                elif moveLine + self.cursorLine &gt;= len(self.lines):
                        self.cursorLine = len(self.lines) -1
                        self.setCursorColumn()
                        self.changeColumn(0)
                # else the cursor is in the lines of text
                else:
                        previousLine = self.cursorLine
                        self.cursorLine += moveLine
                        lenLine = len(self.lines[self.cursorLine])-1

                        self.setCursorColumn()
                        # If the new cursor position is outside the last line of text
                        if self.cursorColumn &gt; lenLine:
                                self.cursorColumn = lenLine

                if self.selectionStart != None:
                        self.selectionEnd = [self.cursorColumn, self.cursorLine,self.getTabCursor(self.cursorLine)]
                self.view.move()

        def changeColumn(self, moveColumn):
                &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
                cursorLine   = self.cursorLine
                cursorColumn = self.cursorColumn
                # If the cursor go to the previous line
                if moveColumn + self.cursorColumn &lt; 0:
                        # If start of line
                        if abs(moveColumn) &gt; 1:
                                self.cursorColumn = 0
                        # If move to the left and must go to previous line
                        elif self.cursorLine &gt; 0:
                                self.cursorLine -= 1
                                self.cursorColumn = len(self.lines[self.cursorLine])-1
                # If the cursor is at the end of line
                elif moveColumn + self.cursorColumn &gt; len(self.lines[self.cursorLine])-1:
                        # If the cursor is on the last line of file
                        if abs(moveColumn) &gt; 1 or self.cursorLine+1 == len(self.lines):
                                # If the file is empty
                                if self.lines[self.cursorLine] == &#34;&#34;:
                                        self.cursorColumn = 0
                                        self.tabCursorColumn = 0
                                # If the last line of contains return char
                                elif self.lines[self.cursorLine][-1] == &#34;\n&#34;:
                                        # Move cursor before return
                                        self.cursorColumn = len(self.lines[self.cursorLine])-1
                                else:
                                        # Move cursor after the last char
                                        self.cursorColumn = len(self.lines[self.cursorLine])

                        # If the cursor is on the end of line and must change of line
                        elif self.cursorLine+1 &lt; len(self.lines):
                                self.cursorLine += 1
                                self.cursorColumn = 0
                                self.tabCursorColumn = 0
                # Normal move of cursor
                else:
                        # Next or previous column
                        self.cursorColumn += moveColumn
                if abs(moveColumn) &gt; 0:
                        self.getTabCursorColumn()
                self.closeSelection()
                self.view.move()
                if self.cursorColumn == cursorColumn and self.cursorLine == cursorLine:
                        return False
                else:
                        return True

        def backspace(self):
                &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
                self.modified = True
                if self.removeSelection() == False:
                        # The cursor not in the begining of line
                        if self.cursorColumn &gt;= 1:
                                line = self.lines[self.cursorLine]
                                line = line[0:self.cursorColumn-1:]+ line[self.cursorColumn  : :]
                                self.lines[self.cursorLine] = line
                                self.changeColumn(-1)
                                self.view.setRefreshLine()
                        # The cursor is on the begining of line
                        else:
                                # If the cursor not on the first line
                                if self.cursorLine &gt;= 1:
                                        # Copy the current line to the end of previous line
                                        self.cursorColumn = len(self.lines[self.cursorLine-1])
                                        self.lines[self.cursorLine-1] = self.lines[self.cursorLine-1][:-1] + self.lines[self.cursorLine]
                                        del self.lines[self.cursorLine]
                                        self.view.scrollPartUp()
                                        self.cursorLine -= 1
                                        self.view.setRefreshAfter()
                                        self.changeColumn(-1)

        def delete(self):
                &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
                self.modified = True
                if self.removeSelection() == False:
                        line = self.lines[self.cursorLine]
                        if self.cursorColumn &lt; len(line):
                                # If the line is empty
                                if line[self.cursorColumn] == &#34;\n&#34;:
                                        # If the cursor not at end of files
                                        if self.cursorLine &lt; len(self.lines)-1:
                                                # Copy the next line to the current line
                                                self.lines[self.cursorLine] = line[:self.cursorColumn] + self.lines[self.cursorLine+1]
                                                del self.lines[self.cursorLine+1]
                                                self.view.scrollPartUp()
                                                self.view.setRefreshAfter()
                                # Else the char is deleted in the middle of line
                                else:
                                        line = line[0:self.cursorColumn:]+ line[self.cursorColumn+1  : :]
                                        self.lines[self.cursorLine] = line
                                        self.changeColumn(0)
                                        self.view.isRefreshLine = True

        def deleteLine(self):
                &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
                self.hideSelection()
                self.modified = True
                # If file contains one or none line
                if len(self.lines) &lt;= 1:
                        # Clean the content of file
                        self.lines = [&#34;&#34;]
                        self.cursorColumn = 0
                        self.cursorLine = 0
                        self.changeColumn(0)
                # If the current line is not the last of file
                elif self.cursorLine &lt; len(self.lines):
                        # Delete the line
                        self.cursorColumn = 0
                        del self.lines[self.cursorLine]
                        self.view.scrollPartUp()
                        if self.cursorLine &gt;= len(self.lines):
                                self.cursorLine = len(self.lines)-1
                        self.changeColumn(0)
                self.view.setRefreshAfter()

        def newLine(self):
                &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
                self.modified = True
                if self.removeSelection() == False:
                        line1 = self.lines[self.cursorLine][:self.cursorColumn]+&#34;\n&#34;
                        line2 = self.lines[self.cursorLine][self.cursorColumn:]
                        self.lines[self.cursorLine]=line1
                        self.lines.insert(self.cursorLine+1, line2)
                        self.view.scrollPartDown()
                        self.changeColumn(1)
                        self.view.setRefreshBefore()

        def insertChar(self, char):
                &#34;&#34;&#34; Insert character &#34;&#34;&#34;
                self.modified = True
                self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char + self.lines[self.cursorLine][self.cursorColumn:]
                self.changeColumn(1)
                self.view.setRefreshLine()

        def replaceChar(self, char):
                &#34;&#34;&#34; Replace character &#34;&#34;&#34;
                self.modified = True
                if self.cursorLine == len(self.lines)-1 and self.cursorColumn &gt;= len(self.lines[self.cursorLine])-1:
                        self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char 
                        self.changeColumn(1)
                        self.view.setRefreshLine()
                # If it is the last char in the line
                elif self.lines[self.cursorLine][self.cursorColumn] == &#34;\n&#34;:
                        # Append char to the line
                        self.insertChar(char)
                # Else the char must be replaced in the line
                else:
                        self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char + self.lines[self.cursorLine][self.cursorColumn+1:]
                        self.changeColumn(1)
                        self.view.setRefreshLine()

        def openSelection(self):
                &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
                if self.selectionStart == None:
                        self.selectionStart = [self.cursorColumn, self.cursorLine, self.getTabCursor(self.cursorLine)]

        def closeSelection(self):
                &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
                if self.selectionStart != None:
                        self.selectionEnd = [self.cursorColumn, self.cursorLine,self.getTabCursor(self.cursorLine)]

        def selectAll(self):
                &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
                self.selectionStart = [0,0,0]
                lastLine = len(self.lines)-1
                lastColumn = len(self.lines[lastLine])-1
                self.moveCursor(lastLine, lastColumn)
                self.selectionEnd  = [lastColumn, lastLine, self.getTabCursor(lastLine, lastColumn)]
                self.view.setRefreshAll()

        def getSelection(self):
                &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
                if self.selectionStart:
                        if self.selectionStart[1] &gt; self.selectionEnd[1]:
                                return self.selectionEnd, self.selectionStart
                        elif self.selectionStart[1] &lt; self.selectionEnd[1]:
                                return self.selectionStart, self.selectionEnd
                        elif self.selectionStart[0] &lt; self.selectionEnd[0]:
                                return self.selectionStart, self.selectionEnd
                        else:
                                return self.selectionEnd, self.selectionStart
                else:
                        return None, None

        def arrowUp(self, keys):
                &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
                self.hideSelection()
                self.changeLine(-len(keys))
        
        def arrowDown(self, keys):
                &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
                self.hideSelection()
                self.changeLine(len(keys))

        def arrowLeft(self, keys):
                &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
                self.hideSelection()
                self.changeColumn(-len(keys))

        def arrowRight(self, keys):
                &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
                self.hideSelection()
                self.changeColumn(len(keys))

        def selectUp(self, keys):
                &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
                self.openSelection()
                self.changeLine(-len(keys))
        
        def selectDown(self, keys):
                &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
                self.openSelection()
                self.changeLine(len(keys))

        def selectLeft(self, keys):
                &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
                self.openSelection()
                self.changeColumn(-len(keys))

        def selectRight(self, keys):
                &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
                self.openSelection()
                self.changeColumn(len(keys))

        def selectHome(self):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.openSelection()
                self.changeColumn(-100000000000)

        def selectEnd(self):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.openSelection()
                self.changeColumn(100000000000)

        def selectPageUp(self, keys):
                &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
                self.openSelection()
                self.changeLine((-self.view.height-1) * len(keys))
                self.changeColumn(-100000000000)

        def selectPageDown(self, keys):
                &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
                self.openSelection()
                self.changeLine((self.view.height+1) * len(keys))
                self.changeColumn(100000000000)

        def selectNextWord(self):
                &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
                self.openSelection()
                self.moveWord(1)

        def selectPreviousWord(self):
                &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
                self.openSelection()
                self.moveWord(-1)

        def pageUp(self, keys):
                &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
                self.hideSelection()
                self.changeLine((-self.view.height-1) * len(keys))

        def pageDown(self, keys):
                &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
                self.hideSelection()
                self.changeLine((self.view.height+1) * len(keys))

        def home(self):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.hideSelection()
                self.changeColumn(-100000000000)

        def end(self):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.hideSelection()
                self.changeColumn(100000000000)

        def addChar(self, keys):
                &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
                result = False

                if useful.isascii(keys[0]):
                        self.removeSelection()
                        for char in keys:
                                if useful.isascii(char):
                                        if self.replaceMode:
                                                self.replaceChar(char)
                                        else:
                                                self.insertChar(char)
                                        result = True
                # if result == False:
                        # print(useful.dump(keys[0]))
                return result

        def findNext(self, text):
                &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
                # Get the selection
                selectionStart, selectionEnd = self.getSelection()

                # Hide the selection
                self.hideSelection()

                # Set the start of search at the cursor position
                currentLine   = self.cursorLine
                currentColumn = self.cursorColumn

                # If selection activated
                if selectionStart != None and selectionEnd != None:
                        # If selection is on one line
                        if selectionStart[1] == selectionEnd[1] and currentLine == selectionStart[1]:
                                # If selection is exactly the size of text
                                if selectionStart[0] == currentColumn:
                                        # Move the start of search after the text selected
                                        currentColumn = selectionEnd[0]
                                        pass

                # Find the text in next lines
                while currentLine &lt; len(self.lines):
                        # Search text
                        pos = self.lines[currentLine].find(text, currentColumn)

                        # If text found
                        if pos &gt;= 0:
                                # Move the cursor to the text found
                                self.cursorLine = currentLine
                                self.cursorColumn = pos + len(text)
                                self.changeColumn(0)
                                self.selectionStart = [pos, currentLine,self.getTabCursor(currentLine,pos)]
                                self.selectionEnd   = [pos + len(text), currentLine, self.getTabCursor(currentLine, pos + len(text))]
                                break
                        else:
                                # Set the search position at the begin of next line
                                currentColumn = 0
                                currentLine += 1
                self.view.move()

        def findPrevious(self, text):
                &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
                # Get the selection
                selectionStart, selectionEnd = self.getSelection()

                # Hide the selection
                self.hideSelection()

                # Set the start of search at the cursor position
                currentLine   = self.cursorLine
                currentColumn = self.cursorColumn

                # If selection activated
                if selectionStart != None and selectionEnd != None:
                        # If selection is on one line
                        if selectionStart[1] == selectionEnd[1] and currentLine == selectionStart[1]:
                                # If selection is exactly the size of text
                                if selectionEnd[0] - selectionStart[0] == len(text):
                                        # Move the start of search before the text selected
                                        currentColumn = selectionStart[0]

                # While the line before the first line not reached
                while currentLine &gt;= 0:
                        # Get the current line
                        line = self.lines[currentLine]

                        # If the current column is negative
                        if currentColumn &lt; 0:
                                # Set the end of line
                                currentColumn = len(line)

                        # Search the text in reverse
                        pos = line.rfind(text, 0, currentColumn)

                        # If text found
                        if pos &gt;= 0:
                                self.cursorLine = currentLine
                                self.cursorColumn = pos
                                self.changeColumn(0)
                                self.selectionStart = [pos, currentLine,self.getTabCursor(currentLine,pos)]
                                self.selectionEnd   = [pos + len(text), currentLine, self.getTabCursor(currentLine, pos + len(text))]
                                break
                        else:
                                # Set the search position at the end of line
                                currentColumn = -1
                                currentLine -= 1
                self.view.move()

        def hideSelection(self):
                &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
                self.view.hideSelection()
                self.selectionStart = self.selectionEnd = None

        def goto(self, lineNumber):
                &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
                self.hideSelection()
                if lineNumber &lt; 0:
                        self.cursorLine = len(self.lines)-1
                elif lineNumber &lt; 1:
                        self.cursorLine = 1
                elif lineNumber &lt; len(self.lines):
                        self.cursorLine = lineNumber - 1
                else:
                        self.cursorLine = len(self.lines)-1
                self.cursorColumn = 0
                self.changeColumn(0)
                self.view.move()

        def copyClipboard(self):
                &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
                result = []
                if self.selectionStart != None:
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd
                        result = []
                        if selLineStart == selLineEnd:
                                result.append(self.lines[selLineStart][selColumnStart:selColumnEnd])
                        else:
                                for line in range(selLineStart, selLineEnd+1):
                                        if line == selLineStart:
                                                part = self.lines[line][selColumnStart:]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][selColumnStart:])
                                        elif line == selLineEnd:
                                                part = self.lines[line][:selColumnEnd]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][:selColumnEnd])
                                        else:
                                                result.append(self.lines[line])
                return result

        def removeSelection(self):
                &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
                if self.selectionStart != None:
                        self.modified = True
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd
                        start = self.lines[selLineStart][:selColumnStart]
                        end   = self.lines[selLineEnd  ][selColumnEnd:]
                        self.lines[selLineStart] = start + end
                        if selLineStart &lt; selLineEnd:
                                for line in range(selLineEnd, selLineStart,-1):
                                        del self.lines[line]
                        pass
                        self.moveCursor(selLineStart, selColumnStart)
                        self.hideSelection()
                        self.view.setRefreshAll()
                        return True
                return False

        def pasteClipboard(self, selection):
                &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
                if selection != []:
                        # Split the line with insertion
                        start = self.lines[self.cursorLine][:self.cursorColumn]
                        end   = self.lines[self.cursorLine][self.cursorColumn:]

                        # Paste the first line
                        self.lines[self.cursorLine] = start + selection[0]

                        self.cursorLine += 1

                        # Insert all lines from clipboard
                        for line in selection[1:-1]:
                                self.lines.insert(self.cursorLine, line)
                                self.cursorLine += 1

                        # If the last line of clipboard is not empty
                        if len(selection[-1]) &gt;= 1:
                                # If the last line of clipboard contains new line
                                if selection[-1][-1] == &#34;\n&#34;:
                                        if len(selection) &gt; 1:
                                                # Add the new line
                                                self.lines.insert(self.cursorLine, selection[-1])
                                                self.cursorLine += 1

                                        # Add the part after the insertion
                                        self.lines.insert(self.cursorLine, end)
                                        self.cursorColumn = 0
                                else:
                                        if len(selection) &gt; 1:
                                                self.lines.insert(self.cursorLine, selection[-1] + end)
                                                self.cursorColumn = len(selection[-1])
                                        else:
                                                self.cursorLine -= 1
                                                self.lines[self.cursorLine] += end
                                                self.cursorColumn = len(start) + len(selection[-1])
                                        
                        self.moveCursor(self.cursorLine, self.cursorColumn)
                        # self.view.setRefreshAll()

        def moveCursor(self, line, column):
                &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
                self.cursorLine   = line
                self.cursorColumn = column
                self.changeColumn(0)
                self.getTabCursorColumn()

        def copy(self):
                &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
                self.selection = self.copyClipboard()

        def cut(self):
                &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
                self.modified = True
                self.selection = self.copyClipboard()
                self.removeSelection()

        def paste(self):
                &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
                self.modified = True
                self.removeSelection()
                self.pasteClipboard(self.selection)
                self.view.setRefreshAll()
                self.hideSelection()

        def changeCase(self):
                &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
                selection = self.copyClipboard()
                if selection != []:
                        self.modified = True
                        selectionStart = self.selectionStart
                        selectionEnd   = self.selectionEnd

                        self.removeSelection()
                        isUpper = None
                        for line in selection:
                                for char in line:
                                        if useful.isupper(char):
                                                isUpper = True
                                                break
                                        elif useful.islower(char):
                                                isUpper = False
                                                break
                                if isUpper != None:
                                        break
                        for line in range(len(selection)):
                                if isUpper:
                                        selection[line] = selection[line].lower()
                                else:
                                        selection[line] = selection[line].upper()
                        self.pasteClipboard(selection)
                        self.view.setRefreshSelection()
                        self.selectionStart = selectionStart
                        self.selectionEnd   = selectionEnd

        def comment(self):
                &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
                self.modified = True

                # If selection
                if self.selectionStart != None:
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd

                        # Add tabulation
                        for line in range(selLineStart, selLineEnd+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] != &#39;#&#39;:
                                                self.lines[line] = &#34;#&#34; + self.lines[line]
                                        else:
                                                if len(self.lines[line]) &gt;= 1:
                                                        self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selectionStart = [0,selLineStart, 0]

                        # Get the length of last selected line
                        lenLineEnd =  len(self.lines[selLineEnd])

                        # Move the end of selection at the end of line selected
                        self.selectionEnd   = [lenLineEnd-1, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd-1)]
                        self.view.setRefreshSelection()
                else:
                        if len(self.lines[self.cursorLine]) &gt;= 1:
                                # If nothing selected
                                if self.lines[self.cursorLine][0] == &#34;#&#34;:
                                        self.lines[self.cursorLine] = self.lines[self.cursorLine][1:]
                                        if self.cursorColumn &gt; 0:
                                                self.changeColumn(-1)
                                else:
                                        self.lines[self.cursorLine] = &#34;#&#34; + self.lines[self.cursorLine]
                                        self.changeColumn(1)
                        self.view.setRefreshLine()

        def indent(self, keys):
                &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
                # If nothing selected
                if self.selectionStart == None:
                        self.addChar(keys)
                else:
                        self.modified = True
                        # Indent selection
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd

                        # If a part of line selected
                        if selLineStart == selLineEnd and not (selColumnStart == 0 and selColumnEnd == len(self.lines[selLineEnd])-1):
                                self.addChar(INDENT)
                        else:
                                # If the last line selected is at beginning of line
                                if selColumnEnd == 0:
                                        # This line must not be indented
                                        selLineEnd -= 1

                                # Add tabulation
                                for line in range(selLineStart, selLineEnd+1):
                                        self.lines[line] = &#34;\t&#34; + self.lines[line]

                                # Move the start selection to the start of first selected line
                                self.selectionStart = [0,selLineStart, 0]

                                # If the last line selected is not at beginning of line
                                if selColumnEnd &gt; 0:
                                        # Get the length of last selected line
                                        lenLineEnd =  len(self.lines[selLineEnd])

                                        # If the end of selection is not on the last line
                                        if selLineEnd &lt; len(self.lines)-1:
                                                lenLineEnd -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selectionEnd   = [lenLineEnd, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selectionEnd  = [0, selLineEnd+1, 0]
                        self.view.setRefreshSelection()

        def unindent(self, keys):
                &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
                # If nothing selected
                if self.selectionStart == None:
                        self.backspace()
                else:
                        self.modified = True
        
                        # Unindent selection
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd

                        # If the selection is only alone line
                        if selLineStart == selLineEnd:
                                self.hideSelection()
                        else:
                                # If the last line selected is at beginning of line
                                if selColumnEnd == 0:
                                        # This line must not be indented
                                        selLineEnd -= 1

                                # Remove indentation
                                for line in range(selLineStart, selLineEnd+1):
                                        if len(self.lines[line]) &gt;= 1:
                                                if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                        self.lines[line] = self.lines[line][1:]

                                # Move the start selection to the start of first selected line
                                self.selectionStart = [0,selLineStart, 0]

                                # If the last line selected is not at beginning of line
                                if selColumnEnd &gt; 0:
                                        # Get the length of last selected line
                                        lenLineEnd =  len(self.lines[selLineEnd])

                                        # If the end of selection is not on the last line
                                        if selLineEnd &lt; len(self.lines)-1:
                                                lenLineEnd -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selectionEnd   = [lenLineEnd, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selectionEnd  = [0, selLineEnd+1, 0]
                        self.view.setRefreshSelection()

        def replace(self, old, new):
                &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
                if self.readOnly == False:
                        selection = self.copyClipboard()
                        if len(selection) == 1:
                                if selection[0] == old:
                                        self.delete()
                                        self.insertChar(new)
                                        return True
                return False

        def getCursorChar(self):
                &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
                return self.lines[self.cursorLine][self.cursorColumn]

        def moveWord(self, direction):
                &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
                state = 0
                while self.changeColumn(direction):
                        currentChar = self.getCursorChar()
                        if useful.ispunctuation(currentChar):
                                if state == 0:
                                        state = 2
                                elif state == 1:
                                        break
                        elif useful.isalpha(currentChar):
                                if state == 0:
                                        state = 1
                                elif state == 2:
                                        break
                        elif useful.isspace(currentChar):
                                if state == 1:
                                        break
                                if state == 2:
                                        break

        def nextWord(self):
                &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
                self.hideSelection()
                self.moveWord(1)
                self.view.move()

        def previousWord(self):
                &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
                self.hideSelection()
                self.moveWord(-1)
                self.view.move()

        def top(self):
                &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
                self.goto(1)

        def bottom(self):
                &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
                self.goto(100000000000)

        def treatKey(self, keys):
                &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
                # Move in the edit field
                if   keys[0] in UP  :            self.arrowUp(keys)
                elif keys[0] in DOWN:            self.arrowDown(keys)
                elif keys[0] in LEFT:            self.arrowLeft(keys)
                elif keys[0] in RIGHT:           self.arrowRight(keys)
                elif keys[0] in HOME:            self.home()
                elif keys[0] in END:             self.end()
                elif keys[0] in PAGE_UP:         self.pageUp(keys)
                elif keys[0] in PAGE_DOWN:       self.pageDown(keys)
                elif keys[0] in TOP:             self.top()
                elif keys[0] in BOTTOM:          self.bottom()
                elif keys[0] in NEXT_WORD:       self.nextWord()
                elif keys[0] in PREVIOUS_WORD:   self.previousWord()
                # Selection the edit field
                elif keys[0] in SELECT_UP:       self.selectUp(keys)
                elif keys[0] in SELECT_DOWN:     self.selectDown(keys)
                elif keys[0] in SELECT_RIGHT:    self.selectRight(keys)
                elif keys[0] in SELECT_LEFT:     self.selectLeft(keys)
                elif keys[0] in SELECT_HOME:     self.selectHome()
                elif keys[0] in SELECT_END:      self.selectEnd()
                elif keys[0] in SELECT_PAGE_UP:  self.selectPageUp(keys)
                elif keys[0] in SELECT_PAGE_DOWN:self.selectPageDown(keys)
                elif keys[0] in SELECT_ALL:      self.selectAll()
                elif keys[0] in SELECT_NEXT_WORD:self.selectNextWord()
                elif keys[0] in SELECT_PREV_WORD:self.selectPreviousWord()

                # If the edit is not in read only 
                elif self.readOnly == False:
                        # Modification in the edit field
                        if   keys[0] in COPY:            self.copy()
                        elif keys[0] in CUT:             self.cut()
                        elif keys[0] in PASTE:           self.paste()

                        elif keys[0] in INDENT:          self.indent(keys)
                        elif keys[0] in UNINDENT:        self.unindent(keys)
                        elif keys[0] in CHANGE_CASE:     self.changeCase()
                        elif keys[0] in COMMENT:         self.comment()

                        elif keys[0] in BACKSPACE:       self.backspace()
                        elif keys[0] in DELETE:          self.delete()
                        elif keys[0] in NEW_LINE:        self.newLine()
                        elif keys[0] in DELETE_LINE:     self.deleteLine()
                        else: self.addChar(keys)

class Edit:
        &#34;&#34;&#34; Class which aggregate the View and Text &#34;&#34;&#34;
        def __init__(self, viewTop=1, viewHeight=None, readOnly=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.view = View(viewHeight, viewTop)
                self.text = Text(readOnly)
                self.text.setView(self.view)
                self.view.setText(self.text)

class Editor:
        &#34;&#34;&#34; Class which manage a complete editor &#34;&#34;&#34;
        def __init__(self, filename, readOnly=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.file = filename
                self.filename = useful.split(filename)[1]
                self.edit = Edit(readOnly=readOnly)
                self.edit.text.load(filename)
                self.isRefreshHeader = True
                self.findText = None
                self.keys= []
        
                if (not useful.exists(filename) and readOnly == True) or useful.isdir(filename):
                        print(&#34;Cannot open &#39;%s&#39;&#34;%self.filename)
                else:
                        self.run()

        def refreshHeader(self, alone=False):
                &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
                if self.isRefreshHeader:
                        self.edit.view.moveCursor(0, 0)
                        filename = &#34;File: %s&#34;%(self.filename)
                        if self.edit.text.readOnly == False:
                                filename += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                                end = &#34;Mode: %s&#34;%(&#34;Replace&#34; if self.edit.text.replaceMode else &#34;Insert&#34;)
                        else:
                                end = &#34;Read only&#34; if self.edit.text.readOnly else &#34;&#34;
                        
                        header = &#34;\x1B[7m %s%s%s \x1B[m&#34;%(filename, &#34; &#34;*(self.edit.view.width - len(filename) - len(end)-2), end)
                        self.edit.view.write(header)
                        self.edit.view.moveCursor()
                        self.isRefreshHeader = False

        def refresh(self):
                &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
                self.refreshHeader()
                self.edit.view.refresh()

        def toggleMode(self):
                &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
                if self.edit.text.replaceMode:
                        self.edit.text.replaceMode = False
                else:
                        self.edit.text.replaceMode = True
                self.isRefreshHeader = True

        def save(self):
                &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
                self.edit.text.save()
                self.isRefreshHeader = True

        def exit(self):
                &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
                self.edit.view.cls()
                if self.edit.text.modified:
                        self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.filename)
                        self.edit.view.flush()
                        while 1:
                                key = useful.getch()
                                if key == &#34;Y&#34; or key == &#34;y&#34;:
                                        if self.edit.text.save():
                                                self.edit.view.write(&#34;Saved\n&#34;)
                                                self.edit.view.flush()
                                        else:
                                                self.edit.view.write(&#34;Failed to save\n&#34;)
                                                self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == &#34;N&#34; or key == &#34;n&#34;:
                                        self.edit.view.write(&#34;Not saved\n&#34;)
                                        self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == ESCAPE:
                                        self.edit.view.setRefreshAll()
                                        self.isRefreshHeader = True
                                        break
                else:
                        self.loop = False

        def input(self, text, help=&#34;&#34;):
                &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
                edit = Edit(viewTop=2, viewHeight=1, readOnly=False)
                edit.view.cls()
                edit.view.moveCursor(1,0)
                edit.view.write(text)
                edit.view.moveCursor(4,0)
                edit.view.write(help)
                result = None
                while 1:
                        edit.view.refresh()
                        key = useful.getch()
                        if key == &#34;\n&#34; or key == &#34;\r&#34;:
                                result = edit.text.lines[0]
                                break
                        elif key == ESCAPE:
                                break
                        else:
                                edit.text.treatKey(key)
                return result

        def find(self):
                &#34;&#34;&#34; Find a text &#34;&#34;&#34;
                self.findText = self.input(&#34;Find :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next&#34;)
                self.findNext()
                self.edit.view.setRefreshAll()
                self.isRefreshHeader = True

        def replace(self):
                &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
                self.findText    = self.input(&#34;Find to replace :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
                if self.findText:
                        self.replaceText = self.input(&#34;Replace with :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next  \x1B[7m^R\x1B[m:Replace&#34;)
                        self.findNext()

                self.edit.view.setRefreshAll()
                self.isRefreshHeader = True

        def replaceCurrent(self):
                &#34;&#34;&#34; Replace current &#34;&#34;&#34;
                if self.edit.text.replace(self.findText, self.replaceText):
                        self.findNext()

        def findNext(self):
                &#34;&#34;&#34; Find next text &#34;&#34;&#34;
                if self.findText:
                        self.edit.text.findNext(self.findText)

        def findPrevious(self):
                &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
                if self.findText:
                        self.edit.text.findPrevious(self.findText)

        def goto(self):
                &#34;&#34;&#34; Goto line &#34;&#34;&#34;
                lineNumber = self.input(&#34;Goto line :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
                try:
                        lineNumber = int(lineNumber)
                        self.edit.text.goto(int(lineNumber))
                except:
                        pass
                self.edit.view.setRefreshAll()
                self.isRefreshHeader = True

        def groupKey(self):
                &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
                result = [self.keys.pop(0)]
                while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                        if self.keys[0] == result[0]:
                                result.append(self.keys.pop(0))
                        else:
                                if useful.isascii(result[0]) and useful.isascii(self.keys[0]):
                                        result.append(self.keys.pop(0))
                                else:
                                        break
                return result

        def getKey(self):
                &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
                if len(self.keys) == 0:
                        while True:
                                try:
                                        key = useful.getch()
                                except KeyboardInterrupt:
                                        key = &#34;\x03&#34;
                                self.keys.append(key)
                                if useful.kbhit() == False or len(self.keys) &gt; 5:
                                        break
                return self.groupKey()

        def execute(self):
                &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
                self.save()
                loop = True
                while loop:
                        self.edit.view.cls()
                        self.edit.view.flush()
                        startTime = useful.ticks()
                        try:
                                useful.import_(self.filename)
                        except KeyboardInterrupt:
                                pass
                        endTime = useful.ticks()
                        print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                        while 1:
                                keys = self.getKey()
                                if keys[0] in NEW_LINE:
                                        loop = False
                                        break
                                elif keys[0] in EXECUTE:
                                        break
                                # else:
                                        # print(useful.dump(keys))
                self.edit.view.cls()
                self.edit.view.setRefreshAll()
                self.isRefreshHeader = True

        def run(self):
                &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
                self.edit.view.cls()
                self.edit.view.getScreenSize()
                self.loop = True
                while(self.loop):
                        try:
                                self.refresh()
                                keys = self.getKey()
                                modified = self.edit.text.modified
                                if   keys[0] in TOGGLE_MODE:    self.toggleMode()
                                elif keys[0] in FIND:           self.find()
                                elif keys[0] in REPLACE:        self.replace()
                                elif keys[0] in FIND_PREVIOUS:  self.findPrevious()
                                elif keys[0] in FIND_NEXT:      self.findNext()
                                elif keys[0] in REPLACE_CURRENT:self.replaceCurrent()
                                elif keys[0] in EXIT:           self.exit()
                                elif keys[0] in GOTO:           self.goto()
                                elif keys[0] in SAVE:           self.save()
                                elif keys[0] in EXECUTE:        self.execute()
                                else: self.edit.text.treatKey(keys)
                                if modified != self.edit.text.modified:
                                        self.isRefreshHeader = True
                        except KeyboardInterrupt:
                                pass
                self.edit.view.resetScrollRegion()
                self.edit.view.reset()

if __name__ == &#34;__main__&#34;:
        readOnly = True
        readOnly = False
        if len(sys.argv) &gt; 1:
                filename = sys.argv[1]
        else:
                filename = &#34;editor.txt&#34;
        edit = Editor(filename, readOnly=readOnly)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.shell.editor.Edit"><code class="flex name class">
<span>class <span class="ident">Edit</span></span>
<span>(</span><span>viewTop=1, viewHeight=None, readOnly=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which aggregate the View and Text </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Edit:
        &#34;&#34;&#34; Class which aggregate the View and Text &#34;&#34;&#34;
        def __init__(self, viewTop=1, viewHeight=None, readOnly=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.view = View(viewHeight, viewTop)
                self.text = Text(readOnly)
                self.text.setView(self.view)
                self.view.setText(self.text)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor"><code class="flex name class">
<span>class <span class="ident">Editor</span></span>
<span>(</span><span>filename, readOnly=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage a complete editor </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Editor:
        &#34;&#34;&#34; Class which manage a complete editor &#34;&#34;&#34;
        def __init__(self, filename, readOnly=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.file = filename
                self.filename = useful.split(filename)[1]
                self.edit = Edit(readOnly=readOnly)
                self.edit.text.load(filename)
                self.isRefreshHeader = True
                self.findText = None
                self.keys= []
        
                if (not useful.exists(filename) and readOnly == True) or useful.isdir(filename):
                        print(&#34;Cannot open &#39;%s&#39;&#34;%self.filename)
                else:
                        self.run()

        def refreshHeader(self, alone=False):
                &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
                if self.isRefreshHeader:
                        self.edit.view.moveCursor(0, 0)
                        filename = &#34;File: %s&#34;%(self.filename)
                        if self.edit.text.readOnly == False:
                                filename += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                                end = &#34;Mode: %s&#34;%(&#34;Replace&#34; if self.edit.text.replaceMode else &#34;Insert&#34;)
                        else:
                                end = &#34;Read only&#34; if self.edit.text.readOnly else &#34;&#34;
                        
                        header = &#34;\x1B[7m %s%s%s \x1B[m&#34;%(filename, &#34; &#34;*(self.edit.view.width - len(filename) - len(end)-2), end)
                        self.edit.view.write(header)
                        self.edit.view.moveCursor()
                        self.isRefreshHeader = False

        def refresh(self):
                &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
                self.refreshHeader()
                self.edit.view.refresh()

        def toggleMode(self):
                &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
                if self.edit.text.replaceMode:
                        self.edit.text.replaceMode = False
                else:
                        self.edit.text.replaceMode = True
                self.isRefreshHeader = True

        def save(self):
                &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
                self.edit.text.save()
                self.isRefreshHeader = True

        def exit(self):
                &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
                self.edit.view.cls()
                if self.edit.text.modified:
                        self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.filename)
                        self.edit.view.flush()
                        while 1:
                                key = useful.getch()
                                if key == &#34;Y&#34; or key == &#34;y&#34;:
                                        if self.edit.text.save():
                                                self.edit.view.write(&#34;Saved\n&#34;)
                                                self.edit.view.flush()
                                        else:
                                                self.edit.view.write(&#34;Failed to save\n&#34;)
                                                self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == &#34;N&#34; or key == &#34;n&#34;:
                                        self.edit.view.write(&#34;Not saved\n&#34;)
                                        self.edit.view.flush()
                                        self.loop = False
                                        break
                                elif key == ESCAPE:
                                        self.edit.view.setRefreshAll()
                                        self.isRefreshHeader = True
                                        break
                else:
                        self.loop = False

        def input(self, text, help=&#34;&#34;):
                &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
                edit = Edit(viewTop=2, viewHeight=1, readOnly=False)
                edit.view.cls()
                edit.view.moveCursor(1,0)
                edit.view.write(text)
                edit.view.moveCursor(4,0)
                edit.view.write(help)
                result = None
                while 1:
                        edit.view.refresh()
                        key = useful.getch()
                        if key == &#34;\n&#34; or key == &#34;\r&#34;:
                                result = edit.text.lines[0]
                                break
                        elif key == ESCAPE:
                                break
                        else:
                                edit.text.treatKey(key)
                return result

        def find(self):
                &#34;&#34;&#34; Find a text &#34;&#34;&#34;
                self.findText = self.input(&#34;Find :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next&#34;)
                self.findNext()
                self.edit.view.setRefreshAll()
                self.isRefreshHeader = True

        def replace(self):
                &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
                self.findText    = self.input(&#34;Find to replace :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
                if self.findText:
                        self.replaceText = self.input(&#34;Replace with :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next  \x1B[7m^R\x1B[m:Replace&#34;)
                        self.findNext()

                self.edit.view.setRefreshAll()
                self.isRefreshHeader = True

        def replaceCurrent(self):
                &#34;&#34;&#34; Replace current &#34;&#34;&#34;
                if self.edit.text.replace(self.findText, self.replaceText):
                        self.findNext()

        def findNext(self):
                &#34;&#34;&#34; Find next text &#34;&#34;&#34;
                if self.findText:
                        self.edit.text.findNext(self.findText)

        def findPrevious(self):
                &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
                if self.findText:
                        self.edit.text.findPrevious(self.findText)

        def goto(self):
                &#34;&#34;&#34; Goto line &#34;&#34;&#34;
                lineNumber = self.input(&#34;Goto line :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
                try:
                        lineNumber = int(lineNumber)
                        self.edit.text.goto(int(lineNumber))
                except:
                        pass
                self.edit.view.setRefreshAll()
                self.isRefreshHeader = True

        def groupKey(self):
                &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
                result = [self.keys.pop(0)]
                while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                        if self.keys[0] == result[0]:
                                result.append(self.keys.pop(0))
                        else:
                                if useful.isascii(result[0]) and useful.isascii(self.keys[0]):
                                        result.append(self.keys.pop(0))
                                else:
                                        break
                return result

        def getKey(self):
                &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
                if len(self.keys) == 0:
                        while True:
                                try:
                                        key = useful.getch()
                                except KeyboardInterrupt:
                                        key = &#34;\x03&#34;
                                self.keys.append(key)
                                if useful.kbhit() == False or len(self.keys) &gt; 5:
                                        break
                return self.groupKey()

        def execute(self):
                &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
                self.save()
                loop = True
                while loop:
                        self.edit.view.cls()
                        self.edit.view.flush()
                        startTime = useful.ticks()
                        try:
                                useful.import_(self.filename)
                        except KeyboardInterrupt:
                                pass
                        endTime = useful.ticks()
                        print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                        while 1:
                                keys = self.getKey()
                                if keys[0] in NEW_LINE:
                                        loop = False
                                        break
                                elif keys[0] in EXECUTE:
                                        break
                                # else:
                                        # print(useful.dump(keys))
                self.edit.view.cls()
                self.edit.view.setRefreshAll()
                self.isRefreshHeader = True

        def run(self):
                &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
                self.edit.view.cls()
                self.edit.view.getScreenSize()
                self.loop = True
                while(self.loop):
                        try:
                                self.refresh()
                                keys = self.getKey()
                                modified = self.edit.text.modified
                                if   keys[0] in TOGGLE_MODE:    self.toggleMode()
                                elif keys[0] in FIND:           self.find()
                                elif keys[0] in REPLACE:        self.replace()
                                elif keys[0] in FIND_PREVIOUS:  self.findPrevious()
                                elif keys[0] in FIND_NEXT:      self.findNext()
                                elif keys[0] in REPLACE_CURRENT:self.replaceCurrent()
                                elif keys[0] in EXIT:           self.exit()
                                elif keys[0] in GOTO:           self.goto()
                                elif keys[0] in SAVE:           self.save()
                                elif keys[0] in EXECUTE:        self.execute()
                                else: self.edit.text.treatKey(keys)
                                if modified != self.edit.text.modified:
                                        self.isRefreshHeader = True
                        except KeyboardInterrupt:
                                pass
                self.edit.view.resetScrollRegion()
                self.edit.view.reset()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.Editor.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the python script edited</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
        &#34;&#34;&#34; Execute the python script edited &#34;&#34;&#34;
        self.save()
        loop = True
        while loop:
                self.edit.view.cls()
                self.edit.view.flush()
                startTime = useful.ticks()
                try:
                        useful.import_(self.filename)
                except KeyboardInterrupt:
                        pass
                endTime = useful.ticks()
                print( &#34;\x1B[7mTime: %d.%03d s Press enter to stop\x1B[m&#34;%((endTime-startTime)/1000, (endTime-startTime)%1000))
                while 1:
                        keys = self.getKey()
                        if keys[0] in NEW_LINE:
                                loop = False
                                break
                        elif keys[0] in EXECUTE:
                                break
                        # else:
                                # print(useful.dump(keys))
        self.edit.view.cls()
        self.edit.view.setRefreshAll()
        self.isRefreshHeader = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.exit"><code class="name flex">
<span>def <span class="ident">exit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Exit from editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit(self):
        &#34;&#34;&#34; Exit from editor &#34;&#34;&#34;
        self.edit.view.cls()
        if self.edit.text.modified:
                self.edit.view.write(&#34;\nSave file &#39;%s&#39; (\x1b[7mY\x1b[m:Yes, \x1b[7mN\x1b[m:No, \x1b[7mEsc\x1b[m:Cancel) : &#34;%self.filename)
                self.edit.view.flush()
                while 1:
                        key = useful.getch()
                        if key == &#34;Y&#34; or key == &#34;y&#34;:
                                if self.edit.text.save():
                                        self.edit.view.write(&#34;Saved\n&#34;)
                                        self.edit.view.flush()
                                else:
                                        self.edit.view.write(&#34;Failed to save\n&#34;)
                                        self.edit.view.flush()
                                self.loop = False
                                break
                        elif key == &#34;N&#34; or key == &#34;n&#34;:
                                self.edit.view.write(&#34;Not saved\n&#34;)
                                self.edit.view.flush()
                                self.loop = False
                                break
                        elif key == ESCAPE:
                                self.edit.view.setRefreshAll()
                                self.isRefreshHeader = True
                                break
        else:
                self.loop = False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find a text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self):
        &#34;&#34;&#34; Find a text &#34;&#34;&#34;
        self.findText = self.input(&#34;Find :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next&#34;)
        self.findNext()
        self.edit.view.setRefreshAll()
        self.isRefreshHeader = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.findNext"><code class="name flex">
<span>def <span class="ident">findNext</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find next text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findNext(self):
        &#34;&#34;&#34; Find next text &#34;&#34;&#34;
        if self.findText:
                self.edit.text.findNext(self.findText)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.findPrevious"><code class="name flex">
<span>def <span class="ident">findPrevious</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find previous text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findPrevious(self):
        &#34;&#34;&#34; Find previous text &#34;&#34;&#34;
        if self.findText:
                self.edit.text.findPrevious(self.findText)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.getKey"><code class="name flex">
<span>def <span class="ident">getKey</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a key pressed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKey(self):
        &#34;&#34;&#34; Get a key pressed &#34;&#34;&#34;
        if len(self.keys) == 0:
                while True:
                        try:
                                key = useful.getch()
                        except KeyboardInterrupt:
                                key = &#34;\x03&#34;
                        self.keys.append(key)
                        if useful.kbhit() == False or len(self.keys) &gt; 5:
                                break
        return self.groupKey()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Goto line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self):
        &#34;&#34;&#34; Goto line &#34;&#34;&#34;
        lineNumber = self.input(&#34;Goto line :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
        try:
                lineNumber = int(lineNumber)
                self.edit.text.goto(int(lineNumber))
        except:
                pass
        self.edit.view.setRefreshAll()
        self.isRefreshHeader = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.groupKey"><code class="name flex">
<span>def <span class="ident">groupKey</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Group similar key to optimize move of cursor and edition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def groupKey(self):
        &#34;&#34;&#34; Group similar key to optimize move of cursor and edition &#34;&#34;&#34;
        result = [self.keys.pop(0)]
        while len(self.keys) &gt; 0 and len(result) &lt;= 10:
                if self.keys[0] == result[0]:
                        result.append(self.keys.pop(0))
                else:
                        if useful.isascii(result[0]) and useful.isascii(self.keys[0]):
                                result.append(self.keys.pop(0))
                        else:
                                break
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.input"><code class="name flex">
<span>def <span class="ident">input</span></span>(<span>self, text, help='')</span>
</code></dt>
<dd>
<div class="desc"><p>Input value, used to get a line number, or text searched</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def input(self, text, help=&#34;&#34;):
        &#34;&#34;&#34; Input value, used to get a line number, or text searched &#34;&#34;&#34;
        edit = Edit(viewTop=2, viewHeight=1, readOnly=False)
        edit.view.cls()
        edit.view.moveCursor(1,0)
        edit.view.write(text)
        edit.view.moveCursor(4,0)
        edit.view.write(help)
        result = None
        while 1:
                edit.view.refresh()
                key = useful.getch()
                if key == &#34;\n&#34; or key == &#34;\r&#34;:
                        result = edit.text.lines[0]
                        break
                elif key == ESCAPE:
                        break
                else:
                        edit.text.treatKey(key)
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
        &#34;&#34;&#34; Refresh the editor &#34;&#34;&#34;
        self.refreshHeader()
        self.edit.view.refresh()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.refreshHeader"><code class="name flex">
<span>def <span class="ident">refreshHeader</span></span>(<span>self, alone=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the header of editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshHeader(self, alone=False):
        &#34;&#34;&#34; Refresh the header of editor &#34;&#34;&#34;
        if self.isRefreshHeader:
                self.edit.view.moveCursor(0, 0)
                filename = &#34;File: %s&#34;%(self.filename)
                if self.edit.text.readOnly == False:
                        filename += &#34; (*)&#34; if self.edit.text.modified else &#34;&#34;
                        end = &#34;Mode: %s&#34;%(&#34;Replace&#34; if self.edit.text.replaceMode else &#34;Insert&#34;)
                else:
                        end = &#34;Read only&#34; if self.edit.text.readOnly else &#34;&#34;
                
                header = &#34;\x1B[7m %s%s%s \x1B[m&#34;%(filename, &#34; &#34;*(self.edit.view.width - len(filename) - len(end)-2), end)
                self.edit.view.write(header)
                self.edit.view.moveCursor()
                self.isRefreshHeader = False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace a text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self):
        &#34;&#34;&#34; Replace a text &#34;&#34;&#34;
        self.findText    = self.input(&#34;Find to replace :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort&#34;)
        if self.findText:
                self.replaceText = self.input(&#34;Replace with :&#34;,&#34;\x1B[7mEsc\x1B[m:Abort  \x1B[7m^Left\x1B[m,\x1B[7m^Up\x1B[m:Previous  \x1B[7m^Down\x1B[m,\x1B[7m^Right\x1B[m:Next  \x1B[7m^R\x1B[m:Replace&#34;)
                self.findNext()

        self.edit.view.setRefreshAll()
        self.isRefreshHeader = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.replaceCurrent"><code class="name flex">
<span>def <span class="ident">replaceCurrent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace current</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replaceCurrent(self):
        &#34;&#34;&#34; Replace current &#34;&#34;&#34;
        if self.edit.text.replace(self.findText, self.replaceText):
                self.findNext()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Core of the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
        &#34;&#34;&#34; Core of the editor &#34;&#34;&#34;
        self.edit.view.cls()
        self.edit.view.getScreenSize()
        self.loop = True
        while(self.loop):
                try:
                        self.refresh()
                        keys = self.getKey()
                        modified = self.edit.text.modified
                        if   keys[0] in TOGGLE_MODE:    self.toggleMode()
                        elif keys[0] in FIND:           self.find()
                        elif keys[0] in REPLACE:        self.replace()
                        elif keys[0] in FIND_PREVIOUS:  self.findPrevious()
                        elif keys[0] in FIND_NEXT:      self.findNext()
                        elif keys[0] in REPLACE_CURRENT:self.replaceCurrent()
                        elif keys[0] in EXIT:           self.exit()
                        elif keys[0] in GOTO:           self.goto()
                        elif keys[0] in SAVE:           self.save()
                        elif keys[0] in EXECUTE:        self.execute()
                        else: self.edit.text.treatKey(keys)
                        if modified != self.edit.text.modified:
                                self.isRefreshHeader = True
                except KeyboardInterrupt:
                        pass
        self.edit.view.resetScrollRegion()
        self.edit.view.reset()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the file edited</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
        &#34;&#34;&#34; Save the file edited &#34;&#34;&#34;
        self.edit.text.save()
        self.isRefreshHeader = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Editor.toggleMode"><code class="name flex">
<span>def <span class="ident">toggleMode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the replace mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggleMode(self):
        &#34;&#34;&#34; Change the replace mode &#34;&#34;&#34;
        if self.edit.text.replaceMode:
                self.edit.text.replaceMode = False
        else:
                self.edit.text.replaceMode = True
        self.isRefreshHeader = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.shell.editor.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
<span>(</span><span>readOnly=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage the text edition </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Text:
        &#34;&#34;&#34; Class which manage the text edition &#34;&#34;&#34;
        def __init__(self, readOnly=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.lines = [&#34;&#34;]
                self.cursorLine   = 0
                self.cursorColumn = 0
                self.tabCursorColumn   = 0
                self.modified     = False
                self.replaceMode  = False
                self.readOnly     = readOnly
                self.view         = None
                self.tabSize      = TABSIZE
                self.selectionStart = None
                self.selectionEnd   = None
                self.selection = []

        def setView(self, view):
                &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
                self.view = view

        def getCountLines(self):
                &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
                return len(self.lines)

        def getCursorLine(self):
                &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
                return self.cursorLine

        def getTabCursor(self, currentLine, currentColumn=None):
                &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
                if currentColumn == None:
                        cursorColumn = self.cursorColumn
                else:
                        cursorColumn = currentColumn
                line = self.lines[currentLine]
                if &#34;\t&#34; in line:
                        tabCursorColumn   = 0
                        column = 0
                        for char in line:
                                if column == cursorColumn:
                                        break
                                if char == &#34;\t&#34;:
                                        pos = tabCursorColumn%self.tabSize
                                        tabCursorColumn += self.tabSize-pos
                                else:
                                        tabCursorColumn += 1
                                column += 1
                        return tabCursorColumn
                else:
                        return cursorColumn

        def getTabLine(self, currentLine = None):
                &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
                line = self.lines[currentLine]
                tabLine = &#34;&#34;
                tabCursorColumn   = 0
                lenLine = len(line)
                column = 0
                while column &lt; lenLine: 
                        char = line[column]
                        if char == &#34;\t&#34;:
                                pos = tabCursorColumn%self.tabSize
                                tabCursorColumn += self.tabSize-pos
                                tabLine         += &#34; &#34;*(self.tabSize-pos)
                                column          += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        part = line[column:tab]
                                else:
                                        part = line[column:]
                                tabCursorColumn += len(part)
                                tabLine         += part
                                column          += len(part)
                return tabLine

        def getTabCursorColumn(self):
                &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
                line = self.lines[self.cursorLine]
                column = 0
                self.tabCursorColumn = 0
                while column &lt; self.cursorColumn:
                        if line[column] == &#34;\t&#34;:
                                pos = self.tabCursorColumn%self.tabSize
                                self.tabCursorColumn += self.tabSize-pos
                                column += 1
                        else:
                                tab = line.find(&#34;\t&#34;,column)
                                if tab &gt; 0:
                                        delta = tab - column
                                        if column + delta &gt; self.cursorColumn:
                                                delta = self.cursorColumn - column
                                                self.tabCursorColumn += delta
                                                column += delta
                                        else:
                                                self.tabCursorColumn += delta
                                                column += delta
                                else:
                                        delta = self.cursorColumn - column
                                        self.tabCursorColumn += delta
                                        column += delta

        def setCursorColumn(self):
                &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
                line = self.lines[self.cursorLine]
                column = 0
                tabCursorColumn = 0
                lenLine = len(line)
                column = 0
                while column &lt; lenLine: 
                        char = line[column]
                        # If the previous position found exactly in the current line
                        if tabCursorColumn == self.tabCursorColumn:
                                self.cursorColumn = column
                                break
                        # If the previous position not found in the current line
                        if tabCursorColumn &gt; self.tabCursorColumn:
                                # Keep last existing position
                                self.cursorColumn = column
                                break
                        # If tabulation found
                        if char == &#34;\t&#34;:
                                tabCursorColumn += self.tabSize-(tabCursorColumn%self.tabSize)
                                column += 1
                        else:
                                # Optimization to accelerate the cursor position
                                tab = line.find(&#34;\t&#34;, column)

                                # Tabulation found
                                if tab &gt; 0:
                                        delta = tab - column
                                        # If the tabulation position is after the previous tabulation cursor
                                        if delta + tabCursorColumn &gt; self.tabCursorColumn:
                                                # Move the cursor to the left
                                                self.cursorColumn = column + (self.tabCursorColumn - tabCursorColumn)
                                                break
                                        else:
                                                # Another tabulation found, move it after
                                                tabCursorColumn += delta
                                                column += delta
                                # Tabulation not found
                                else:
                                        # Move the cursor to the end of line
                                        self.cursorColumn = column + (self.tabCursorColumn - tabCursorColumn)
                                        break
                else:
                        if len(line) &gt;= 1:
                                self.cursorColumn = len(line)-1
                        else:
                                self.cursorColumn = 0

        def load(self, filename):
                &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
                self.filename = None
                try:
                        self.lines = []
                        self.filename = filename
                        file = open(filename, &#34;r&#34;)
                        line = file.readline()
                        while line != &#34;&#34;:
                                self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                                line = file.readline()
                        file.close()
                        if len(self.lines) == 0:
                                self.lines = [&#34;&#34;]
                except MemoryError:
                        raise MemoryError()
                except OSError:
                        self.lines = [&#34;&#34;]
                        # File not existing
                except Exception as error:
                        print(useful.exception(error))
                        self.lines = [&#34;&#34;]

        def save(self):
                &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
                result = False
                if self.readOnly == False:
                        if self.filename != None:
                                try:
                                        file = open(self.filename, &#34;w&#34;)
                                        for line in self.lines:
                                                file.write(line)
                                        file.close()
                                        self.modified = False
                                        result = True
                                except Exception as error:
                                        print(useful.exception(error))
                return result

        def changeLine(self, moveLine):
                &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
                # If cursor is before the first line
                if moveLine + self.cursorLine &lt; 0:
                        # Set the cursor to the first line
                        self.cursorLine = 0
                        self.setCursorColumn()
                        self.changeColumn(0)
                # If the cursor is after the last line
                elif moveLine + self.cursorLine &gt;= len(self.lines):
                        self.cursorLine = len(self.lines) -1
                        self.setCursorColumn()
                        self.changeColumn(0)
                # else the cursor is in the lines of text
                else:
                        previousLine = self.cursorLine
                        self.cursorLine += moveLine
                        lenLine = len(self.lines[self.cursorLine])-1

                        self.setCursorColumn()
                        # If the new cursor position is outside the last line of text
                        if self.cursorColumn &gt; lenLine:
                                self.cursorColumn = lenLine

                if self.selectionStart != None:
                        self.selectionEnd = [self.cursorColumn, self.cursorLine,self.getTabCursor(self.cursorLine)]
                self.view.move()

        def changeColumn(self, moveColumn):
                &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
                cursorLine   = self.cursorLine
                cursorColumn = self.cursorColumn
                # If the cursor go to the previous line
                if moveColumn + self.cursorColumn &lt; 0:
                        # If start of line
                        if abs(moveColumn) &gt; 1:
                                self.cursorColumn = 0
                        # If move to the left and must go to previous line
                        elif self.cursorLine &gt; 0:
                                self.cursorLine -= 1
                                self.cursorColumn = len(self.lines[self.cursorLine])-1
                # If the cursor is at the end of line
                elif moveColumn + self.cursorColumn &gt; len(self.lines[self.cursorLine])-1:
                        # If the cursor is on the last line of file
                        if abs(moveColumn) &gt; 1 or self.cursorLine+1 == len(self.lines):
                                # If the file is empty
                                if self.lines[self.cursorLine] == &#34;&#34;:
                                        self.cursorColumn = 0
                                        self.tabCursorColumn = 0
                                # If the last line of contains return char
                                elif self.lines[self.cursorLine][-1] == &#34;\n&#34;:
                                        # Move cursor before return
                                        self.cursorColumn = len(self.lines[self.cursorLine])-1
                                else:
                                        # Move cursor after the last char
                                        self.cursorColumn = len(self.lines[self.cursorLine])

                        # If the cursor is on the end of line and must change of line
                        elif self.cursorLine+1 &lt; len(self.lines):
                                self.cursorLine += 1
                                self.cursorColumn = 0
                                self.tabCursorColumn = 0
                # Normal move of cursor
                else:
                        # Next or previous column
                        self.cursorColumn += moveColumn
                if abs(moveColumn) &gt; 0:
                        self.getTabCursorColumn()
                self.closeSelection()
                self.view.move()
                if self.cursorColumn == cursorColumn and self.cursorLine == cursorLine:
                        return False
                else:
                        return True

        def backspace(self):
                &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
                self.modified = True
                if self.removeSelection() == False:
                        # The cursor not in the begining of line
                        if self.cursorColumn &gt;= 1:
                                line = self.lines[self.cursorLine]
                                line = line[0:self.cursorColumn-1:]+ line[self.cursorColumn  : :]
                                self.lines[self.cursorLine] = line
                                self.changeColumn(-1)
                                self.view.setRefreshLine()
                        # The cursor is on the begining of line
                        else:
                                # If the cursor not on the first line
                                if self.cursorLine &gt;= 1:
                                        # Copy the current line to the end of previous line
                                        self.cursorColumn = len(self.lines[self.cursorLine-1])
                                        self.lines[self.cursorLine-1] = self.lines[self.cursorLine-1][:-1] + self.lines[self.cursorLine]
                                        del self.lines[self.cursorLine]
                                        self.view.scrollPartUp()
                                        self.cursorLine -= 1
                                        self.view.setRefreshAfter()
                                        self.changeColumn(-1)

        def delete(self):
                &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
                self.modified = True
                if self.removeSelection() == False:
                        line = self.lines[self.cursorLine]
                        if self.cursorColumn &lt; len(line):
                                # If the line is empty
                                if line[self.cursorColumn] == &#34;\n&#34;:
                                        # If the cursor not at end of files
                                        if self.cursorLine &lt; len(self.lines)-1:
                                                # Copy the next line to the current line
                                                self.lines[self.cursorLine] = line[:self.cursorColumn] + self.lines[self.cursorLine+1]
                                                del self.lines[self.cursorLine+1]
                                                self.view.scrollPartUp()
                                                self.view.setRefreshAfter()
                                # Else the char is deleted in the middle of line
                                else:
                                        line = line[0:self.cursorColumn:]+ line[self.cursorColumn+1  : :]
                                        self.lines[self.cursorLine] = line
                                        self.changeColumn(0)
                                        self.view.isRefreshLine = True

        def deleteLine(self):
                &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
                self.hideSelection()
                self.modified = True
                # If file contains one or none line
                if len(self.lines) &lt;= 1:
                        # Clean the content of file
                        self.lines = [&#34;&#34;]
                        self.cursorColumn = 0
                        self.cursorLine = 0
                        self.changeColumn(0)
                # If the current line is not the last of file
                elif self.cursorLine &lt; len(self.lines):
                        # Delete the line
                        self.cursorColumn = 0
                        del self.lines[self.cursorLine]
                        self.view.scrollPartUp()
                        if self.cursorLine &gt;= len(self.lines):
                                self.cursorLine = len(self.lines)-1
                        self.changeColumn(0)
                self.view.setRefreshAfter()

        def newLine(self):
                &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
                self.modified = True
                if self.removeSelection() == False:
                        line1 = self.lines[self.cursorLine][:self.cursorColumn]+&#34;\n&#34;
                        line2 = self.lines[self.cursorLine][self.cursorColumn:]
                        self.lines[self.cursorLine]=line1
                        self.lines.insert(self.cursorLine+1, line2)
                        self.view.scrollPartDown()
                        self.changeColumn(1)
                        self.view.setRefreshBefore()

        def insertChar(self, char):
                &#34;&#34;&#34; Insert character &#34;&#34;&#34;
                self.modified = True
                self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char + self.lines[self.cursorLine][self.cursorColumn:]
                self.changeColumn(1)
                self.view.setRefreshLine()

        def replaceChar(self, char):
                &#34;&#34;&#34; Replace character &#34;&#34;&#34;
                self.modified = True
                if self.cursorLine == len(self.lines)-1 and self.cursorColumn &gt;= len(self.lines[self.cursorLine])-1:
                        self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char 
                        self.changeColumn(1)
                        self.view.setRefreshLine()
                # If it is the last char in the line
                elif self.lines[self.cursorLine][self.cursorColumn] == &#34;\n&#34;:
                        # Append char to the line
                        self.insertChar(char)
                # Else the char must be replaced in the line
                else:
                        self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char + self.lines[self.cursorLine][self.cursorColumn+1:]
                        self.changeColumn(1)
                        self.view.setRefreshLine()

        def openSelection(self):
                &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
                if self.selectionStart == None:
                        self.selectionStart = [self.cursorColumn, self.cursorLine, self.getTabCursor(self.cursorLine)]

        def closeSelection(self):
                &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
                if self.selectionStart != None:
                        self.selectionEnd = [self.cursorColumn, self.cursorLine,self.getTabCursor(self.cursorLine)]

        def selectAll(self):
                &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
                self.selectionStart = [0,0,0]
                lastLine = len(self.lines)-1
                lastColumn = len(self.lines[lastLine])-1
                self.moveCursor(lastLine, lastColumn)
                self.selectionEnd  = [lastColumn, lastLine, self.getTabCursor(lastLine, lastColumn)]
                self.view.setRefreshAll()

        def getSelection(self):
                &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
                if self.selectionStart:
                        if self.selectionStart[1] &gt; self.selectionEnd[1]:
                                return self.selectionEnd, self.selectionStart
                        elif self.selectionStart[1] &lt; self.selectionEnd[1]:
                                return self.selectionStart, self.selectionEnd
                        elif self.selectionStart[0] &lt; self.selectionEnd[0]:
                                return self.selectionStart, self.selectionEnd
                        else:
                                return self.selectionEnd, self.selectionStart
                else:
                        return None, None

        def arrowUp(self, keys):
                &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
                self.hideSelection()
                self.changeLine(-len(keys))
        
        def arrowDown(self, keys):
                &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
                self.hideSelection()
                self.changeLine(len(keys))

        def arrowLeft(self, keys):
                &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
                self.hideSelection()
                self.changeColumn(-len(keys))

        def arrowRight(self, keys):
                &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
                self.hideSelection()
                self.changeColumn(len(keys))

        def selectUp(self, keys):
                &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
                self.openSelection()
                self.changeLine(-len(keys))
        
        def selectDown(self, keys):
                &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
                self.openSelection()
                self.changeLine(len(keys))

        def selectLeft(self, keys):
                &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
                self.openSelection()
                self.changeColumn(-len(keys))

        def selectRight(self, keys):
                &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
                self.openSelection()
                self.changeColumn(len(keys))

        def selectHome(self):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.openSelection()
                self.changeColumn(-100000000000)

        def selectEnd(self):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.openSelection()
                self.changeColumn(100000000000)

        def selectPageUp(self, keys):
                &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
                self.openSelection()
                self.changeLine((-self.view.height-1) * len(keys))
                self.changeColumn(-100000000000)

        def selectPageDown(self, keys):
                &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
                self.openSelection()
                self.changeLine((self.view.height+1) * len(keys))
                self.changeColumn(100000000000)

        def selectNextWord(self):
                &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
                self.openSelection()
                self.moveWord(1)

        def selectPreviousWord(self):
                &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
                self.openSelection()
                self.moveWord(-1)

        def pageUp(self, keys):
                &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
                self.hideSelection()
                self.changeLine((-self.view.height-1) * len(keys))

        def pageDown(self, keys):
                &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
                self.hideSelection()
                self.changeLine((self.view.height+1) * len(keys))

        def home(self):
                &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
                self.hideSelection()
                self.changeColumn(-100000000000)

        def end(self):
                &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
                self.hideSelection()
                self.changeColumn(100000000000)

        def addChar(self, keys):
                &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
                result = False

                if useful.isascii(keys[0]):
                        self.removeSelection()
                        for char in keys:
                                if useful.isascii(char):
                                        if self.replaceMode:
                                                self.replaceChar(char)
                                        else:
                                                self.insertChar(char)
                                        result = True
                # if result == False:
                        # print(useful.dump(keys[0]))
                return result

        def findNext(self, text):
                &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
                # Get the selection
                selectionStart, selectionEnd = self.getSelection()

                # Hide the selection
                self.hideSelection()

                # Set the start of search at the cursor position
                currentLine   = self.cursorLine
                currentColumn = self.cursorColumn

                # If selection activated
                if selectionStart != None and selectionEnd != None:
                        # If selection is on one line
                        if selectionStart[1] == selectionEnd[1] and currentLine == selectionStart[1]:
                                # If selection is exactly the size of text
                                if selectionStart[0] == currentColumn:
                                        # Move the start of search after the text selected
                                        currentColumn = selectionEnd[0]
                                        pass

                # Find the text in next lines
                while currentLine &lt; len(self.lines):
                        # Search text
                        pos = self.lines[currentLine].find(text, currentColumn)

                        # If text found
                        if pos &gt;= 0:
                                # Move the cursor to the text found
                                self.cursorLine = currentLine
                                self.cursorColumn = pos + len(text)
                                self.changeColumn(0)
                                self.selectionStart = [pos, currentLine,self.getTabCursor(currentLine,pos)]
                                self.selectionEnd   = [pos + len(text), currentLine, self.getTabCursor(currentLine, pos + len(text))]
                                break
                        else:
                                # Set the search position at the begin of next line
                                currentColumn = 0
                                currentLine += 1
                self.view.move()

        def findPrevious(self, text):
                &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
                # Get the selection
                selectionStart, selectionEnd = self.getSelection()

                # Hide the selection
                self.hideSelection()

                # Set the start of search at the cursor position
                currentLine   = self.cursorLine
                currentColumn = self.cursorColumn

                # If selection activated
                if selectionStart != None and selectionEnd != None:
                        # If selection is on one line
                        if selectionStart[1] == selectionEnd[1] and currentLine == selectionStart[1]:
                                # If selection is exactly the size of text
                                if selectionEnd[0] - selectionStart[0] == len(text):
                                        # Move the start of search before the text selected
                                        currentColumn = selectionStart[0]

                # While the line before the first line not reached
                while currentLine &gt;= 0:
                        # Get the current line
                        line = self.lines[currentLine]

                        # If the current column is negative
                        if currentColumn &lt; 0:
                                # Set the end of line
                                currentColumn = len(line)

                        # Search the text in reverse
                        pos = line.rfind(text, 0, currentColumn)

                        # If text found
                        if pos &gt;= 0:
                                self.cursorLine = currentLine
                                self.cursorColumn = pos
                                self.changeColumn(0)
                                self.selectionStart = [pos, currentLine,self.getTabCursor(currentLine,pos)]
                                self.selectionEnd   = [pos + len(text), currentLine, self.getTabCursor(currentLine, pos + len(text))]
                                break
                        else:
                                # Set the search position at the end of line
                                currentColumn = -1
                                currentLine -= 1
                self.view.move()

        def hideSelection(self):
                &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
                self.view.hideSelection()
                self.selectionStart = self.selectionEnd = None

        def goto(self, lineNumber):
                &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
                self.hideSelection()
                if lineNumber &lt; 0:
                        self.cursorLine = len(self.lines)-1
                elif lineNumber &lt; 1:
                        self.cursorLine = 1
                elif lineNumber &lt; len(self.lines):
                        self.cursorLine = lineNumber - 1
                else:
                        self.cursorLine = len(self.lines)-1
                self.cursorColumn = 0
                self.changeColumn(0)
                self.view.move()

        def copyClipboard(self):
                &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
                result = []
                if self.selectionStart != None:
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd
                        result = []
                        if selLineStart == selLineEnd:
                                result.append(self.lines[selLineStart][selColumnStart:selColumnEnd])
                        else:
                                for line in range(selLineStart, selLineEnd+1):
                                        if line == selLineStart:
                                                part = self.lines[line][selColumnStart:]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][selColumnStart:])
                                        elif line == selLineEnd:
                                                part = self.lines[line][:selColumnEnd]
                                                if part != &#34;&#34;:
                                                        result.append(self.lines[line][:selColumnEnd])
                                        else:
                                                result.append(self.lines[line])
                return result

        def removeSelection(self):
                &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
                if self.selectionStart != None:
                        self.modified = True
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd
                        start = self.lines[selLineStart][:selColumnStart]
                        end   = self.lines[selLineEnd  ][selColumnEnd:]
                        self.lines[selLineStart] = start + end
                        if selLineStart &lt; selLineEnd:
                                for line in range(selLineEnd, selLineStart,-1):
                                        del self.lines[line]
                        pass
                        self.moveCursor(selLineStart, selColumnStart)
                        self.hideSelection()
                        self.view.setRefreshAll()
                        return True
                return False

        def pasteClipboard(self, selection):
                &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
                if selection != []:
                        # Split the line with insertion
                        start = self.lines[self.cursorLine][:self.cursorColumn]
                        end   = self.lines[self.cursorLine][self.cursorColumn:]

                        # Paste the first line
                        self.lines[self.cursorLine] = start + selection[0]

                        self.cursorLine += 1

                        # Insert all lines from clipboard
                        for line in selection[1:-1]:
                                self.lines.insert(self.cursorLine, line)
                                self.cursorLine += 1

                        # If the last line of clipboard is not empty
                        if len(selection[-1]) &gt;= 1:
                                # If the last line of clipboard contains new line
                                if selection[-1][-1] == &#34;\n&#34;:
                                        if len(selection) &gt; 1:
                                                # Add the new line
                                                self.lines.insert(self.cursorLine, selection[-1])
                                                self.cursorLine += 1

                                        # Add the part after the insertion
                                        self.lines.insert(self.cursorLine, end)
                                        self.cursorColumn = 0
                                else:
                                        if len(selection) &gt; 1:
                                                self.lines.insert(self.cursorLine, selection[-1] + end)
                                                self.cursorColumn = len(selection[-1])
                                        else:
                                                self.cursorLine -= 1
                                                self.lines[self.cursorLine] += end
                                                self.cursorColumn = len(start) + len(selection[-1])
                                        
                        self.moveCursor(self.cursorLine, self.cursorColumn)
                        # self.view.setRefreshAll()

        def moveCursor(self, line, column):
                &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
                self.cursorLine   = line
                self.cursorColumn = column
                self.changeColumn(0)
                self.getTabCursorColumn()

        def copy(self):
                &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
                self.selection = self.copyClipboard()

        def cut(self):
                &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
                self.modified = True
                self.selection = self.copyClipboard()
                self.removeSelection()

        def paste(self):
                &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
                self.modified = True
                self.removeSelection()
                self.pasteClipboard(self.selection)
                self.view.setRefreshAll()
                self.hideSelection()

        def changeCase(self):
                &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
                selection = self.copyClipboard()
                if selection != []:
                        self.modified = True
                        selectionStart = self.selectionStart
                        selectionEnd   = self.selectionEnd

                        self.removeSelection()
                        isUpper = None
                        for line in selection:
                                for char in line:
                                        if useful.isupper(char):
                                                isUpper = True
                                                break
                                        elif useful.islower(char):
                                                isUpper = False
                                                break
                                if isUpper != None:
                                        break
                        for line in range(len(selection)):
                                if isUpper:
                                        selection[line] = selection[line].lower()
                                else:
                                        selection[line] = selection[line].upper()
                        self.pasteClipboard(selection)
                        self.view.setRefreshSelection()
                        self.selectionStart = selectionStart
                        self.selectionEnd   = selectionEnd

        def comment(self):
                &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
                self.modified = True

                # If selection
                if self.selectionStart != None:
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd

                        # Add tabulation
                        for line in range(selLineStart, selLineEnd+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] != &#39;#&#39;:
                                                self.lines[line] = &#34;#&#34; + self.lines[line]
                                        else:
                                                if len(self.lines[line]) &gt;= 1:
                                                        self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selectionStart = [0,selLineStart, 0]

                        # Get the length of last selected line
                        lenLineEnd =  len(self.lines[selLineEnd])

                        # Move the end of selection at the end of line selected
                        self.selectionEnd   = [lenLineEnd-1, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd-1)]
                        self.view.setRefreshSelection()
                else:
                        if len(self.lines[self.cursorLine]) &gt;= 1:
                                # If nothing selected
                                if self.lines[self.cursorLine][0] == &#34;#&#34;:
                                        self.lines[self.cursorLine] = self.lines[self.cursorLine][1:]
                                        if self.cursorColumn &gt; 0:
                                                self.changeColumn(-1)
                                else:
                                        self.lines[self.cursorLine] = &#34;#&#34; + self.lines[self.cursorLine]
                                        self.changeColumn(1)
                        self.view.setRefreshLine()

        def indent(self, keys):
                &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
                # If nothing selected
                if self.selectionStart == None:
                        self.addChar(keys)
                else:
                        self.modified = True
                        # Indent selection
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd

                        # If a part of line selected
                        if selLineStart == selLineEnd and not (selColumnStart == 0 and selColumnEnd == len(self.lines[selLineEnd])-1):
                                self.addChar(INDENT)
                        else:
                                # If the last line selected is at beginning of line
                                if selColumnEnd == 0:
                                        # This line must not be indented
                                        selLineEnd -= 1

                                # Add tabulation
                                for line in range(selLineStart, selLineEnd+1):
                                        self.lines[line] = &#34;\t&#34; + self.lines[line]

                                # Move the start selection to the start of first selected line
                                self.selectionStart = [0,selLineStart, 0]

                                # If the last line selected is not at beginning of line
                                if selColumnEnd &gt; 0:
                                        # Get the length of last selected line
                                        lenLineEnd =  len(self.lines[selLineEnd])

                                        # If the end of selection is not on the last line
                                        if selLineEnd &lt; len(self.lines)-1:
                                                lenLineEnd -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selectionEnd   = [lenLineEnd, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selectionEnd  = [0, selLineEnd+1, 0]
                        self.view.setRefreshSelection()

        def unindent(self, keys):
                &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
                # If nothing selected
                if self.selectionStart == None:
                        self.backspace()
                else:
                        self.modified = True
        
                        # Unindent selection
                        selectionStart, selectionEnd = self.getSelection()
                        selColumnStart, selLineStart, dummy = selectionStart
                        selColumnEnd,   selLineEnd,   dummy = selectionEnd

                        # If the selection is only alone line
                        if selLineStart == selLineEnd:
                                self.hideSelection()
                        else:
                                # If the last line selected is at beginning of line
                                if selColumnEnd == 0:
                                        # This line must not be indented
                                        selLineEnd -= 1

                                # Remove indentation
                                for line in range(selLineStart, selLineEnd+1):
                                        if len(self.lines[line]) &gt;= 1:
                                                if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                        self.lines[line] = self.lines[line][1:]

                                # Move the start selection to the start of first selected line
                                self.selectionStart = [0,selLineStart, 0]

                                # If the last line selected is not at beginning of line
                                if selColumnEnd &gt; 0:
                                        # Get the length of last selected line
                                        lenLineEnd =  len(self.lines[selLineEnd])

                                        # If the end of selection is not on the last line
                                        if selLineEnd &lt; len(self.lines)-1:
                                                lenLineEnd -= 1

                                        # Move the end of selection at the end of line selected
                                        self.selectionEnd   = [lenLineEnd, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd)]
                                else:
                                        # Move the end of selection at the start of the last line selected
                                        self.selectionEnd  = [0, selLineEnd+1, 0]
                        self.view.setRefreshSelection()

        def replace(self, old, new):
                &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
                if self.readOnly == False:
                        selection = self.copyClipboard()
                        if len(selection) == 1:
                                if selection[0] == old:
                                        self.delete()
                                        self.insertChar(new)
                                        return True
                return False

        def getCursorChar(self):
                &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
                return self.lines[self.cursorLine][self.cursorColumn]

        def moveWord(self, direction):
                &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
                state = 0
                while self.changeColumn(direction):
                        currentChar = self.getCursorChar()
                        if useful.ispunctuation(currentChar):
                                if state == 0:
                                        state = 2
                                elif state == 1:
                                        break
                        elif useful.isalpha(currentChar):
                                if state == 0:
                                        state = 1
                                elif state == 2:
                                        break
                        elif useful.isspace(currentChar):
                                if state == 1:
                                        break
                                if state == 2:
                                        break

        def nextWord(self):
                &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
                self.hideSelection()
                self.moveWord(1)
                self.view.move()

        def previousWord(self):
                &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
                self.hideSelection()
                self.moveWord(-1)
                self.view.move()

        def top(self):
                &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
                self.goto(1)

        def bottom(self):
                &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
                self.goto(100000000000)

        def treatKey(self, keys):
                &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
                # Move in the edit field
                if   keys[0] in UP  :            self.arrowUp(keys)
                elif keys[0] in DOWN:            self.arrowDown(keys)
                elif keys[0] in LEFT:            self.arrowLeft(keys)
                elif keys[0] in RIGHT:           self.arrowRight(keys)
                elif keys[0] in HOME:            self.home()
                elif keys[0] in END:             self.end()
                elif keys[0] in PAGE_UP:         self.pageUp(keys)
                elif keys[0] in PAGE_DOWN:       self.pageDown(keys)
                elif keys[0] in TOP:             self.top()
                elif keys[0] in BOTTOM:          self.bottom()
                elif keys[0] in NEXT_WORD:       self.nextWord()
                elif keys[0] in PREVIOUS_WORD:   self.previousWord()
                # Selection the edit field
                elif keys[0] in SELECT_UP:       self.selectUp(keys)
                elif keys[0] in SELECT_DOWN:     self.selectDown(keys)
                elif keys[0] in SELECT_RIGHT:    self.selectRight(keys)
                elif keys[0] in SELECT_LEFT:     self.selectLeft(keys)
                elif keys[0] in SELECT_HOME:     self.selectHome()
                elif keys[0] in SELECT_END:      self.selectEnd()
                elif keys[0] in SELECT_PAGE_UP:  self.selectPageUp(keys)
                elif keys[0] in SELECT_PAGE_DOWN:self.selectPageDown(keys)
                elif keys[0] in SELECT_ALL:      self.selectAll()
                elif keys[0] in SELECT_NEXT_WORD:self.selectNextWord()
                elif keys[0] in SELECT_PREV_WORD:self.selectPreviousWord()

                # If the edit is not in read only 
                elif self.readOnly == False:
                        # Modification in the edit field
                        if   keys[0] in COPY:            self.copy()
                        elif keys[0] in CUT:             self.cut()
                        elif keys[0] in PASTE:           self.paste()

                        elif keys[0] in INDENT:          self.indent(keys)
                        elif keys[0] in UNINDENT:        self.unindent(keys)
                        elif keys[0] in CHANGE_CASE:     self.changeCase()
                        elif keys[0] in COMMENT:         self.comment()

                        elif keys[0] in BACKSPACE:       self.backspace()
                        elif keys[0] in DELETE:          self.delete()
                        elif keys[0] in NEW_LINE:        self.newLine()
                        elif keys[0] in DELETE_LINE:     self.deleteLine()
                        else: self.addChar(keys)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.Text.addChar"><code class="name flex">
<span>def <span class="ident">addChar</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage other key, add character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addChar(self, keys):
        &#34;&#34;&#34; Manage other key, add character &#34;&#34;&#34;
        result = False

        if useful.isascii(keys[0]):
                self.removeSelection()
                for char in keys:
                        if useful.isascii(char):
                                if self.replaceMode:
                                        self.replaceChar(char)
                                else:
                                        self.insertChar(char)
                                result = True
        # if result == False:
                # print(useful.dump(keys[0]))
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrowDown"><code class="name flex">
<span>def <span class="ident">arrowDown</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrowDown(self, keys):
        &#34;&#34;&#34; Manage arrow down key &#34;&#34;&#34;
        self.hideSelection()
        self.changeLine(len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrowLeft"><code class="name flex">
<span>def <span class="ident">arrowLeft</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow left key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrowLeft(self, keys):
        &#34;&#34;&#34; Manage arrow left key &#34;&#34;&#34;
        self.hideSelection()
        self.changeColumn(-len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrowRight"><code class="name flex">
<span>def <span class="ident">arrowRight</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow right key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrowRight(self, keys):
        &#34;&#34;&#34; Manage arrow right key &#34;&#34;&#34;
        self.hideSelection()
        self.changeColumn(len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.arrowUp"><code class="name flex">
<span>def <span class="ident">arrowUp</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage arrow up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arrowUp(self, keys):
        &#34;&#34;&#34; Manage arrow up key &#34;&#34;&#34;
        self.hideSelection()
        self.changeLine(-len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.backspace"><code class="name flex">
<span>def <span class="ident">backspace</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the backspace key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backspace(self):
        &#34;&#34;&#34; Manage the backspace key &#34;&#34;&#34;
        self.modified = True
        if self.removeSelection() == False:
                # The cursor not in the begining of line
                if self.cursorColumn &gt;= 1:
                        line = self.lines[self.cursorLine]
                        line = line[0:self.cursorColumn-1:]+ line[self.cursorColumn  : :]
                        self.lines[self.cursorLine] = line
                        self.changeColumn(-1)
                        self.view.setRefreshLine()
                # The cursor is on the begining of line
                else:
                        # If the cursor not on the first line
                        if self.cursorLine &gt;= 1:
                                # Copy the current line to the end of previous line
                                self.cursorColumn = len(self.lines[self.cursorLine-1])
                                self.lines[self.cursorLine-1] = self.lines[self.cursorLine-1][:-1] + self.lines[self.cursorLine]
                                del self.lines[self.cursorLine]
                                self.view.scrollPartUp()
                                self.cursorLine -= 1
                                self.view.setRefreshAfter()
                                self.changeColumn(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.bottom"><code class="name flex">
<span>def <span class="ident">bottom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the last line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bottom(self):
        &#34;&#34;&#34; Move the cursor to the last line of text &#34;&#34;&#34;
        self.goto(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.changeCase"><code class="name flex">
<span>def <span class="ident">changeCase</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the case of selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeCase(self):
        &#34;&#34;&#34; Change the case of selection &#34;&#34;&#34;
        selection = self.copyClipboard()
        if selection != []:
                self.modified = True
                selectionStart = self.selectionStart
                selectionEnd   = self.selectionEnd

                self.removeSelection()
                isUpper = None
                for line in selection:
                        for char in line:
                                if useful.isupper(char):
                                        isUpper = True
                                        break
                                elif useful.islower(char):
                                        isUpper = False
                                        break
                        if isUpper != None:
                                break
                for line in range(len(selection)):
                        if isUpper:
                                selection[line] = selection[line].lower()
                        else:
                                selection[line] = selection[line].upper()
                self.pasteClipboard(selection)
                self.view.setRefreshSelection()
                self.selectionStart = selectionStart
                self.selectionEnd   = selectionEnd</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.changeColumn"><code class="name flex">
<span>def <span class="ident">changeColumn</span></span>(<span>self, moveColumn)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor on another column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeColumn(self, moveColumn):
        &#34;&#34;&#34; Move the cursor on another column &#34;&#34;&#34;
        cursorLine   = self.cursorLine
        cursorColumn = self.cursorColumn
        # If the cursor go to the previous line
        if moveColumn + self.cursorColumn &lt; 0:
                # If start of line
                if abs(moveColumn) &gt; 1:
                        self.cursorColumn = 0
                # If move to the left and must go to previous line
                elif self.cursorLine &gt; 0:
                        self.cursorLine -= 1
                        self.cursorColumn = len(self.lines[self.cursorLine])-1
        # If the cursor is at the end of line
        elif moveColumn + self.cursorColumn &gt; len(self.lines[self.cursorLine])-1:
                # If the cursor is on the last line of file
                if abs(moveColumn) &gt; 1 or self.cursorLine+1 == len(self.lines):
                        # If the file is empty
                        if self.lines[self.cursorLine] == &#34;&#34;:
                                self.cursorColumn = 0
                                self.tabCursorColumn = 0
                        # If the last line of contains return char
                        elif self.lines[self.cursorLine][-1] == &#34;\n&#34;:
                                # Move cursor before return
                                self.cursorColumn = len(self.lines[self.cursorLine])-1
                        else:
                                # Move cursor after the last char
                                self.cursorColumn = len(self.lines[self.cursorLine])

                # If the cursor is on the end of line and must change of line
                elif self.cursorLine+1 &lt; len(self.lines):
                        self.cursorLine += 1
                        self.cursorColumn = 0
                        self.tabCursorColumn = 0
        # Normal move of cursor
        else:
                # Next or previous column
                self.cursorColumn += moveColumn
        if abs(moveColumn) &gt; 0:
                self.getTabCursorColumn()
        self.closeSelection()
        self.view.move()
        if self.cursorColumn == cursorColumn and self.cursorLine == cursorLine:
                return False
        else:
                return True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.changeLine"><code class="name flex">
<span>def <span class="ident">changeLine</span></span>(<span>self, moveLine)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor on another line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changeLine(self, moveLine):
        &#34;&#34;&#34; Move the cursor on another line &#34;&#34;&#34;
        # If cursor is before the first line
        if moveLine + self.cursorLine &lt; 0:
                # Set the cursor to the first line
                self.cursorLine = 0
                self.setCursorColumn()
                self.changeColumn(0)
        # If the cursor is after the last line
        elif moveLine + self.cursorLine &gt;= len(self.lines):
                self.cursorLine = len(self.lines) -1
                self.setCursorColumn()
                self.changeColumn(0)
        # else the cursor is in the lines of text
        else:
                previousLine = self.cursorLine
                self.cursorLine += moveLine
                lenLine = len(self.lines[self.cursorLine])-1

                self.setCursorColumn()
                # If the new cursor position is outside the last line of text
                if self.cursorColumn &gt; lenLine:
                        self.cursorColumn = lenLine

        if self.selectionStart != None:
                self.selectionEnd = [self.cursorColumn, self.cursorLine,self.getTabCursor(self.cursorLine)]
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.closeSelection"><code class="name flex">
<span>def <span class="ident">closeSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Terminate selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closeSelection(self):
        &#34;&#34;&#34; Terminate selection &#34;&#34;&#34;
        if self.selectionStart != None:
                self.selectionEnd = [self.cursorColumn, self.cursorLine,self.getTabCursor(self.cursorLine)]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.comment"><code class="name flex">
<span>def <span class="ident">comment</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Comment the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comment(self):
        &#34;&#34;&#34; Comment the selection &#34;&#34;&#34;
        self.modified = True

        # If selection
        if self.selectionStart != None:
                selectionStart, selectionEnd = self.getSelection()
                selColumnStart, selLineStart, dummy = selectionStart
                selColumnEnd,   selLineEnd,   dummy = selectionEnd

                # Add tabulation
                for line in range(selLineStart, selLineEnd+1):
                        if len(self.lines[line]) &gt;= 1:
                                if self.lines[line][0] != &#39;#&#39;:
                                        self.lines[line] = &#34;#&#34; + self.lines[line]
                                else:
                                        if len(self.lines[line]) &gt;= 1:
                                                self.lines[line] = self.lines[line][1:]

                # Move the start selection to the start of first selected line
                self.selectionStart = [0,selLineStart, 0]

                # Get the length of last selected line
                lenLineEnd =  len(self.lines[selLineEnd])

                # Move the end of selection at the end of line selected
                self.selectionEnd   = [lenLineEnd-1, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd-1)]
                self.view.setRefreshSelection()
        else:
                if len(self.lines[self.cursorLine]) &gt;= 1:
                        # If nothing selected
                        if self.lines[self.cursorLine][0] == &#34;#&#34;:
                                self.lines[self.cursorLine] = self.lines[self.cursorLine][1:]
                                if self.cursorColumn &gt; 0:
                                        self.changeColumn(-1)
                        else:
                                self.lines[self.cursorLine] = &#34;#&#34; + self.lines[self.cursorLine]
                                self.changeColumn(1)
                self.view.setRefreshLine()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage copy key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
        &#34;&#34;&#34; Manage copy key &#34;&#34;&#34;
        self.selection = self.copyClipboard()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.copyClipboard"><code class="name flex">
<span>def <span class="ident">copyClipboard</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy selection to clipboard</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copyClipboard(self):
        &#34;&#34;&#34; Copy selection to clipboard &#34;&#34;&#34;
        result = []
        if self.selectionStart != None:
                selectionStart, selectionEnd = self.getSelection()
                selColumnStart, selLineStart, dummy = selectionStart
                selColumnEnd,   selLineEnd,   dummy = selectionEnd
                result = []
                if selLineStart == selLineEnd:
                        result.append(self.lines[selLineStart][selColumnStart:selColumnEnd])
                else:
                        for line in range(selLineStart, selLineEnd+1):
                                if line == selLineStart:
                                        part = self.lines[line][selColumnStart:]
                                        if part != &#34;&#34;:
                                                result.append(self.lines[line][selColumnStart:])
                                elif line == selLineEnd:
                                        part = self.lines[line][:selColumnEnd]
                                        if part != &#34;&#34;:
                                                result.append(self.lines[line][:selColumnEnd])
                                else:
                                        result.append(self.lines[line])
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.cut"><code class="name flex">
<span>def <span class="ident">cut</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage cut key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut(self):
        &#34;&#34;&#34; Manage cut key &#34;&#34;&#34;
        self.modified = True
        self.selection = self.copyClipboard()
        self.removeSelection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the delete key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self):
        &#34;&#34;&#34; Manage the delete key &#34;&#34;&#34;
        self.modified = True
        if self.removeSelection() == False:
                line = self.lines[self.cursorLine]
                if self.cursorColumn &lt; len(line):
                        # If the line is empty
                        if line[self.cursorColumn] == &#34;\n&#34;:
                                # If the cursor not at end of files
                                if self.cursorLine &lt; len(self.lines)-1:
                                        # Copy the next line to the current line
                                        self.lines[self.cursorLine] = line[:self.cursorColumn] + self.lines[self.cursorLine+1]
                                        del self.lines[self.cursorLine+1]
                                        self.view.scrollPartUp()
                                        self.view.setRefreshAfter()
                        # Else the char is deleted in the middle of line
                        else:
                                line = line[0:self.cursorColumn:]+ line[self.cursorColumn+1  : :]
                                self.lines[self.cursorLine] = line
                                self.changeColumn(0)
                                self.view.isRefreshLine = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.deleteLine"><code class="name flex">
<span>def <span class="ident">deleteLine</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the delete of line key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteLine(self):
        &#34;&#34;&#34; Manage the delete of line key &#34;&#34;&#34;
        self.hideSelection()
        self.modified = True
        # If file contains one or none line
        if len(self.lines) &lt;= 1:
                # Clean the content of file
                self.lines = [&#34;&#34;]
                self.cursorColumn = 0
                self.cursorLine = 0
                self.changeColumn(0)
        # If the current line is not the last of file
        elif self.cursorLine &lt; len(self.lines):
                # Delete the line
                self.cursorColumn = 0
                del self.lines[self.cursorLine]
                self.view.scrollPartUp()
                if self.cursorLine &gt;= len(self.lines):
                        self.cursorLine = len(self.lines)-1
                self.changeColumn(0)
        self.view.setRefreshAfter()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage end key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self):
        &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
        self.hideSelection()
        self.changeColumn(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.findNext"><code class="name flex">
<span>def <span class="ident">findNext</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Find next researched text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findNext(self, text):
        &#34;&#34;&#34; Find next researched text &#34;&#34;&#34;
        # Get the selection
        selectionStart, selectionEnd = self.getSelection()

        # Hide the selection
        self.hideSelection()

        # Set the start of search at the cursor position
        currentLine   = self.cursorLine
        currentColumn = self.cursorColumn

        # If selection activated
        if selectionStart != None and selectionEnd != None:
                # If selection is on one line
                if selectionStart[1] == selectionEnd[1] and currentLine == selectionStart[1]:
                        # If selection is exactly the size of text
                        if selectionStart[0] == currentColumn:
                                # Move the start of search after the text selected
                                currentColumn = selectionEnd[0]
                                pass

        # Find the text in next lines
        while currentLine &lt; len(self.lines):
                # Search text
                pos = self.lines[currentLine].find(text, currentColumn)

                # If text found
                if pos &gt;= 0:
                        # Move the cursor to the text found
                        self.cursorLine = currentLine
                        self.cursorColumn = pos + len(text)
                        self.changeColumn(0)
                        self.selectionStart = [pos, currentLine,self.getTabCursor(currentLine,pos)]
                        self.selectionEnd   = [pos + len(text), currentLine, self.getTabCursor(currentLine, pos + len(text))]
                        break
                else:
                        # Set the search position at the begin of next line
                        currentColumn = 0
                        currentLine += 1
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.findPrevious"><code class="name flex">
<span>def <span class="ident">findPrevious</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Find previous researched text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findPrevious(self, text):
        &#34;&#34;&#34; Find previous researched text &#34;&#34;&#34;
        # Get the selection
        selectionStart, selectionEnd = self.getSelection()

        # Hide the selection
        self.hideSelection()

        # Set the start of search at the cursor position
        currentLine   = self.cursorLine
        currentColumn = self.cursorColumn

        # If selection activated
        if selectionStart != None and selectionEnd != None:
                # If selection is on one line
                if selectionStart[1] == selectionEnd[1] and currentLine == selectionStart[1]:
                        # If selection is exactly the size of text
                        if selectionEnd[0] - selectionStart[0] == len(text):
                                # Move the start of search before the text selected
                                currentColumn = selectionStart[0]

        # While the line before the first line not reached
        while currentLine &gt;= 0:
                # Get the current line
                line = self.lines[currentLine]

                # If the current column is negative
                if currentColumn &lt; 0:
                        # Set the end of line
                        currentColumn = len(line)

                # Search the text in reverse
                pos = line.rfind(text, 0, currentColumn)

                # If text found
                if pos &gt;= 0:
                        self.cursorLine = currentLine
                        self.cursorColumn = pos
                        self.changeColumn(0)
                        self.selectionStart = [pos, currentLine,self.getTabCursor(currentLine,pos)]
                        self.selectionEnd   = [pos + len(text), currentLine, self.getTabCursor(currentLine, pos + len(text))]
                        break
                else:
                        # Set the search position at the end of line
                        currentColumn = -1
                        currentLine -= 1
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.getCountLines"><code class="name flex">
<span>def <span class="ident">getCountLines</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the total of lines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCountLines(self):
        &#34;&#34;&#34; Get the total of lines &#34;&#34;&#34;
        return len(self.lines)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.getCursorChar"><code class="name flex">
<span>def <span class="ident">getCursorChar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the char on the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCursorChar(self):
        &#34;&#34;&#34; Get the char on the cursor &#34;&#34;&#34;
        return self.lines[self.cursorLine][self.cursorColumn]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.getCursorLine"><code class="name flex">
<span>def <span class="ident">getCursorLine</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the current line of the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCursorLine(self):
        &#34;&#34;&#34; Get the current line of the cursor &#34;&#34;&#34;
        return self.cursorLine</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.getSelection"><code class="name flex">
<span>def <span class="ident">getSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get information about selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSelection(self):
        &#34;&#34;&#34; Get information about selection &#34;&#34;&#34;
        if self.selectionStart:
                if self.selectionStart[1] &gt; self.selectionEnd[1]:
                        return self.selectionEnd, self.selectionStart
                elif self.selectionStart[1] &lt; self.selectionEnd[1]:
                        return self.selectionStart, self.selectionEnd
                elif self.selectionStart[0] &lt; self.selectionEnd[0]:
                        return self.selectionStart, self.selectionEnd
                else:
                        return self.selectionEnd, self.selectionStart
        else:
                return None, None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.getTabCursor"><code class="name flex">
<span>def <span class="ident">getTabCursor</span></span>(<span>self, currentLine, currentColumn=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get position of cursor with line with tabulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTabCursor(self, currentLine, currentColumn=None):
        &#34;&#34;&#34; Get position of cursor with line with tabulation &#34;&#34;&#34;
        if currentColumn == None:
                cursorColumn = self.cursorColumn
        else:
                cursorColumn = currentColumn
        line = self.lines[currentLine]
        if &#34;\t&#34; in line:
                tabCursorColumn   = 0
                column = 0
                for char in line:
                        if column == cursorColumn:
                                break
                        if char == &#34;\t&#34;:
                                pos = tabCursorColumn%self.tabSize
                                tabCursorColumn += self.tabSize-pos
                        else:
                                tabCursorColumn += 1
                        column += 1
                return tabCursorColumn
        else:
                return cursorColumn</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.getTabCursorColumn"><code class="name flex">
<span>def <span class="ident">getTabCursorColumn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the column of cursor in tabuled line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTabCursorColumn(self):
        &#34;&#34;&#34; Get the column of cursor in tabuled line &#34;&#34;&#34;
        line = self.lines[self.cursorLine]
        column = 0
        self.tabCursorColumn = 0
        while column &lt; self.cursorColumn:
                if line[column] == &#34;\t&#34;:
                        pos = self.tabCursorColumn%self.tabSize
                        self.tabCursorColumn += self.tabSize-pos
                        column += 1
                else:
                        tab = line.find(&#34;\t&#34;,column)
                        if tab &gt; 0:
                                delta = tab - column
                                if column + delta &gt; self.cursorColumn:
                                        delta = self.cursorColumn - column
                                        self.tabCursorColumn += delta
                                        column += delta
                                else:
                                        self.tabCursorColumn += delta
                                        column += delta
                        else:
                                delta = self.cursorColumn - column
                                self.tabCursorColumn += delta
                                column += delta</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.getTabLine"><code class="name flex">
<span>def <span class="ident">getTabLine</span></span>(<span>self, currentLine=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the tabuled line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getTabLine(self, currentLine = None):
        &#34;&#34;&#34; Get the tabuled line &#34;&#34;&#34;
        line = self.lines[currentLine]
        tabLine = &#34;&#34;
        tabCursorColumn   = 0
        lenLine = len(line)
        column = 0
        while column &lt; lenLine: 
                char = line[column]
                if char == &#34;\t&#34;:
                        pos = tabCursorColumn%self.tabSize
                        tabCursorColumn += self.tabSize-pos
                        tabLine         += &#34; &#34;*(self.tabSize-pos)
                        column          += 1
                else:
                        tab = line.find(&#34;\t&#34;,column)
                        if tab &gt; 0:
                                part = line[column:tab]
                        else:
                                part = line[column:]
                        tabCursorColumn += len(part)
                        tabLine         += part
                        column          += len(part)
        return tabLine</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.goto"><code class="name flex">
<span>def <span class="ident">goto</span></span>(<span>self, lineNumber)</span>
</code></dt>
<dd>
<div class="desc"><p>Goto specified line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def goto(self, lineNumber):
        &#34;&#34;&#34; Goto specified line &#34;&#34;&#34;
        self.hideSelection()
        if lineNumber &lt; 0:
                self.cursorLine = len(self.lines)-1
        elif lineNumber &lt; 1:
                self.cursorLine = 1
        elif lineNumber &lt; len(self.lines):
                self.cursorLine = lineNumber - 1
        else:
                self.cursorLine = len(self.lines)-1
        self.cursorColumn = 0
        self.changeColumn(0)
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.hideSelection"><code class="name flex">
<span>def <span class="ident">hideSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hideSelection(self):
        &#34;&#34;&#34; Hide selection &#34;&#34;&#34;
        self.view.hideSelection()
        self.selectionStart = self.selectionEnd = None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.home"><code class="name flex">
<span>def <span class="ident">home</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage home key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def home(self):
        &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
        self.hideSelection()
        self.changeColumn(-100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.indent"><code class="name flex">
<span>def <span class="ident">indent</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage tabulation key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indent(self, keys):
        &#34;&#34;&#34; Manage tabulation key &#34;&#34;&#34;
        # If nothing selected
        if self.selectionStart == None:
                self.addChar(keys)
        else:
                self.modified = True
                # Indent selection
                selectionStart, selectionEnd = self.getSelection()
                selColumnStart, selLineStart, dummy = selectionStart
                selColumnEnd,   selLineEnd,   dummy = selectionEnd

                # If a part of line selected
                if selLineStart == selLineEnd and not (selColumnStart == 0 and selColumnEnd == len(self.lines[selLineEnd])-1):
                        self.addChar(INDENT)
                else:
                        # If the last line selected is at beginning of line
                        if selColumnEnd == 0:
                                # This line must not be indented
                                selLineEnd -= 1

                        # Add tabulation
                        for line in range(selLineStart, selLineEnd+1):
                                self.lines[line] = &#34;\t&#34; + self.lines[line]

                        # Move the start selection to the start of first selected line
                        self.selectionStart = [0,selLineStart, 0]

                        # If the last line selected is not at beginning of line
                        if selColumnEnd &gt; 0:
                                # Get the length of last selected line
                                lenLineEnd =  len(self.lines[selLineEnd])

                                # If the end of selection is not on the last line
                                if selLineEnd &lt; len(self.lines)-1:
                                        lenLineEnd -= 1

                                # Move the end of selection at the end of line selected
                                self.selectionEnd   = [lenLineEnd, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd)]
                        else:
                                # Move the end of selection at the start of the last line selected
                                self.selectionEnd  = [0, selLineEnd+1, 0]
                self.view.setRefreshSelection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.insertChar"><code class="name flex">
<span>def <span class="ident">insertChar</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertChar(self, char):
        &#34;&#34;&#34; Insert character &#34;&#34;&#34;
        self.modified = True
        self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char + self.lines[self.cursorLine][self.cursorColumn:]
        self.changeColumn(1)
        self.view.setRefreshLine()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load file in the editor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, filename):
        &#34;&#34;&#34; Load file in the editor &#34;&#34;&#34;
        self.filename = None
        try:
                self.lines = []
                self.filename = filename
                file = open(filename, &#34;r&#34;)
                line = file.readline()
                while line != &#34;&#34;:
                        self.lines.append(line.replace(&#34;\r\n&#34;,&#34;\n&#34;))
                        line = file.readline()
                file.close()
                if len(self.lines) == 0:
                        self.lines = [&#34;&#34;]
        except MemoryError:
                raise MemoryError()
        except OSError:
                self.lines = [&#34;&#34;]
                # File not existing
        except Exception as error:
                print(useful.exception(error))
                self.lines = [&#34;&#34;]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.moveCursor"><code class="name flex">
<span>def <span class="ident">moveCursor</span></span>(<span>self, line, column)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveCursor(self, line, column):
        &#34;&#34;&#34; Move the cursor &#34;&#34;&#34;
        self.cursorLine   = line
        self.cursorColumn = column
        self.changeColumn(0)
        self.getTabCursorColumn()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.moveWord"><code class="name flex">
<span>def <span class="ident">moveWord</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveWord(self, direction):
        &#34;&#34;&#34; Move the cursor to the word &#34;&#34;&#34;
        state = 0
        while self.changeColumn(direction):
                currentChar = self.getCursorChar()
                if useful.ispunctuation(currentChar):
                        if state == 0:
                                state = 2
                        elif state == 1:
                                break
                elif useful.isalpha(currentChar):
                        if state == 0:
                                state = 1
                        elif state == 2:
                                break
                elif useful.isspace(currentChar):
                        if state == 1:
                                break
                        if state == 2:
                                break</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.newLine"><code class="name flex">
<span>def <span class="ident">newLine</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the newline key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newLine(self):
        &#34;&#34;&#34; Manage the newline key &#34;&#34;&#34;
        self.modified = True
        if self.removeSelection() == False:
                line1 = self.lines[self.cursorLine][:self.cursorColumn]+&#34;\n&#34;
                line2 = self.lines[self.cursorLine][self.cursorColumn:]
                self.lines[self.cursorLine]=line1
                self.lines.insert(self.cursorLine+1, line2)
                self.view.scrollPartDown()
                self.changeColumn(1)
                self.view.setRefreshBefore()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.nextWord"><code class="name flex">
<span>def <span class="ident">nextWord</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the next word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nextWord(self):
        &#34;&#34;&#34; Move the cursor to the next word &#34;&#34;&#34;
        self.hideSelection()
        self.moveWord(1)
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.openSelection"><code class="name flex">
<span>def <span class="ident">openSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def openSelection(self):
        &#34;&#34;&#34; Start a selection &#34;&#34;&#34;
        if self.selectionStart == None:
                self.selectionStart = [self.cursorColumn, self.cursorLine, self.getTabCursor(self.cursorLine)]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.pageDown"><code class="name flex">
<span>def <span class="ident">pageDown</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage page down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pageDown(self, keys):
        &#34;&#34;&#34; Manage page down key &#34;&#34;&#34;
        self.hideSelection()
        self.changeLine((self.view.height+1) * len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.pageUp"><code class="name flex">
<span>def <span class="ident">pageUp</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage page up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pageUp(self, keys):
        &#34;&#34;&#34; Manage page up key &#34;&#34;&#34;
        self.hideSelection()
        self.changeLine((-self.view.height-1) * len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.paste"><code class="name flex">
<span>def <span class="ident">paste</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage paste key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paste(self):
        &#34;&#34;&#34; Manage paste key &#34;&#34;&#34;
        self.modified = True
        self.removeSelection()
        self.pasteClipboard(self.selection)
        self.view.setRefreshAll()
        self.hideSelection()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.pasteClipboard"><code class="name flex">
<span>def <span class="ident">pasteClipboard</span></span>(<span>self, selection)</span>
</code></dt>
<dd>
<div class="desc"><p>Paste clipboard at the cursor position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pasteClipboard(self, selection):
        &#34;&#34;&#34; Paste clipboard at the cursor position &#34;&#34;&#34;
        if selection != []:
                # Split the line with insertion
                start = self.lines[self.cursorLine][:self.cursorColumn]
                end   = self.lines[self.cursorLine][self.cursorColumn:]

                # Paste the first line
                self.lines[self.cursorLine] = start + selection[0]

                self.cursorLine += 1

                # Insert all lines from clipboard
                for line in selection[1:-1]:
                        self.lines.insert(self.cursorLine, line)
                        self.cursorLine += 1

                # If the last line of clipboard is not empty
                if len(selection[-1]) &gt;= 1:
                        # If the last line of clipboard contains new line
                        if selection[-1][-1] == &#34;\n&#34;:
                                if len(selection) &gt; 1:
                                        # Add the new line
                                        self.lines.insert(self.cursorLine, selection[-1])
                                        self.cursorLine += 1

                                # Add the part after the insertion
                                self.lines.insert(self.cursorLine, end)
                                self.cursorColumn = 0
                        else:
                                if len(selection) &gt; 1:
                                        self.lines.insert(self.cursorLine, selection[-1] + end)
                                        self.cursorColumn = len(selection[-1])
                                else:
                                        self.cursorLine -= 1
                                        self.lines[self.cursorLine] += end
                                        self.cursorColumn = len(start) + len(selection[-1])
                                
                self.moveCursor(self.cursorLine, self.cursorColumn)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.previousWord"><code class="name flex">
<span>def <span class="ident">previousWord</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the previous word</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previousWord(self):
        &#34;&#34;&#34; Move the cursor to the previous word &#34;&#34;&#34;
        self.hideSelection()
        self.moveWord(-1)
        self.view.move()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.removeSelection"><code class="name flex">
<span>def <span class="ident">removeSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def removeSelection(self):
        &#34;&#34;&#34; Remove selection &#34;&#34;&#34;
        if self.selectionStart != None:
                self.modified = True
                selectionStart, selectionEnd = self.getSelection()
                selColumnStart, selLineStart, dummy = selectionStart
                selColumnEnd,   selLineEnd,   dummy = selectionEnd
                start = self.lines[selLineStart][:selColumnStart]
                end   = self.lines[selLineEnd  ][selColumnEnd:]
                self.lines[selLineStart] = start + end
                if selLineStart &lt; selLineEnd:
                        for line in range(selLineEnd, selLineStart,-1):
                                del self.lines[line]
                pass
                self.moveCursor(selLineStart, selColumnStart)
                self.hideSelection()
                self.view.setRefreshAll()
                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, old, new)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, old, new):
        &#34;&#34;&#34; Replace the selection &#34;&#34;&#34;
        if self.readOnly == False:
                selection = self.copyClipboard()
                if len(selection) == 1:
                        if selection[0] == old:
                                self.delete()
                                self.insertChar(new)
                                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.replaceChar"><code class="name flex">
<span>def <span class="ident">replaceChar</span></span>(<span>self, char)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replaceChar(self, char):
        &#34;&#34;&#34; Replace character &#34;&#34;&#34;
        self.modified = True
        if self.cursorLine == len(self.lines)-1 and self.cursorColumn &gt;= len(self.lines[self.cursorLine])-1:
                self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char 
                self.changeColumn(1)
                self.view.setRefreshLine()
        # If it is the last char in the line
        elif self.lines[self.cursorLine][self.cursorColumn] == &#34;\n&#34;:
                # Append char to the line
                self.insertChar(char)
        # Else the char must be replaced in the line
        else:
                self.lines[self.cursorLine] = self.lines[self.cursorLine][:self.cursorColumn] + char + self.lines[self.cursorLine][self.cursorColumn+1:]
                self.changeColumn(1)
                self.view.setRefreshLine()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save text in the file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
        &#34;&#34;&#34; Save text in the file &#34;&#34;&#34;
        result = False
        if self.readOnly == False:
                if self.filename != None:
                        try:
                                file = open(self.filename, &#34;w&#34;)
                                for line in self.lines:
                                        file.write(line)
                                file.close()
                                self.modified = False
                                result = True
                        except Exception as error:
                                print(useful.exception(error))
        return result</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectAll"><code class="name flex">
<span>def <span class="ident">selectAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Do a select all</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectAll(self):
        &#34;&#34;&#34; Do a select all &#34;&#34;&#34;
        self.selectionStart = [0,0,0]
        lastLine = len(self.lines)-1
        lastColumn = len(self.lines[lastLine])-1
        self.moveCursor(lastLine, lastColumn)
        self.selectionEnd  = [lastColumn, lastLine, self.getTabCursor(lastLine, lastColumn)]
        self.view.setRefreshAll()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectDown"><code class="name flex">
<span>def <span class="ident">selectDown</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectDown(self, keys):
        &#34;&#34;&#34; Manage select down key &#34;&#34;&#34;
        self.openSelection()
        self.changeLine(len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectEnd"><code class="name flex">
<span>def <span class="ident">selectEnd</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage end key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectEnd(self):
        &#34;&#34;&#34; Manage end key &#34;&#34;&#34;
        self.openSelection()
        self.changeColumn(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectHome"><code class="name flex">
<span>def <span class="ident">selectHome</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage home key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectHome(self):
        &#34;&#34;&#34; Manage home key &#34;&#34;&#34;
        self.openSelection()
        self.changeColumn(-100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectLeft"><code class="name flex">
<span>def <span class="ident">selectLeft</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select left key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectLeft(self, keys):
        &#34;&#34;&#34; Manage select left key &#34;&#34;&#34;
        self.openSelection()
        self.changeColumn(-len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectNextWord"><code class="name flex">
<span>def <span class="ident">selectNextWord</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select next word key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectNextWord(self):
        &#34;&#34;&#34; Manage select next word key &#34;&#34;&#34;
        self.openSelection()
        self.moveWord(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectPageDown"><code class="name flex">
<span>def <span class="ident">selectPageDown</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select page down key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectPageDown(self, keys):
        &#34;&#34;&#34; Manage select page down key &#34;&#34;&#34;
        self.openSelection()
        self.changeLine((self.view.height+1) * len(keys))
        self.changeColumn(100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectPageUp"><code class="name flex">
<span>def <span class="ident">selectPageUp</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select page up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectPageUp(self, keys):
        &#34;&#34;&#34; Manage select page up key &#34;&#34;&#34;
        self.openSelection()
        self.changeLine((-self.view.height-1) * len(keys))
        self.changeColumn(-100000000000)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectPreviousWord"><code class="name flex">
<span>def <span class="ident">selectPreviousWord</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select previous word key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectPreviousWord(self):
        &#34;&#34;&#34; Manage select previous word key &#34;&#34;&#34;
        self.openSelection()
        self.moveWord(-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectRight"><code class="name flex">
<span>def <span class="ident">selectRight</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select right key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectRight(self, keys):
        &#34;&#34;&#34; Manage select right key &#34;&#34;&#34;
        self.openSelection()
        self.changeColumn(len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.selectUp"><code class="name flex">
<span>def <span class="ident">selectUp</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage select up key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectUp(self, keys):
        &#34;&#34;&#34; Manage select up key &#34;&#34;&#34;
        self.openSelection()
        self.changeLine(-len(keys))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.setCursorColumn"><code class="name flex">
<span>def <span class="ident">setCursorColumn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>When the line change compute the cursor position with tabulation in the line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setCursorColumn(self):
        &#34;&#34;&#34; When the line change compute the cursor position with tabulation in the line &#34;&#34;&#34;
        line = self.lines[self.cursorLine]
        column = 0
        tabCursorColumn = 0
        lenLine = len(line)
        column = 0
        while column &lt; lenLine: 
                char = line[column]
                # If the previous position found exactly in the current line
                if tabCursorColumn == self.tabCursorColumn:
                        self.cursorColumn = column
                        break
                # If the previous position not found in the current line
                if tabCursorColumn &gt; self.tabCursorColumn:
                        # Keep last existing position
                        self.cursorColumn = column
                        break
                # If tabulation found
                if char == &#34;\t&#34;:
                        tabCursorColumn += self.tabSize-(tabCursorColumn%self.tabSize)
                        column += 1
                else:
                        # Optimization to accelerate the cursor position
                        tab = line.find(&#34;\t&#34;, column)

                        # Tabulation found
                        if tab &gt; 0:
                                delta = tab - column
                                # If the tabulation position is after the previous tabulation cursor
                                if delta + tabCursorColumn &gt; self.tabCursorColumn:
                                        # Move the cursor to the left
                                        self.cursorColumn = column + (self.tabCursorColumn - tabCursorColumn)
                                        break
                                else:
                                        # Another tabulation found, move it after
                                        tabCursorColumn += delta
                                        column += delta
                        # Tabulation not found
                        else:
                                # Move the cursor to the end of line
                                self.cursorColumn = column + (self.tabCursorColumn - tabCursorColumn)
                                break
        else:
                if len(line) &gt;= 1:
                        self.cursorColumn = len(line)-1
                else:
                        self.cursorColumn = 0</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.setView"><code class="name flex">
<span>def <span class="ident">setView</span></span>(<span>self, view)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the view attached to the text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setView(self, view):
        &#34;&#34;&#34; Define the view attached to the text &#34;&#34;&#34;
        self.view = view</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor to the first line of text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top(self):
        &#34;&#34;&#34; Move the cursor to the first line of text &#34;&#34;&#34;
        self.goto(1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.treatKey"><code class="name flex">
<span>def <span class="ident">treatKey</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Treat keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def treatKey(self, keys):
        &#34;&#34;&#34; Treat keys &#34;&#34;&#34;
        # Move in the edit field
        if   keys[0] in UP  :            self.arrowUp(keys)
        elif keys[0] in DOWN:            self.arrowDown(keys)
        elif keys[0] in LEFT:            self.arrowLeft(keys)
        elif keys[0] in RIGHT:           self.arrowRight(keys)
        elif keys[0] in HOME:            self.home()
        elif keys[0] in END:             self.end()
        elif keys[0] in PAGE_UP:         self.pageUp(keys)
        elif keys[0] in PAGE_DOWN:       self.pageDown(keys)
        elif keys[0] in TOP:             self.top()
        elif keys[0] in BOTTOM:          self.bottom()
        elif keys[0] in NEXT_WORD:       self.nextWord()
        elif keys[0] in PREVIOUS_WORD:   self.previousWord()
        # Selection the edit field
        elif keys[0] in SELECT_UP:       self.selectUp(keys)
        elif keys[0] in SELECT_DOWN:     self.selectDown(keys)
        elif keys[0] in SELECT_RIGHT:    self.selectRight(keys)
        elif keys[0] in SELECT_LEFT:     self.selectLeft(keys)
        elif keys[0] in SELECT_HOME:     self.selectHome()
        elif keys[0] in SELECT_END:      self.selectEnd()
        elif keys[0] in SELECT_PAGE_UP:  self.selectPageUp(keys)
        elif keys[0] in SELECT_PAGE_DOWN:self.selectPageDown(keys)
        elif keys[0] in SELECT_ALL:      self.selectAll()
        elif keys[0] in SELECT_NEXT_WORD:self.selectNextWord()
        elif keys[0] in SELECT_PREV_WORD:self.selectPreviousWord()

        # If the edit is not in read only 
        elif self.readOnly == False:
                # Modification in the edit field
                if   keys[0] in COPY:            self.copy()
                elif keys[0] in CUT:             self.cut()
                elif keys[0] in PASTE:           self.paste()

                elif keys[0] in INDENT:          self.indent(keys)
                elif keys[0] in UNINDENT:        self.unindent(keys)
                elif keys[0] in CHANGE_CASE:     self.changeCase()
                elif keys[0] in COMMENT:         self.comment()

                elif keys[0] in BACKSPACE:       self.backspace()
                elif keys[0] in DELETE:          self.delete()
                elif keys[0] in NEW_LINE:        self.newLine()
                elif keys[0] in DELETE_LINE:     self.deleteLine()
                else: self.addChar(keys)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.Text.unindent"><code class="name flex">
<span>def <span class="ident">unindent</span></span>(<span>self, keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the unindentation key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unindent(self, keys):
        &#34;&#34;&#34; Manage the unindentation key &#34;&#34;&#34;
        # If nothing selected
        if self.selectionStart == None:
                self.backspace()
        else:
                self.modified = True

                # Unindent selection
                selectionStart, selectionEnd = self.getSelection()
                selColumnStart, selLineStart, dummy = selectionStart
                selColumnEnd,   selLineEnd,   dummy = selectionEnd

                # If the selection is only alone line
                if selLineStart == selLineEnd:
                        self.hideSelection()
                else:
                        # If the last line selected is at beginning of line
                        if selColumnEnd == 0:
                                # This line must not be indented
                                selLineEnd -= 1

                        # Remove indentation
                        for line in range(selLineStart, selLineEnd+1):
                                if len(self.lines[line]) &gt;= 1:
                                        if self.lines[line][0] == &#34;\t&#34; or self.lines[line][0] == &#34; &#34;:
                                                self.lines[line] = self.lines[line][1:]

                        # Move the start selection to the start of first selected line
                        self.selectionStart = [0,selLineStart, 0]

                        # If the last line selected is not at beginning of line
                        if selColumnEnd &gt; 0:
                                # Get the length of last selected line
                                lenLineEnd =  len(self.lines[selLineEnd])

                                # If the end of selection is not on the last line
                                if selLineEnd &lt; len(self.lines)-1:
                                        lenLineEnd -= 1

                                # Move the end of selection at the end of line selected
                                self.selectionEnd   = [lenLineEnd, selLineEnd, self.getTabCursor(selLineEnd,lenLineEnd)]
                        else:
                                # Move the end of selection at the start of the last line selected
                                self.selectionEnd  = [0, selLineEnd+1, 0]
                self.view.setRefreshSelection()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.shell.editor.View"><code class="flex name class">
<span>class <span class="ident">View</span></span>
<span>(</span><span>viewHeight, viewTop)</span>
</code></dt>
<dd>
<div class="desc"><p>Class which manage the view of the edit field </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class View:
        &#34;&#34;&#34; Class which manage the view of the edit field &#34;&#34;&#34;
        def __init__(self, viewHeight, viewTop):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.line     = 0
                self.column   = 0
                if viewHeight == None:
                        self.height   = 20
                else:
                        self.height          = viewHeight
                self.width               = 80
                self.top                 = viewTop
                self.isRefreshAll        = True
                self.isRefreshLine       = False
                self.isRefreshLineBefore = False
                self.isRefreshLineAfter  = False
                self.refreshPart         = None
                self.text                = None
                self.tabCursorColumn     = 0
                self.selLineStart        = None
                self.selLineEnd          = None

        def write(self, data):
                &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
                sys.stdout.write(data)

        def flush(self):
                &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
                try:
                        sys.stdout.flush()
                except:
                        pass

        def setText(self, text):
                &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
                self.text = text

        def getScreenPosition(self):
                &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
                return (self.text.getCursorLine() - self.line + self.top, self.tabCursorColumn - self.column)

        def reset(self):
                &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
                self.write(&#34;\x1b&#34;&#34;c&#34;)
                self.flush()

        def resetScrollRegion(self):
                &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
                if self.screenHeight &gt; 0:
                        self.setScrollingRegion(0, self.screenHeight-1)

        def setScrollingRegion(self, topLine, bottomLine):
                &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
                if topLine &lt; bottomLine:
                        self.write(&#34;\x1B[%d;%dr&#34;%(topLine+1,bottomLine+1))

        def scrollUp(self):
                &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
                self.setScrollingRegion(self.top, self.height+1)
                self.write(&#34;\x1B[1S&#34;)

        def scrollDown(self):
                &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
                self.setScrollingRegion(self.top, self.height+1)
                self.write(&#34;\x1B[1T&#34;)

        def scrollPartUp(self):
                &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
                line, column = self.getScreenPosition()
                if line &lt; self.height:
                        self.setScrollingRegion(line, self.height+1)
                        self.write(&#34;\x1B[1S&#34;)

        def scrollPartDown(self):
                &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
                line, column = self.getScreenPosition()
                if line &lt; self.height:
                        self.setScrollingRegion(line+1, self.height+1)
                        self.write(&#34;\x1B[1T&#34;)
                else:
                        self.isRefreshLineAfter = True

        def move(self):
                &#34;&#34;&#34; Move the view &#34;&#34;&#34;
                self.tabCursorColumn = self.text.getTabCursor(self.text.getCursorLine())
                # Move view port
                if self.tabCursorColumn &lt; self.column:
                        self.isRefreshAll = True
                        if self.tabCursorColumn &gt; HORIZONTAL_MOVE:
                                self.column = self.tabCursorColumn-HORIZONTAL_MOVE
                        else:
                                self.column = 0
                elif self.tabCursorColumn &gt;= self.column + self.width:
                        self.column = self.tabCursorColumn-self.width+HORIZONTAL_MOVE
                        self.isRefreshAll = True
                if self.text.getCursorLine() &lt; self.line:
                        delta = self.line - self.text.getCursorLine()
                        self.line = self.text.getCursorLine()
                        if self.line &lt; 0:
                                self.line = 0
                        if delta == 1:
                                self.scrollDown()
                                self.isRefreshLine = True
                        else:
                                self.isRefreshAll = True
                elif self.text.getCursorLine() &gt; self.line + self.height:
                        delta =  self.text.getCursorLine() - self.line - self.height
                        self.line = self.text.getCursorLine()-self.height
                        if delta == 1:
                                self.scrollUp()
                                self.isRefreshLine = True
                        else:
                                self.isRefreshAll = True

        def setRefreshLine(self):
                &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
                self.isRefreshLine = True

        def setRefreshAfter(self):
                &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
                self.isRefreshLine = True
                self.isRefreshLineAfter = True

        def setRefreshBefore(self):
                &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
                self.isRefreshLine = True
                self.isRefreshLineBefore = True

        def setRefreshAll(self):
                &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
                self.isRefreshAll = True

        def showLine(self, currentLine, screenLine, selectionStart, selectionEnd):
                &#34;&#34;&#34; Show one line &#34;&#34;&#34;
                self.moveCursor(screenLine, 0)
                self.write(&#34;\x1B[K&#34;)
                if currentLine &lt; self.text.getCountLines() and currentLine &gt;= 0:
                        line = self.text.getTabLine(currentLine)
                        partLine = line[self.column:self.column+self.width]
                        # If the line selected
                        if selectionStart != None:
                                # If the line not empty
                                if len(partLine) &gt;= 1:
                                        # If the line have carriage return at the end
                                        if partLine[-1] == &#34;\n&#34;:
                                                # Remove the carriage return
                                                partLine = partLine[:-1]
                                if len(partLine) &gt; 0:
                                        dummy, selLineStart, selColumnStart = selectionStart
                                        dummy, selLineEnd,   selColumnEnd   = selectionEnd
                                        # If the current line is the end of selection
                                        if currentLine == selLineEnd:
                                                # If the end of selection is outside the visible part
                                                if selColumnEnd - self.column &lt; 0:
                                                        selColumnEnd = 0
                                                else:
                                                        selColumnEnd -= self.column

                                                # If the start of selection is on the previous lines
                                                if selLineStart &lt; selLineEnd:
                                                        # Select the start of line
                                                        partLine = &#34;\x1B[7m&#34; + partLine[:selColumnEnd] + &#34;\x1B[m&#34; + partLine[selColumnEnd:]
                                                else:
                                                        # Unselect the end of line
                                                        partLine = partLine[:selColumnEnd] + &#34;\x1B[m&#34; + partLine[selColumnEnd:]
                                        # If the current line is the start of selection
                                        if currentLine == selLineStart:
                                                # If the start of selection is outside the visible part
                                                if selColumnStart - self.column &lt; 0:
                                                        selColumnStart = 0
                                                else:
                                                        selColumnStart -= self.column

                                                # If the end of selection is on the next lines
                                                if selLineStart &lt; selLineEnd:
                                                        # Select the end of line
                                                        partLine = partLine[:selColumnStart] + &#34;\x1B[7m&#34; + partLine[selColumnStart:] + &#34;\x1B[m&#34;
                                                else:
                                                        # Select the start of line
                                                        partLine = partLine[:selColumnStart] + &#34;\x1B[7m&#34; + partLine[selColumnStart:] 
                                        # If the line is completly selected
                                        if currentLine &gt; selLineStart and currentLine &lt; selLineEnd:
                                                # Select all the line
                                                partLine = &#34;\x1B[7m&#34; + partLine + &#34;\x1B[m&#34;
                                else:
                                        partLine = &#34;&#34;
                                self.write(partLine)
                        else:
                                self.write(partLine.rstrip())

        def refreshLine(self, selectionStart, selectionEnd):
                &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
                screenLine,     screenColumn = self.getScreenPosition()
                refreshed = False

                # If the line must be refreshed before the cursor line
                if self.isRefreshLineBefore:
                        self.isRefreshLineBefore = False
                        self.showLine(self.text.getCursorLine()-1, screenLine-1, selectionStart, selectionEnd)
                        refreshed = True
                # If the line must be refreshed after the cursor line
                if self.isRefreshLineAfter:
                        self.isRefreshLineAfter = False
                        self.showLine(self.text.getCursorLine()+1, screenLine+1, selectionStart, selectionEnd)
                        offset = self.height - screenLine
                        self.showLine(self.text.getCursorLine()+offset+1, screenLine+offset+1, selectionStart, selectionEnd)
                        refreshed = True
                # If only the cursor line must be refresh
                if self.isRefreshLine:
                        self.isRefreshLine = False
                        self.showLine(self.text.getCursorLine(), screenLine, selectionStart, selectionEnd)
                        refreshed = True

                # If no refresh detected and a selection started
                if selectionStart != None and refreshed == False:
                        # Refresh the selection
                        self.showLine(self.text.getCursorLine(), screenLine, selectionStart, selectionEnd)

        def refresh(self):
                &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
                selectionStart, selectionEnd = self.text.getSelection()
                if self.refreshPart != None:
                        self.refreshContent(selectionStart, selectionEnd, self.refreshPart)
                        self.refreshPart = None
                # Refresh all required
                if self.isRefreshAll:
                        self.refreshContent(selectionStart, selectionEnd, True)
                        self.isRefreshAll  = False
                        self.isRefreshLine = False
                else:
                        # If no selection activated
                        if selectionStart == None:
                                # Refresh the current line
                                self.refreshLine(selectionStart, selectionEnd)
                        else:
                                # Refresh the selection
                                self.refreshContent(selectionStart, selectionEnd, False)
                self.moveCursor()
                self.flush()

        def refreshContent(self, selectionStart, selectionEnd, all):
                &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
                # If selection present
                if selectionStart != None:
                        # Get the selection
                        dummy, selLineStart, selColumnStart = selectionStart
                        dummy, selLineEnd,   selColumnEnd   = selectionEnd
                        lineStart = selLineStart
                        lineEnd   = selLineEnd
                        # The aim of this part is to limit the refresh area
                        # If the precedent display show a selection
                        if self.selLineEnd != None and self.selLineStart != None:
                                # If the start and end of selection is on the sames lines
                                if self.selLineEnd == selLineEnd and self.selLineStart == selLineStart:
                                        lineStart = lineEnd = self.text.getCursorLine()
                                else:
                                        # If the end of selection is after the precedent display
                                        if self.selLineEnd &gt; selLineEnd:
                                                lineEnd = self.selLineEnd
                                        # If the end of selection is on the same line than the precedent display
                                        elif self.selLineEnd == selLineEnd:
                                                # If the start of selection is before the precedent display
                                                if self.selLineStart &lt; selLineStart:
                                                        lineEnd = selLineStart
                                                else:
                                                        lineEnd = self.selLineStart
                                        # If the start of selection is before the precedent display
                                        if self.selLineStart &lt; selLineStart:
                                                lineStart = self.selLineStart
                                        # If the start of selection is on the same line than the precedent display
                                        elif self.selLineStart == selLineStart:
                                                # If the end of selection is after the precedent display
                                                if self.selLineEnd &gt; selLineEnd:
                                                        lineStart = selLineEnd
                                                else:
                                                        lineStart = self.selLineEnd
                else:
                        lineStart = 0
                        lineEnd = self.line + self.height
                currentLine = self.line
                screenLine = self.top
                if type(all) == type([]):
                        lineStart, lineEnd = all
                        all = False
                # Refresh all lines visible
                while currentLine &lt; self.text.getCountLines() and currentLine &lt;= self.line + self.height:
                        # If the line is in selection or all must be refreshed
                        if lineStart &lt;= currentLine &lt;= lineEnd or all:
                                self.showLine(currentLine, screenLine, selectionStart, selectionEnd)
                        screenLine  += 1
                        currentLine += 1
                if all == True:
                        # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                        while currentLine &lt;= self.line + self.height:
                                self.moveCursor(screenLine, 0)
                                self.write(&#34;\x1B[K&#34;)
                                screenLine  += 1
                                currentLine += 1
                # If selection present
                if selectionStart != None:
                        # Save current selection
                        dummy, self.selLineStart, dummy = selectionStart
                        dummy, self.selLineEnd,   dummy   = selectionEnd

        def hideSelection(self):
                &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
                selectionStart, selectionEnd = self.text.getSelection()
                if selectionStart != None:
                        self.setRefreshSelection()
                        self.selLineStart = None
                        self.selLineEnd   = None

        def setRefreshSelection(self):
                &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
                selectionStart, selectionEnd = self.text.getSelection()
                if selectionStart != None:
                        # self.isRefreshAll = True
                        lineStart = selectionStart[1]
                        if self.selLineStart &lt; lineStart:
                                lineStart = self.selLineStart
                        lineEnd = selectionEnd[1]
                        if self.selLineEnd &gt; lineEnd:
                                lineEnd = self.selLineEnd
                        self.refreshPart = [lineStart, lineEnd]

        def moveCursor(self, screenLine=None, screenColumn=None):
                &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
                if screenLine == None and screenColumn == None:
                        screenLine, screenColumn = self.getScreenPosition()
                self.write(&#34;\x1B[%d;%df&#34;%(screenLine+1,screenColumn+1))

        def getScreenSize(self):
                &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
                height, width = useful.getScreenSize()
                self.screenHeight = height
                self.screenWidth = width
                self.height = height-self.top-1
                self.width  = width
                self.moveCursor()

        def cls(self):
                &#34;&#34;&#34; Clear the screen &#34;&#34;&#34;
                self.write(&#34;\x1B[2J&#34;)
                self.moveCursor(0,0)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.shell.editor.View.cls"><code class="name flex">
<span>def <span class="ident">cls</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the screen</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cls(self):
        &#34;&#34;&#34; Clear the screen &#34;&#34;&#34;
        self.write(&#34;\x1B[2J&#34;)
        self.moveCursor(0,0)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.flush"><code class="name flex">
<span>def <span class="ident">flush</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Flush text to stdout</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush(self):
        &#34;&#34;&#34; Flush text to stdout &#34;&#34;&#34;
        try:
                sys.stdout.flush()
        except:
                pass</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.getScreenPosition"><code class="name flex">
<span>def <span class="ident">getScreenPosition</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the screen position of cursor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getScreenPosition(self):
        &#34;&#34;&#34; Get the screen position of cursor &#34;&#34;&#34;
        return (self.text.getCursorLine() - self.line + self.top, self.tabCursorColumn - self.column)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.getScreenSize"><code class="name flex">
<span>def <span class="ident">getScreenSize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the screen size</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getScreenSize(self):
        &#34;&#34;&#34; Get the screen size &#34;&#34;&#34;
        height, width = useful.getScreenSize()
        self.screenHeight = height
        self.screenWidth = width
        self.height = height-self.top-1
        self.width  = width
        self.moveCursor()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.hideSelection"><code class="name flex">
<span>def <span class="ident">hideSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hide the selection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hideSelection(self):
        &#34;&#34;&#34; Hide the selection &#34;&#34;&#34;
        selectionStart, selectionEnd = self.text.getSelection()
        if selectionStart != None:
                self.setRefreshSelection()
                self.selLineStart = None
                self.selLineEnd   = None</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self):
        &#34;&#34;&#34; Move the view &#34;&#34;&#34;
        self.tabCursorColumn = self.text.getTabCursor(self.text.getCursorLine())
        # Move view port
        if self.tabCursorColumn &lt; self.column:
                self.isRefreshAll = True
                if self.tabCursorColumn &gt; HORIZONTAL_MOVE:
                        self.column = self.tabCursorColumn-HORIZONTAL_MOVE
                else:
                        self.column = 0
        elif self.tabCursorColumn &gt;= self.column + self.width:
                self.column = self.tabCursorColumn-self.width+HORIZONTAL_MOVE
                self.isRefreshAll = True
        if self.text.getCursorLine() &lt; self.line:
                delta = self.line - self.text.getCursorLine()
                self.line = self.text.getCursorLine()
                if self.line &lt; 0:
                        self.line = 0
                if delta == 1:
                        self.scrollDown()
                        self.isRefreshLine = True
                else:
                        self.isRefreshAll = True
        elif self.text.getCursorLine() &gt; self.line + self.height:
                delta =  self.text.getCursorLine() - self.line - self.height
                self.line = self.text.getCursorLine()-self.height
                if delta == 1:
                        self.scrollUp()
                        self.isRefreshLine = True
                else:
                        self.isRefreshAll = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.moveCursor"><code class="name flex">
<span>def <span class="ident">moveCursor</span></span>(<span>self, screenLine=None, screenColumn=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the cursor in the view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def moveCursor(self, screenLine=None, screenColumn=None):
        &#34;&#34;&#34; Move the cursor in the view &#34;&#34;&#34;
        if screenLine == None and screenColumn == None:
                screenLine, screenColumn = self.getScreenPosition()
        self.write(&#34;\x1B[%d;%df&#34;%(screenLine+1,screenColumn+1))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh view</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self):
        &#34;&#34;&#34; Refresh view &#34;&#34;&#34;
        selectionStart, selectionEnd = self.text.getSelection()
        if self.refreshPart != None:
                self.refreshContent(selectionStart, selectionEnd, self.refreshPart)
                self.refreshPart = None
        # Refresh all required
        if self.isRefreshAll:
                self.refreshContent(selectionStart, selectionEnd, True)
                self.isRefreshAll  = False
                self.isRefreshLine = False
        else:
                # If no selection activated
                if selectionStart == None:
                        # Refresh the current line
                        self.refreshLine(selectionStart, selectionEnd)
                else:
                        # Refresh the selection
                        self.refreshContent(selectionStart, selectionEnd, False)
        self.moveCursor()
        self.flush()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refreshContent"><code class="name flex">
<span>def <span class="ident">refreshContent</span></span>(<span>self, selectionStart, selectionEnd, all)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh content</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshContent(self, selectionStart, selectionEnd, all):
        &#34;&#34;&#34; Refresh content &#34;&#34;&#34;
        # If selection present
        if selectionStart != None:
                # Get the selection
                dummy, selLineStart, selColumnStart = selectionStart
                dummy, selLineEnd,   selColumnEnd   = selectionEnd
                lineStart = selLineStart
                lineEnd   = selLineEnd
                # The aim of this part is to limit the refresh area
                # If the precedent display show a selection
                if self.selLineEnd != None and self.selLineStart != None:
                        # If the start and end of selection is on the sames lines
                        if self.selLineEnd == selLineEnd and self.selLineStart == selLineStart:
                                lineStart = lineEnd = self.text.getCursorLine()
                        else:
                                # If the end of selection is after the precedent display
                                if self.selLineEnd &gt; selLineEnd:
                                        lineEnd = self.selLineEnd
                                # If the end of selection is on the same line than the precedent display
                                elif self.selLineEnd == selLineEnd:
                                        # If the start of selection is before the precedent display
                                        if self.selLineStart &lt; selLineStart:
                                                lineEnd = selLineStart
                                        else:
                                                lineEnd = self.selLineStart
                                # If the start of selection is before the precedent display
                                if self.selLineStart &lt; selLineStart:
                                        lineStart = self.selLineStart
                                # If the start of selection is on the same line than the precedent display
                                elif self.selLineStart == selLineStart:
                                        # If the end of selection is after the precedent display
                                        if self.selLineEnd &gt; selLineEnd:
                                                lineStart = selLineEnd
                                        else:
                                                lineStart = self.selLineEnd
        else:
                lineStart = 0
                lineEnd = self.line + self.height
        currentLine = self.line
        screenLine = self.top
        if type(all) == type([]):
                lineStart, lineEnd = all
                all = False
        # Refresh all lines visible
        while currentLine &lt; self.text.getCountLines() and currentLine &lt;= self.line + self.height:
                # If the line is in selection or all must be refreshed
                if lineStart &lt;= currentLine &lt;= lineEnd or all:
                        self.showLine(currentLine, screenLine, selectionStart, selectionEnd)
                screenLine  += 1
                currentLine += 1
        if all == True:
                # Erase the rest of the screen with empty line (used when the text is shorter than the screen)
                while currentLine &lt;= self.line + self.height:
                        self.moveCursor(screenLine, 0)
                        self.write(&#34;\x1B[K&#34;)
                        screenLine  += 1
                        currentLine += 1
        # If selection present
        if selectionStart != None:
                # Save current selection
                dummy, self.selLineStart, dummy = selectionStart
                dummy, self.selLineEnd,   dummy   = selectionEnd</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.refreshLine"><code class="name flex">
<span>def <span class="ident">refreshLine</span></span>(<span>self, selectionStart, selectionEnd)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refreshLine(self, selectionStart, selectionEnd):
        &#34;&#34;&#34; Refresh line &#34;&#34;&#34;
        screenLine,     screenColumn = self.getScreenPosition()
        refreshed = False

        # If the line must be refreshed before the cursor line
        if self.isRefreshLineBefore:
                self.isRefreshLineBefore = False
                self.showLine(self.text.getCursorLine()-1, screenLine-1, selectionStart, selectionEnd)
                refreshed = True
        # If the line must be refreshed after the cursor line
        if self.isRefreshLineAfter:
                self.isRefreshLineAfter = False
                self.showLine(self.text.getCursorLine()+1, screenLine+1, selectionStart, selectionEnd)
                offset = self.height - screenLine
                self.showLine(self.text.getCursorLine()+offset+1, screenLine+offset+1, selectionStart, selectionEnd)
                refreshed = True
        # If only the cursor line must be refresh
        if self.isRefreshLine:
                self.isRefreshLine = False
                self.showLine(self.text.getCursorLine(), screenLine, selectionStart, selectionEnd)
                refreshed = True

        # If no refresh detected and a selection started
        if selectionStart != None and refreshed == False:
                # Refresh the selection
                self.showLine(self.text.getCursorLine(), screenLine, selectionStart, selectionEnd)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset VT100</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
        &#34;&#34;&#34; Reset VT100 &#34;&#34;&#34;
        self.write(&#34;\x1b&#34;&#34;c&#34;)
        self.flush()</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.resetScrollRegion"><code class="name flex">
<span>def <span class="ident">resetScrollRegion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset VT100 scroll region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetScrollRegion(self):
        &#34;&#34;&#34; Reset VT100 scroll region &#34;&#34;&#34;
        if self.screenHeight &gt; 0:
                self.setScrollingRegion(0, self.screenHeight-1)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scrollDown"><code class="name flex">
<span>def <span class="ident">scrollDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll to down</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrollDown(self):
        &#34;&#34;&#34; Scroll to down &#34;&#34;&#34;
        self.setScrollingRegion(self.top, self.height+1)
        self.write(&#34;\x1B[1T&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scrollPartDown"><code class="name flex">
<span>def <span class="ident">scrollPartDown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the lower part</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrollPartDown(self):
        &#34;&#34;&#34; Scroll the lower part &#34;&#34;&#34;
        line, column = self.getScreenPosition()
        if line &lt; self.height:
                self.setScrollingRegion(line+1, self.height+1)
                self.write(&#34;\x1B[1T&#34;)
        else:
                self.isRefreshLineAfter = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scrollPartUp"><code class="name flex">
<span>def <span class="ident">scrollPartUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll the upper part</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrollPartUp(self):
        &#34;&#34;&#34; Scroll the upper part &#34;&#34;&#34;
        line, column = self.getScreenPosition()
        if line &lt; self.height:
                self.setScrollingRegion(line, self.height+1)
                self.write(&#34;\x1B[1S&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.scrollUp"><code class="name flex">
<span>def <span class="ident">scrollUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Scroll to up</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrollUp(self):
        &#34;&#34;&#34; Scroll to up &#34;&#34;&#34;
        self.setScrollingRegion(self.top, self.height+1)
        self.write(&#34;\x1B[1S&#34;)</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.setRefreshAfter"><code class="name flex">
<span>def <span class="ident">setRefreshAfter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines after the current line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setRefreshAfter(self):
        &#34;&#34;&#34; Indicates that all lines after the current line must be refreshed &#34;&#34;&#34;
        self.isRefreshLine = True
        self.isRefreshLineAfter = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.setRefreshAll"><code class="name flex">
<span>def <span class="ident">setRefreshAll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setRefreshAll(self):
        &#34;&#34;&#34; Indicates that all lines must be refreshed &#34;&#34;&#34;
        self.isRefreshAll = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.setRefreshBefore"><code class="name flex">
<span>def <span class="ident">setRefreshBefore</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that all lines before the current line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setRefreshBefore(self):
        &#34;&#34;&#34; Indicates that all lines before the current line must be refreshed &#34;&#34;&#34;
        self.isRefreshLine = True
        self.isRefreshLineBefore = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.setRefreshLine"><code class="name flex">
<span>def <span class="ident">setRefreshLine</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the line must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setRefreshLine(self):
        &#34;&#34;&#34; Indicates that the line must be refreshed &#34;&#34;&#34;
        self.isRefreshLine = True</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.setRefreshSelection"><code class="name flex">
<span>def <span class="ident">setRefreshSelection</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the selection must be refreshed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setRefreshSelection(self):
        &#34;&#34;&#34; Indicates that the selection must be refreshed &#34;&#34;&#34;
        selectionStart, selectionEnd = self.text.getSelection()
        if selectionStart != None:
                # self.isRefreshAll = True
                lineStart = selectionStart[1]
                if self.selLineStart &lt; lineStart:
                        lineStart = self.selLineStart
                lineEnd = selectionEnd[1]
                if self.selLineEnd &gt; lineEnd:
                        lineEnd = self.selLineEnd
                self.refreshPart = [lineStart, lineEnd]</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.setScrollingRegion"><code class="name flex">
<span>def <span class="ident">setScrollingRegion</span></span>(<span>self, topLine, bottomLine)</span>
</code></dt>
<dd>
<div class="desc"><p>Define VT100 scroll region</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setScrollingRegion(self, topLine, bottomLine):
        &#34;&#34;&#34; Define VT100 scroll region &#34;&#34;&#34;
        if topLine &lt; bottomLine:
                self.write(&#34;\x1B[%d;%dr&#34;%(topLine+1,bottomLine+1))</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.setText"><code class="name flex">
<span>def <span class="ident">setText</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the text object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setText(self, text):
        &#34;&#34;&#34; Set the text object &#34;&#34;&#34;
        self.text = text</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.showLine"><code class="name flex">
<span>def <span class="ident">showLine</span></span>(<span>self, currentLine, screenLine, selectionStart, selectionEnd)</span>
</code></dt>
<dd>
<div class="desc"><p>Show one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showLine(self, currentLine, screenLine, selectionStart, selectionEnd):
        &#34;&#34;&#34; Show one line &#34;&#34;&#34;
        self.moveCursor(screenLine, 0)
        self.write(&#34;\x1B[K&#34;)
        if currentLine &lt; self.text.getCountLines() and currentLine &gt;= 0:
                line = self.text.getTabLine(currentLine)
                partLine = line[self.column:self.column+self.width]
                # If the line selected
                if selectionStart != None:
                        # If the line not empty
                        if len(partLine) &gt;= 1:
                                # If the line have carriage return at the end
                                if partLine[-1] == &#34;\n&#34;:
                                        # Remove the carriage return
                                        partLine = partLine[:-1]
                        if len(partLine) &gt; 0:
                                dummy, selLineStart, selColumnStart = selectionStart
                                dummy, selLineEnd,   selColumnEnd   = selectionEnd
                                # If the current line is the end of selection
                                if currentLine == selLineEnd:
                                        # If the end of selection is outside the visible part
                                        if selColumnEnd - self.column &lt; 0:
                                                selColumnEnd = 0
                                        else:
                                                selColumnEnd -= self.column

                                        # If the start of selection is on the previous lines
                                        if selLineStart &lt; selLineEnd:
                                                # Select the start of line
                                                partLine = &#34;\x1B[7m&#34; + partLine[:selColumnEnd] + &#34;\x1B[m&#34; + partLine[selColumnEnd:]
                                        else:
                                                # Unselect the end of line
                                                partLine = partLine[:selColumnEnd] + &#34;\x1B[m&#34; + partLine[selColumnEnd:]
                                # If the current line is the start of selection
                                if currentLine == selLineStart:
                                        # If the start of selection is outside the visible part
                                        if selColumnStart - self.column &lt; 0:
                                                selColumnStart = 0
                                        else:
                                                selColumnStart -= self.column

                                        # If the end of selection is on the next lines
                                        if selLineStart &lt; selLineEnd:
                                                # Select the end of line
                                                partLine = partLine[:selColumnStart] + &#34;\x1B[7m&#34; + partLine[selColumnStart:] + &#34;\x1B[m&#34;
                                        else:
                                                # Select the start of line
                                                partLine = partLine[:selColumnStart] + &#34;\x1B[7m&#34; + partLine[selColumnStart:] 
                                # If the line is completly selected
                                if currentLine &gt; selLineStart and currentLine &lt; selLineEnd:
                                        # Select all the line
                                        partLine = &#34;\x1B[7m&#34; + partLine + &#34;\x1B[m&#34;
                        else:
                                partLine = &#34;&#34;
                        self.write(partLine)
                else:
                        self.write(partLine.rstrip())</code></pre>
</details>
</dd>
<dt id="lib.shell.editor.View.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Write data to stdout</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, data):
        &#34;&#34;&#34; Write data to stdout &#34;&#34;&#34;
        sys.stdout.write(data)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.shell" href="index.html">lib.shell</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.shell.editor.Edit" href="#lib.shell.editor.Edit">Edit</a></code></h4>
</li>
<li>
<h4><code><a title="lib.shell.editor.Editor" href="#lib.shell.editor.Editor">Editor</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.shell.editor.Editor.execute" href="#lib.shell.editor.Editor.execute">execute</a></code></li>
<li><code><a title="lib.shell.editor.Editor.exit" href="#lib.shell.editor.Editor.exit">exit</a></code></li>
<li><code><a title="lib.shell.editor.Editor.find" href="#lib.shell.editor.Editor.find">find</a></code></li>
<li><code><a title="lib.shell.editor.Editor.findNext" href="#lib.shell.editor.Editor.findNext">findNext</a></code></li>
<li><code><a title="lib.shell.editor.Editor.findPrevious" href="#lib.shell.editor.Editor.findPrevious">findPrevious</a></code></li>
<li><code><a title="lib.shell.editor.Editor.getKey" href="#lib.shell.editor.Editor.getKey">getKey</a></code></li>
<li><code><a title="lib.shell.editor.Editor.goto" href="#lib.shell.editor.Editor.goto">goto</a></code></li>
<li><code><a title="lib.shell.editor.Editor.groupKey" href="#lib.shell.editor.Editor.groupKey">groupKey</a></code></li>
<li><code><a title="lib.shell.editor.Editor.input" href="#lib.shell.editor.Editor.input">input</a></code></li>
<li><code><a title="lib.shell.editor.Editor.refresh" href="#lib.shell.editor.Editor.refresh">refresh</a></code></li>
<li><code><a title="lib.shell.editor.Editor.refreshHeader" href="#lib.shell.editor.Editor.refreshHeader">refreshHeader</a></code></li>
<li><code><a title="lib.shell.editor.Editor.replace" href="#lib.shell.editor.Editor.replace">replace</a></code></li>
<li><code><a title="lib.shell.editor.Editor.replaceCurrent" href="#lib.shell.editor.Editor.replaceCurrent">replaceCurrent</a></code></li>
<li><code><a title="lib.shell.editor.Editor.run" href="#lib.shell.editor.Editor.run">run</a></code></li>
<li><code><a title="lib.shell.editor.Editor.save" href="#lib.shell.editor.Editor.save">save</a></code></li>
<li><code><a title="lib.shell.editor.Editor.toggleMode" href="#lib.shell.editor.Editor.toggleMode">toggleMode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.shell.editor.Text" href="#lib.shell.editor.Text">Text</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.shell.editor.Text.addChar" href="#lib.shell.editor.Text.addChar">addChar</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrowDown" href="#lib.shell.editor.Text.arrowDown">arrowDown</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrowLeft" href="#lib.shell.editor.Text.arrowLeft">arrowLeft</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrowRight" href="#lib.shell.editor.Text.arrowRight">arrowRight</a></code></li>
<li><code><a title="lib.shell.editor.Text.arrowUp" href="#lib.shell.editor.Text.arrowUp">arrowUp</a></code></li>
<li><code><a title="lib.shell.editor.Text.backspace" href="#lib.shell.editor.Text.backspace">backspace</a></code></li>
<li><code><a title="lib.shell.editor.Text.bottom" href="#lib.shell.editor.Text.bottom">bottom</a></code></li>
<li><code><a title="lib.shell.editor.Text.changeCase" href="#lib.shell.editor.Text.changeCase">changeCase</a></code></li>
<li><code><a title="lib.shell.editor.Text.changeColumn" href="#lib.shell.editor.Text.changeColumn">changeColumn</a></code></li>
<li><code><a title="lib.shell.editor.Text.changeLine" href="#lib.shell.editor.Text.changeLine">changeLine</a></code></li>
<li><code><a title="lib.shell.editor.Text.closeSelection" href="#lib.shell.editor.Text.closeSelection">closeSelection</a></code></li>
<li><code><a title="lib.shell.editor.Text.comment" href="#lib.shell.editor.Text.comment">comment</a></code></li>
<li><code><a title="lib.shell.editor.Text.copy" href="#lib.shell.editor.Text.copy">copy</a></code></li>
<li><code><a title="lib.shell.editor.Text.copyClipboard" href="#lib.shell.editor.Text.copyClipboard">copyClipboard</a></code></li>
<li><code><a title="lib.shell.editor.Text.cut" href="#lib.shell.editor.Text.cut">cut</a></code></li>
<li><code><a title="lib.shell.editor.Text.delete" href="#lib.shell.editor.Text.delete">delete</a></code></li>
<li><code><a title="lib.shell.editor.Text.deleteLine" href="#lib.shell.editor.Text.deleteLine">deleteLine</a></code></li>
<li><code><a title="lib.shell.editor.Text.end" href="#lib.shell.editor.Text.end">end</a></code></li>
<li><code><a title="lib.shell.editor.Text.findNext" href="#lib.shell.editor.Text.findNext">findNext</a></code></li>
<li><code><a title="lib.shell.editor.Text.findPrevious" href="#lib.shell.editor.Text.findPrevious">findPrevious</a></code></li>
<li><code><a title="lib.shell.editor.Text.getCountLines" href="#lib.shell.editor.Text.getCountLines">getCountLines</a></code></li>
<li><code><a title="lib.shell.editor.Text.getCursorChar" href="#lib.shell.editor.Text.getCursorChar">getCursorChar</a></code></li>
<li><code><a title="lib.shell.editor.Text.getCursorLine" href="#lib.shell.editor.Text.getCursorLine">getCursorLine</a></code></li>
<li><code><a title="lib.shell.editor.Text.getSelection" href="#lib.shell.editor.Text.getSelection">getSelection</a></code></li>
<li><code><a title="lib.shell.editor.Text.getTabCursor" href="#lib.shell.editor.Text.getTabCursor">getTabCursor</a></code></li>
<li><code><a title="lib.shell.editor.Text.getTabCursorColumn" href="#lib.shell.editor.Text.getTabCursorColumn">getTabCursorColumn</a></code></li>
<li><code><a title="lib.shell.editor.Text.getTabLine" href="#lib.shell.editor.Text.getTabLine">getTabLine</a></code></li>
<li><code><a title="lib.shell.editor.Text.goto" href="#lib.shell.editor.Text.goto">goto</a></code></li>
<li><code><a title="lib.shell.editor.Text.hideSelection" href="#lib.shell.editor.Text.hideSelection">hideSelection</a></code></li>
<li><code><a title="lib.shell.editor.Text.home" href="#lib.shell.editor.Text.home">home</a></code></li>
<li><code><a title="lib.shell.editor.Text.indent" href="#lib.shell.editor.Text.indent">indent</a></code></li>
<li><code><a title="lib.shell.editor.Text.insertChar" href="#lib.shell.editor.Text.insertChar">insertChar</a></code></li>
<li><code><a title="lib.shell.editor.Text.load" href="#lib.shell.editor.Text.load">load</a></code></li>
<li><code><a title="lib.shell.editor.Text.moveCursor" href="#lib.shell.editor.Text.moveCursor">moveCursor</a></code></li>
<li><code><a title="lib.shell.editor.Text.moveWord" href="#lib.shell.editor.Text.moveWord">moveWord</a></code></li>
<li><code><a title="lib.shell.editor.Text.newLine" href="#lib.shell.editor.Text.newLine">newLine</a></code></li>
<li><code><a title="lib.shell.editor.Text.nextWord" href="#lib.shell.editor.Text.nextWord">nextWord</a></code></li>
<li><code><a title="lib.shell.editor.Text.openSelection" href="#lib.shell.editor.Text.openSelection">openSelection</a></code></li>
<li><code><a title="lib.shell.editor.Text.pageDown" href="#lib.shell.editor.Text.pageDown">pageDown</a></code></li>
<li><code><a title="lib.shell.editor.Text.pageUp" href="#lib.shell.editor.Text.pageUp">pageUp</a></code></li>
<li><code><a title="lib.shell.editor.Text.paste" href="#lib.shell.editor.Text.paste">paste</a></code></li>
<li><code><a title="lib.shell.editor.Text.pasteClipboard" href="#lib.shell.editor.Text.pasteClipboard">pasteClipboard</a></code></li>
<li><code><a title="lib.shell.editor.Text.previousWord" href="#lib.shell.editor.Text.previousWord">previousWord</a></code></li>
<li><code><a title="lib.shell.editor.Text.removeSelection" href="#lib.shell.editor.Text.removeSelection">removeSelection</a></code></li>
<li><code><a title="lib.shell.editor.Text.replace" href="#lib.shell.editor.Text.replace">replace</a></code></li>
<li><code><a title="lib.shell.editor.Text.replaceChar" href="#lib.shell.editor.Text.replaceChar">replaceChar</a></code></li>
<li><code><a title="lib.shell.editor.Text.save" href="#lib.shell.editor.Text.save">save</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectAll" href="#lib.shell.editor.Text.selectAll">selectAll</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectDown" href="#lib.shell.editor.Text.selectDown">selectDown</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectEnd" href="#lib.shell.editor.Text.selectEnd">selectEnd</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectHome" href="#lib.shell.editor.Text.selectHome">selectHome</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectLeft" href="#lib.shell.editor.Text.selectLeft">selectLeft</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectNextWord" href="#lib.shell.editor.Text.selectNextWord">selectNextWord</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectPageDown" href="#lib.shell.editor.Text.selectPageDown">selectPageDown</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectPageUp" href="#lib.shell.editor.Text.selectPageUp">selectPageUp</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectPreviousWord" href="#lib.shell.editor.Text.selectPreviousWord">selectPreviousWord</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectRight" href="#lib.shell.editor.Text.selectRight">selectRight</a></code></li>
<li><code><a title="lib.shell.editor.Text.selectUp" href="#lib.shell.editor.Text.selectUp">selectUp</a></code></li>
<li><code><a title="lib.shell.editor.Text.setCursorColumn" href="#lib.shell.editor.Text.setCursorColumn">setCursorColumn</a></code></li>
<li><code><a title="lib.shell.editor.Text.setView" href="#lib.shell.editor.Text.setView">setView</a></code></li>
<li><code><a title="lib.shell.editor.Text.top" href="#lib.shell.editor.Text.top">top</a></code></li>
<li><code><a title="lib.shell.editor.Text.treatKey" href="#lib.shell.editor.Text.treatKey">treatKey</a></code></li>
<li><code><a title="lib.shell.editor.Text.unindent" href="#lib.shell.editor.Text.unindent">unindent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.shell.editor.View" href="#lib.shell.editor.View">View</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.shell.editor.View.cls" href="#lib.shell.editor.View.cls">cls</a></code></li>
<li><code><a title="lib.shell.editor.View.flush" href="#lib.shell.editor.View.flush">flush</a></code></li>
<li><code><a title="lib.shell.editor.View.getScreenPosition" href="#lib.shell.editor.View.getScreenPosition">getScreenPosition</a></code></li>
<li><code><a title="lib.shell.editor.View.getScreenSize" href="#lib.shell.editor.View.getScreenSize">getScreenSize</a></code></li>
<li><code><a title="lib.shell.editor.View.hideSelection" href="#lib.shell.editor.View.hideSelection">hideSelection</a></code></li>
<li><code><a title="lib.shell.editor.View.move" href="#lib.shell.editor.View.move">move</a></code></li>
<li><code><a title="lib.shell.editor.View.moveCursor" href="#lib.shell.editor.View.moveCursor">moveCursor</a></code></li>
<li><code><a title="lib.shell.editor.View.refresh" href="#lib.shell.editor.View.refresh">refresh</a></code></li>
<li><code><a title="lib.shell.editor.View.refreshContent" href="#lib.shell.editor.View.refreshContent">refreshContent</a></code></li>
<li><code><a title="lib.shell.editor.View.refreshLine" href="#lib.shell.editor.View.refreshLine">refreshLine</a></code></li>
<li><code><a title="lib.shell.editor.View.reset" href="#lib.shell.editor.View.reset">reset</a></code></li>
<li><code><a title="lib.shell.editor.View.resetScrollRegion" href="#lib.shell.editor.View.resetScrollRegion">resetScrollRegion</a></code></li>
<li><code><a title="lib.shell.editor.View.scrollDown" href="#lib.shell.editor.View.scrollDown">scrollDown</a></code></li>
<li><code><a title="lib.shell.editor.View.scrollPartDown" href="#lib.shell.editor.View.scrollPartDown">scrollPartDown</a></code></li>
<li><code><a title="lib.shell.editor.View.scrollPartUp" href="#lib.shell.editor.View.scrollPartUp">scrollPartUp</a></code></li>
<li><code><a title="lib.shell.editor.View.scrollUp" href="#lib.shell.editor.View.scrollUp">scrollUp</a></code></li>
<li><code><a title="lib.shell.editor.View.setRefreshAfter" href="#lib.shell.editor.View.setRefreshAfter">setRefreshAfter</a></code></li>
<li><code><a title="lib.shell.editor.View.setRefreshAll" href="#lib.shell.editor.View.setRefreshAll">setRefreshAll</a></code></li>
<li><code><a title="lib.shell.editor.View.setRefreshBefore" href="#lib.shell.editor.View.setRefreshBefore">setRefreshBefore</a></code></li>
<li><code><a title="lib.shell.editor.View.setRefreshLine" href="#lib.shell.editor.View.setRefreshLine">setRefreshLine</a></code></li>
<li><code><a title="lib.shell.editor.View.setRefreshSelection" href="#lib.shell.editor.View.setRefreshSelection">setRefreshSelection</a></code></li>
<li><code><a title="lib.shell.editor.View.setScrollingRegion" href="#lib.shell.editor.View.setScrollingRegion">setScrollingRegion</a></code></li>
<li><code><a title="lib.shell.editor.View.setText" href="#lib.shell.editor.View.setText">setText</a></code></li>
<li><code><a title="lib.shell.editor.View.showLine" href="#lib.shell.editor.View.showLine">showLine</a></code></li>
<li><code><a title="lib.shell.editor.View.write" href="#lib.shell.editor.View.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>