<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lib.server.mqttprotocol API documentation</title>
<meta name="description" content="Support for mqtt client protocol using asynchronous sockets. Support MQTT 3.11" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.server.mqttprotocol</code></h1>
</header>
<section id="section-intro">
<p>Support for mqtt client protocol using asynchronous sockets. Support MQTT 3.11</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under Pycameresp License
# Copyright (c) 2023 Remi BERTHOLET
# pylint:disable=consider-using-f-string
&#34;&#34;&#34; Support for mqtt client protocol using asynchronous sockets. Support MQTT 3.11 &#34;&#34;&#34;
import uasyncio
import wifi.hostname
import server.mqttclient
import server.notifier
import server.mqttmessages
import tools.logger
import tools.strings
import tools.tasking

class MqttSubscription:
        &#34;&#34;&#34; Subscription callback caller &#34;&#34;&#34;
        def __init__(self, topic, callback, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.topic = topic
                self.kwargs  = kwargs
                self.callback = callback
                self.qos = kwargs.get(&#34;qos&#34;,server.mqttmessages.MQTT_QOS_ONCE)

        async def call(self, message):
                &#34;&#34;&#34; Call callback registered &#34;&#34;&#34;
                await self.callback(message, **self.kwargs)

class MqttClientContext:
        &#34;&#34;&#34; Context of the mqtt client &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                config = server.mqttclient.MqttConfig()
                if config.load() is False:
                        config.save()

                self.kwargs = kwargs
                self.kwargs[&#34;mqtt_host&#34;]  = kwargs.get(&#34;mqtt_host&#34;,config.host)
                self.kwargs[&#34;mqtt_port&#34;]  = kwargs.get(&#34;mqtt_port&#34;,config.port)
                self.kwargs[&#34;username&#34;]   = kwargs.get(&#34;username&#34;,config.username)
                self.kwargs[&#34;password&#34;]   = kwargs.get(&#34;password&#34;,config.password)
                self.kwargs[&#34;keep_alive&#34;] = kwargs.get(&#34;keep_alive&#34;,60)
                if self.kwargs[&#34;keep_alive&#34;] &lt; 10:
                        self.kwargs[&#34;keep_alive&#34;] = 10
                self.keep_alive = self.kwargs[&#34;keep_alive&#34;]
                self.streamio   = None
                self.state = MqttStateMachine.STATE_OPEN
                self.debug = kwargs.get(&#34;debug&#34;,False)
                self.kwargs[&#34;client_id&#34;] = tools.strings.tostrings(kwargs.get(&#34;client_id&#34;,wifi.hostname.Hostname().get_hostname()))
                self.last_establish =  tools.strings.ticks()//1000

class MqttProtocol:
        &#34;&#34;&#34; Manages an mqtt client &#34;&#34;&#34;
        subscriptions = {}
        controls = {}
        context = None
        publications = []

        @staticmethod
        def start(**kwargs):
                &#34;&#34;&#34; Start the mqtt client &#34;&#34;&#34;
                if MqttProtocol.context is None:
                        MqttProtocol.context = MqttClientContext(**kwargs)
                        tools.tasking.Tasks.create_monitor(MqttStateMachine.task, **kwargs)
                        tools.tasking.Tasks.create_monitor(MqttProtocol.ping_task, **kwargs)

        @staticmethod
        async def send(message):
                &#34;&#34;&#34; Send message &#34;&#34;&#34;
                result = False
                if MqttProtocol.context is not None:
                        if MqttProtocol.context.debug:
                                print(&#34;Mqtt send    : %s&#34;%message.__class__.__name__)
                        try:
                                await message.write(MqttProtocol.context.streamio)
                                result = True
                        except Exception as err:
                                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                        tools.logger.syslog(&#34;Mqtt cannot send message&#34;)
                                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
                return result

        @staticmethod
        async def disconnect():
                &#34;&#34;&#34; Send diconnect message &#34;&#34;&#34;
                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttProtocol.send(server.mqttmessages.MqttDisconnect())
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def ping_task(**kwargs):
                &#34;&#34;&#34; Ping server periodicaly &#34;&#34;&#34;
                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttProtocol.send(server.mqttmessages.MqttPingReq())
                        await uasyncio.sleep(MqttProtocol.context.keep_alive)

                        # Send another time publication if not acknowledged
                        if len(MqttProtocol.publications) &gt; 0:
                                for publication in MqttProtocol.publications:
                                        if (publication.sent_time + MqttProtocol.context.keep_alive*500) &lt; tools.strings.ticks():
                                                await MqttProtocol.send(publication)
                                                publication.dup = 1
                else:
                        await uasyncio.sleep(MqttProtocol.context.keep_alive//2)

        @staticmethod
        def add_topic(**kwargs):
                &#34;&#34;&#34; Add a subscription to the topic decorator &#34;&#34;&#34;
                callback = kwargs.get(&#34;callback&#34;,None)
                topic    = kwargs.get(&#34;topic&#34;, None)
                if callback and topic:
                        MqttProtocol.subscriptions[tools.strings.tostrings(topic)] = MqttSubscription(**kwargs)
                        return True
                return False

        @staticmethod
        def remove_topic(**kwargs):
                &#34;&#34;&#34; Remove a subscription to the topic &#34;&#34;&#34;
                topic    = kwargs.get(&#34;topic&#34;, None)
                if topic:
                        subscription = MqttProtocol.subscriptions.get(topic, None)
                        if subscription:
                                del MqttProtocol.subscriptions[topic]

        @staticmethod
        async def subscribe(**kwargs):
                &#34;&#34;&#34; Subscribe topic &#34;&#34;&#34;
                result = True
                if MqttProtocol.context is not None:
                        result = MqttProtocol.add_topic(**kwargs)
                        if result:
                                message = server.mqttmessages.MqttSubscribe(**kwargs)
                                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                        result = await MqttProtocol.send(message)
                else:
                        result = False
                return result

        @staticmethod
        async def unsubscribe(**kwargs):
                &#34;&#34;&#34; Unsubscribe topic &#34;&#34;&#34;
                result = True
                if MqttProtocol.context is not None:
                        message = server.mqttmessages.MqttUnsubscribe(**kwargs)
                        MqttProtocol.remove_topic(**kwargs)
                        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                await MqttProtocol.send(message)
                else:
                        result = False
                return result

        @staticmethod
        async def publish(**kwargs):
                &#34;&#34;&#34; Publish message on topic &#34;&#34;&#34;
                result = True
                if MqttProtocol.context is not None:
                        message = server.mqttmessages.MqttPublish(**kwargs)
                        if &#34;%(client_id)s&#34; in message.topic:
                                message.topic = message.topic%MqttProtocol.context.kwargs
                        if message.qos != server.mqttmessages.MQTT_QOS_ONCE:
                                MqttProtocol.publications.append(message)
                        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                result = await MqttProtocol.send(message)
                                message.dup = 1
                        else:
                                if len(MqttProtocol.publications) &gt; 10:
                                        # Remove older publications
                                        MqttProtocol.publications = MqttProtocol.publications[-10:]
                else:
                        result = False
                return result

        @staticmethod
        async def call_subscription(message):
                &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
                subscription = MqttProtocol.subscriptions.get(tools.strings.tostrings(message.topic), (None,None,None))
                if subscription is not None:
                        try:
                                await subscription.call(message)
                        except Exception as err:
                                tools.logger.syslog(err)

        @staticmethod
        def add_control(control, **kwargs):
                &#34;&#34;&#34; Add a callback to control payload &#34;&#34;&#34;
                def add_control(callback):
                        MqttProtocol.controls[control] = (callback, kwargs)
                        return callback
                return add_control

        @staticmethod
        def remove_control(control):
                &#34;&#34;&#34; Remove callback on control payload &#34;&#34;&#34;
                control = MqttProtocol.controls.get(control, None)
                if control is not None:
                        del MqttProtocol.controls[control]

        @staticmethod
        @server.notifier.Notifier.add()
        async def notify_message(notification):
                &#34;&#34;&#34; Notify message for mqtt &#34;&#34;&#34;
                config = server.mqttclient.MqttConfig()
                if config.load() is False:
                        config.save()

                result = True
                if config.activated or notification.forced:
                        if notification.data:
                                value = notification.data
                        elif notification.value is not None and notification.value != &#34;&#34;:
                                value = notification.value
                        elif notification.message is not None and notification.message != &#34;&#34;:
                                value = notification.message
                        else:
                                value = None

                        if notification.topic and value:
                                if MqttProtocol.notify_message not in notification.sent:
                                        topic = &#34;%(client_id)s/&#34; + tools.strings.tostrings(notification.topic)
                                        result = await MqttProtocol.publish(topic=topic, value=value)
                                        if result is True:
                                                notification.sent.append(MqttProtocol.notify_message)
                                        else:
                                                current_time = (tools.strings.ticks()//1000)
                                                if MqttProtocol.context is not None:
                                                        # If the broker has not been visible for several hours
                                                        if current_time &gt; (MqttProtocol.context.last_establish + 7200):
                                                                # Ignore the error
                                                                result = True
                return result

class MqttStateMachine:
        &#34;&#34;&#34; Mqtt protocol management state machine &#34;&#34;&#34;  
        STATE_OPEN      = 1
        STATE_CONNECT   = 2
        STATE_CONNACK   = 3
        STATE_ACCEPTED  = 4
        STATE_REFUSED   = 5
        STATE_ESTABLISH = 6
        STATE_CLOSE     = 7
        STATE_WAIT      = 8

        @staticmethod
        async def state_open():
                &#34;&#34;&#34; Open mqtt state open socket &#34;&#34;&#34;
                try:
                        reader,writer = await uasyncio.open_connection(tools.strings.tostrings(MqttProtocol.context.kwargs.get(&#34;mqtt_host&#34;)), MqttProtocol.context.kwargs.get(&#34;mqtt_port&#34;))
                        MqttProtocol.context.streamio = server.mqttmessages.MqttStream(reader, writer, **MqttProtocol.context.kwargs)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CONNECT
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_connect():
                &#34;&#34;&#34; Open mqtt state send connect &#34;&#34;&#34;
                try:
                        command = server.mqttmessages.MqttConnect(**MqttProtocol.context.kwargs)
                        command.clean_session = True
                        command.keep_alive = MqttProtocol.context.kwargs.get(&#34;keep_alive&#34;,60)
                        await MqttProtocol.send(command)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CONNACK
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_connack():
                &#34;&#34;&#34; Wait connection acknowledge state &#34;&#34;&#34;
                await MqttStateMachine.state_receive()

        @staticmethod
        async def state_accepted():
                &#34;&#34;&#34; Connection mqtt accepted state &#34;&#34;&#34;
                try:
                        if len(MqttProtocol.subscriptions) &gt; 0:
                                command = server.mqttmessages.MqttSubscribe()
                                for subscription in MqttProtocol.subscriptions.values():
                                        command.add_topic(subscription.topic, subscription.qos)
                                await MqttProtocol.send(command)
                        if len(MqttProtocol.publications) &gt; 0:
                                for publication in MqttProtocol.publications:
                                        await MqttProtocol.send(publication)
                                        publication.dup = 1
                        MqttProtocol.context.state = MqttStateMachine.STATE_ESTABLISH
                        tools.logger.syslog(&#34;Mqtt established (client_id=&#39;%s&#39;)&#34;%MqttProtocol.context.kwargs.get(&#34;client_id&#34;,&#34;&#34;))
                        MqttProtocol.context.last_establish  = tools.strings.ticks()//1000
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_establish():
                &#34;&#34;&#34; Established mqtt state &#34;&#34;&#34;
                await MqttStateMachine.state_receive()

        @staticmethod
        async def state_receive():
                &#34;&#34;&#34; Wait and treat message &#34;&#34;&#34;
                try:
                        try:
                                # Read and decode message
                                message = await uasyncio.wait_for(server.mqttmessages.MqttMessage.receive(MqttProtocol.context.streamio), MqttProtocol.context.keep_alive + MqttProtocol.context.keep_alive//2)
                        except Exception as err:
                                message = None

                        # If message decoded with success
                        if message is not None:
                                MqttProtocol.context.last_establish = tools.strings.ticks()//1000
                                if MqttProtocol.context.debug:
                                        print(&#34;Mqtt receive : %s&#34;%message.__class__.__name__)
                                # Search treatment callback
                                callback, kwargs = MqttProtocol.controls.get(message.control, [None,None])

                                # If callback found
                                if callback:
                                        # Call callback
                                        await callback(message, **kwargs)
                                else:
                                        tools.logger.syslog(&#34;Mqtt callback not found for message=%d&#34;%message.control)
                        else:
                                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                        tools.logger.syslog(&#34;Mqtt lost connection&#34;)
                                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_close():
                &#34;&#34;&#34; Close mqtt state &#34;&#34;&#34;
                try:
                        if MqttProtocol.context.streamio is not None:
                                await MqttProtocol.context.streamio.close()
                                MqttProtocol.context.streamio = None
                        MqttProtocol.context.state = MqttStateMachine.STATE_WAIT
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_WAIT

        @staticmethod
        async def state_wait():
                &#34;&#34;&#34; Wait mqtt state before next reconnection &#34;&#34;&#34;
                current_time = (tools.strings.ticks()//1000)
                # if the last connection dates back more than two hours
                if current_time &gt; (MqttProtocol.context.last_establish + 7200):
                        polling = 3607
                # if the last connection dates back more than an hour
                elif current_time &gt; (MqttProtocol.context.last_establish + 3600):
                        polling = 907
                # if the last connection dates back more than a quarter of an hour
                elif current_time &gt; (MqttProtocol.context.last_establish + 900):
                        polling = 179
                else:
                        polling = 11
                down = current_time - MqttProtocol.context.last_establish
                seconds = (down)%60
                mins    = (down/60)%60
                hours   = (down/3600)%24
                days    = (down/86400)
                tools.logger.syslog(&#34;Mqtt not connected since %d days, %d:%02d:%02d&#34;%(days,hours,mins,seconds))
                await uasyncio.sleep(polling)
                MqttProtocol.context.state = MqttStateMachine.STATE_OPEN

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_CONNACK)
        async def on_conn_ack(message, **kwargs):
                &#34;&#34;&#34; Conn ack treatment &#34;&#34;&#34;
                if MqttProtocol.context.state == MqttStateMachine.STATE_CONNACK:
                        if message.return_code == 0:
                                tools.logger.syslog(&#34;Mqtt connected&#34;)
                                MqttProtocol.context.state = MqttStateMachine.STATE_ACCEPTED
                        else:
                                tools.logger.syslog(&#34;Mqtt connection refused %d&#34;%message.return_code)
                                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
                else:
                        tools.logger.syslog(&#34;Mqtt unexpected connack&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PINGREQ)
        async def on_ping_req(message, **kwargs):
                &#34;&#34;&#34; Ping received &#34;&#34;&#34;
                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttProtocol.send(server.mqttmessages.MqttPingResp())
                else:
                        tools.logger.syslog(&#34;Mqtt unexpected pingreq&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PINGRESP)
        async def on_ping_rsp(message, **kwargs):
                &#34;&#34;&#34; Ping response received &#34;&#34;&#34;
                if MqttProtocol.context.state != MqttStateMachine.STATE_ESTABLISH:
                        tools.logger.syslog(&#34;Mqtt unexpected pingres&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_SUBACK)
        async def on_sub_ack(message, **kwargs):
                &#34;&#34;&#34; Subcribe acknowledge &#34;&#34;&#34;
                if message.return_code[0] == server.mqttmessages.MQTT_SUBACK_FAILURE:
                        tools.logger.syslog(&#34;Mqtt subscribe failed&#34;)

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBACK)
        async def on_pub_ack(message, **kwargs):
                &#34;&#34;&#34; Publish ack received &#34;&#34;&#34;
                for publication in MqttProtocol.publications:
                        if publication.identifier == message.identifier:
                                MqttProtocol.publications.remove(publication)
                                break

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBREC)
        async def on_pub_rec(message, **kwargs):
                &#34;&#34;&#34; Publish received &#34;&#34;&#34;
                await MqttProtocol.send(server.mqttmessages.MqttPubRel(identifier=message.identifier))

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBREL)
        async def on_pub_rel(message, **kwargs):
                &#34;&#34;&#34; Publish release received &#34;&#34;&#34;
                await MqttProtocol.send(server.mqttmessages.MqttPubComp(identifier=message.identifier))

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBCOMP)
        async def on_pub_comp(message, **kwargs):
                &#34;&#34;&#34; Publish complete received &#34;&#34;&#34;
                MqttStateMachine.on_pub_ack(message, **kwargs)

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_UNSUBACK)
        async def on_unsub_ack(message, **kwargs):
                &#34;&#34;&#34; Unsubcribe acknowledge &#34;&#34;&#34;

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_DISCONNECT)
        async def on_disconnect(message, **kwargs):
                &#34;&#34;&#34; Disconnect received &#34;&#34;&#34;
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBLISH)
        async def on_publish(message, **kwargs):
                &#34;&#34;&#34; Published message &#34;&#34;&#34;
                if MqttProtocol.context.debug:
                        print(&#34;Mqtt publish topic &#39;%s&#39;, value=&#39;%s&#39;&#34;%(message.topic, message.value))
                await MqttProtocol.call_subscription(message)
                if message.qos == server.mqttmessages.MQTT_QOS_ONCE:
                        pass
                elif message.qos == server.mqttmessages.MQTT_QOS_LEAST_ONCE:
                        await MqttProtocol.send(server.mqttmessages.MqttPubAck(identifier=message.identifier))
                elif message.qos == server.mqttmessages.MQTT_QOS_EXACTLY_ONCE:
                        await MqttProtocol.send(server.mqttmessages.MqttPubRec(identifier=message.identifier))

        @staticmethod
        async def task(**kwargs):
                &#34;&#34;&#34; Manages mqtt commands received and returns responses &#34;&#34;&#34;
                try:
                        states = {
                                MqttStateMachine.STATE_OPEN      : (&#34;OPEN&#34;,      MqttStateMachine.state_open),
                                MqttStateMachine.STATE_CONNECT   : (&#34;CONNECT&#34;,   MqttStateMachine.state_connect),
                                MqttStateMachine.STATE_CONNACK   : (&#34;CONNACK&#34;,   MqttStateMachine.state_connack),
                                MqttStateMachine.STATE_ACCEPTED  : (&#34;ACCEPTED&#34;,  MqttStateMachine.state_accepted),
                                MqttStateMachine.STATE_ESTABLISH : (&#34;ESTABLISH&#34;, MqttStateMachine.state_establish),
                                MqttStateMachine.STATE_CLOSE     : (&#34;CLOSE&#34;,     MqttStateMachine.state_close),
                                MqttStateMachine.STATE_WAIT      : (&#34;WAIT&#34;,      MqttStateMachine.state_wait)
                        }
                        previous_state_name = &#34;&#34;
                        while True:
                                state_name, callback = states.get(MqttProtocol.context.state, (None,None))
                                if previous_state_name != state_name:
                                        if MqttProtocol.context.debug:
                                                print(&#34;Mqtt state   : %s&#34;%state_name)
                                        previous_state_name = state_name
                                if callback is not None:
                                        await callback()
                                else:
                                        raise server.mqttmessages.MqttException(&#34;Mqtt illegal state&#34;)
                except Exception as err:
                        tools.logger.syslog(err)
                finally:
                        await MqttStateMachine.state_close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.server.mqttprotocol.MqttClientContext"><code class="flex name class">
<span>class <span class="ident">MqttClientContext</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Context of the mqtt client </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttClientContext:
        &#34;&#34;&#34; Context of the mqtt client &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                config = server.mqttclient.MqttConfig()
                if config.load() is False:
                        config.save()

                self.kwargs = kwargs
                self.kwargs[&#34;mqtt_host&#34;]  = kwargs.get(&#34;mqtt_host&#34;,config.host)
                self.kwargs[&#34;mqtt_port&#34;]  = kwargs.get(&#34;mqtt_port&#34;,config.port)
                self.kwargs[&#34;username&#34;]   = kwargs.get(&#34;username&#34;,config.username)
                self.kwargs[&#34;password&#34;]   = kwargs.get(&#34;password&#34;,config.password)
                self.kwargs[&#34;keep_alive&#34;] = kwargs.get(&#34;keep_alive&#34;,60)
                if self.kwargs[&#34;keep_alive&#34;] &lt; 10:
                        self.kwargs[&#34;keep_alive&#34;] = 10
                self.keep_alive = self.kwargs[&#34;keep_alive&#34;]
                self.streamio   = None
                self.state = MqttStateMachine.STATE_OPEN
                self.debug = kwargs.get(&#34;debug&#34;,False)
                self.kwargs[&#34;client_id&#34;] = tools.strings.tostrings(kwargs.get(&#34;client_id&#34;,wifi.hostname.Hostname().get_hostname()))
                self.last_establish =  tools.strings.ticks()//1000</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol"><code class="flex name class">
<span>class <span class="ident">MqttProtocol</span></span>
</code></dt>
<dd>
<div class="desc"><p>Manages an mqtt client</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttProtocol:
        &#34;&#34;&#34; Manages an mqtt client &#34;&#34;&#34;
        subscriptions = {}
        controls = {}
        context = None
        publications = []

        @staticmethod
        def start(**kwargs):
                &#34;&#34;&#34; Start the mqtt client &#34;&#34;&#34;
                if MqttProtocol.context is None:
                        MqttProtocol.context = MqttClientContext(**kwargs)
                        tools.tasking.Tasks.create_monitor(MqttStateMachine.task, **kwargs)
                        tools.tasking.Tasks.create_monitor(MqttProtocol.ping_task, **kwargs)

        @staticmethod
        async def send(message):
                &#34;&#34;&#34; Send message &#34;&#34;&#34;
                result = False
                if MqttProtocol.context is not None:
                        if MqttProtocol.context.debug:
                                print(&#34;Mqtt send    : %s&#34;%message.__class__.__name__)
                        try:
                                await message.write(MqttProtocol.context.streamio)
                                result = True
                        except Exception as err:
                                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                        tools.logger.syslog(&#34;Mqtt cannot send message&#34;)
                                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
                return result

        @staticmethod
        async def disconnect():
                &#34;&#34;&#34; Send diconnect message &#34;&#34;&#34;
                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttProtocol.send(server.mqttmessages.MqttDisconnect())
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def ping_task(**kwargs):
                &#34;&#34;&#34; Ping server periodicaly &#34;&#34;&#34;
                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttProtocol.send(server.mqttmessages.MqttPingReq())
                        await uasyncio.sleep(MqttProtocol.context.keep_alive)

                        # Send another time publication if not acknowledged
                        if len(MqttProtocol.publications) &gt; 0:
                                for publication in MqttProtocol.publications:
                                        if (publication.sent_time + MqttProtocol.context.keep_alive*500) &lt; tools.strings.ticks():
                                                await MqttProtocol.send(publication)
                                                publication.dup = 1
                else:
                        await uasyncio.sleep(MqttProtocol.context.keep_alive//2)

        @staticmethod
        def add_topic(**kwargs):
                &#34;&#34;&#34; Add a subscription to the topic decorator &#34;&#34;&#34;
                callback = kwargs.get(&#34;callback&#34;,None)
                topic    = kwargs.get(&#34;topic&#34;, None)
                if callback and topic:
                        MqttProtocol.subscriptions[tools.strings.tostrings(topic)] = MqttSubscription(**kwargs)
                        return True
                return False

        @staticmethod
        def remove_topic(**kwargs):
                &#34;&#34;&#34; Remove a subscription to the topic &#34;&#34;&#34;
                topic    = kwargs.get(&#34;topic&#34;, None)
                if topic:
                        subscription = MqttProtocol.subscriptions.get(topic, None)
                        if subscription:
                                del MqttProtocol.subscriptions[topic]

        @staticmethod
        async def subscribe(**kwargs):
                &#34;&#34;&#34; Subscribe topic &#34;&#34;&#34;
                result = True
                if MqttProtocol.context is not None:
                        result = MqttProtocol.add_topic(**kwargs)
                        if result:
                                message = server.mqttmessages.MqttSubscribe(**kwargs)
                                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                        result = await MqttProtocol.send(message)
                else:
                        result = False
                return result

        @staticmethod
        async def unsubscribe(**kwargs):
                &#34;&#34;&#34; Unsubscribe topic &#34;&#34;&#34;
                result = True
                if MqttProtocol.context is not None:
                        message = server.mqttmessages.MqttUnsubscribe(**kwargs)
                        MqttProtocol.remove_topic(**kwargs)
                        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                await MqttProtocol.send(message)
                else:
                        result = False
                return result

        @staticmethod
        async def publish(**kwargs):
                &#34;&#34;&#34; Publish message on topic &#34;&#34;&#34;
                result = True
                if MqttProtocol.context is not None:
                        message = server.mqttmessages.MqttPublish(**kwargs)
                        if &#34;%(client_id)s&#34; in message.topic:
                                message.topic = message.topic%MqttProtocol.context.kwargs
                        if message.qos != server.mqttmessages.MQTT_QOS_ONCE:
                                MqttProtocol.publications.append(message)
                        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                result = await MqttProtocol.send(message)
                                message.dup = 1
                        else:
                                if len(MqttProtocol.publications) &gt; 10:
                                        # Remove older publications
                                        MqttProtocol.publications = MqttProtocol.publications[-10:]
                else:
                        result = False
                return result

        @staticmethod
        async def call_subscription(message):
                &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
                subscription = MqttProtocol.subscriptions.get(tools.strings.tostrings(message.topic), (None,None,None))
                if subscription is not None:
                        try:
                                await subscription.call(message)
                        except Exception as err:
                                tools.logger.syslog(err)

        @staticmethod
        def add_control(control, **kwargs):
                &#34;&#34;&#34; Add a callback to control payload &#34;&#34;&#34;
                def add_control(callback):
                        MqttProtocol.controls[control] = (callback, kwargs)
                        return callback
                return add_control

        @staticmethod
        def remove_control(control):
                &#34;&#34;&#34; Remove callback on control payload &#34;&#34;&#34;
                control = MqttProtocol.controls.get(control, None)
                if control is not None:
                        del MqttProtocol.controls[control]

        @staticmethod
        @server.notifier.Notifier.add()
        async def notify_message(notification):
                &#34;&#34;&#34; Notify message for mqtt &#34;&#34;&#34;
                config = server.mqttclient.MqttConfig()
                if config.load() is False:
                        config.save()

                result = True
                if config.activated or notification.forced:
                        if notification.data:
                                value = notification.data
                        elif notification.value is not None and notification.value != &#34;&#34;:
                                value = notification.value
                        elif notification.message is not None and notification.message != &#34;&#34;:
                                value = notification.message
                        else:
                                value = None

                        if notification.topic and value:
                                if MqttProtocol.notify_message not in notification.sent:
                                        topic = &#34;%(client_id)s/&#34; + tools.strings.tostrings(notification.topic)
                                        result = await MqttProtocol.publish(topic=topic, value=value)
                                        if result is True:
                                                notification.sent.append(MqttProtocol.notify_message)
                                        else:
                                                current_time = (tools.strings.ticks()//1000)
                                                if MqttProtocol.context is not None:
                                                        # If the broker has not been visible for several hours
                                                        if current_time &gt; (MqttProtocol.context.last_establish + 7200):
                                                                # Ignore the error
                                                                result = True
                return result</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.server.mqttprotocol.MqttProtocol.context"><code class="name">var <span class="ident">context</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.controls"><code class="name">var <span class="ident">controls</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.publications"><code class="name">var <span class="ident">publications</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.subscriptions"><code class="name">var <span class="ident">subscriptions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.server.mqttprotocol.MqttProtocol.add_control"><code class="name flex">
<span>def <span class="ident">add_control</span></span>(<span>control, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a callback to control payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_control(control, **kwargs):
        &#34;&#34;&#34; Add a callback to control payload &#34;&#34;&#34;
        def add_control(callback):
                MqttProtocol.controls[control] = (callback, kwargs)
                return callback
        return add_control</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.add_topic"><code class="name flex">
<span>def <span class="ident">add_topic</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a subscription to the topic decorator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_topic(**kwargs):
        &#34;&#34;&#34; Add a subscription to the topic decorator &#34;&#34;&#34;
        callback = kwargs.get(&#34;callback&#34;,None)
        topic    = kwargs.get(&#34;topic&#34;, None)
        if callback and topic:
                MqttProtocol.subscriptions[tools.strings.tostrings(topic)] = MqttSubscription(**kwargs)
                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.call_subscription"><code class="name flex">
<span>async def <span class="ident">call_subscription</span></span>(<span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove callback on subscription</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def call_subscription(message):
        &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
        subscription = MqttProtocol.subscriptions.get(tools.strings.tostrings(message.topic), (None,None,None))
        if subscription is not None:
                try:
                        await subscription.call(message)
                except Exception as err:
                        tools.logger.syslog(err)</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Send diconnect message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def disconnect():
        &#34;&#34;&#34; Send diconnect message &#34;&#34;&#34;
        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                await MqttProtocol.send(server.mqttmessages.MqttDisconnect())
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.notify_message"><code class="name flex">
<span>async def <span class="ident">notify_message</span></span>(<span>notification)</span>
</code></dt>
<dd>
<div class="desc"><p>Notify message for mqtt</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@server.notifier.Notifier.add()
async def notify_message(notification):
        &#34;&#34;&#34; Notify message for mqtt &#34;&#34;&#34;
        config = server.mqttclient.MqttConfig()
        if config.load() is False:
                config.save()

        result = True
        if config.activated or notification.forced:
                if notification.data:
                        value = notification.data
                elif notification.value is not None and notification.value != &#34;&#34;:
                        value = notification.value
                elif notification.message is not None and notification.message != &#34;&#34;:
                        value = notification.message
                else:
                        value = None

                if notification.topic and value:
                        if MqttProtocol.notify_message not in notification.sent:
                                topic = &#34;%(client_id)s/&#34; + tools.strings.tostrings(notification.topic)
                                result = await MqttProtocol.publish(topic=topic, value=value)
                                if result is True:
                                        notification.sent.append(MqttProtocol.notify_message)
                                else:
                                        current_time = (tools.strings.ticks()//1000)
                                        if MqttProtocol.context is not None:
                                                # If the broker has not been visible for several hours
                                                if current_time &gt; (MqttProtocol.context.last_establish + 7200):
                                                        # Ignore the error
                                                        result = True
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.ping_task"><code class="name flex">
<span>async def <span class="ident">ping_task</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ping server periodicaly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def ping_task(**kwargs):
        &#34;&#34;&#34; Ping server periodicaly &#34;&#34;&#34;
        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                await MqttProtocol.send(server.mqttmessages.MqttPingReq())
                await uasyncio.sleep(MqttProtocol.context.keep_alive)

                # Send another time publication if not acknowledged
                if len(MqttProtocol.publications) &gt; 0:
                        for publication in MqttProtocol.publications:
                                if (publication.sent_time + MqttProtocol.context.keep_alive*500) &lt; tools.strings.ticks():
                                        await MqttProtocol.send(publication)
                                        publication.dup = 1
        else:
                await uasyncio.sleep(MqttProtocol.context.keep_alive//2)</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.publish"><code class="name flex">
<span>async def <span class="ident">publish</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish message on topic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def publish(**kwargs):
        &#34;&#34;&#34; Publish message on topic &#34;&#34;&#34;
        result = True
        if MqttProtocol.context is not None:
                message = server.mqttmessages.MqttPublish(**kwargs)
                if &#34;%(client_id)s&#34; in message.topic:
                        message.topic = message.topic%MqttProtocol.context.kwargs
                if message.qos != server.mqttmessages.MQTT_QOS_ONCE:
                        MqttProtocol.publications.append(message)
                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                        result = await MqttProtocol.send(message)
                        message.dup = 1
                else:
                        if len(MqttProtocol.publications) &gt; 10:
                                # Remove older publications
                                MqttProtocol.publications = MqttProtocol.publications[-10:]
        else:
                result = False
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.remove_control"><code class="name flex">
<span>def <span class="ident">remove_control</span></span>(<span>control)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove callback on control payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_control(control):
        &#34;&#34;&#34; Remove callback on control payload &#34;&#34;&#34;
        control = MqttProtocol.controls.get(control, None)
        if control is not None:
                del MqttProtocol.controls[control]</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.remove_topic"><code class="name flex">
<span>def <span class="ident">remove_topic</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a subscription to the topic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_topic(**kwargs):
        &#34;&#34;&#34; Remove a subscription to the topic &#34;&#34;&#34;
        topic    = kwargs.get(&#34;topic&#34;, None)
        if topic:
                subscription = MqttProtocol.subscriptions.get(topic, None)
                if subscription:
                        del MqttProtocol.subscriptions[topic]</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Send message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def send(message):
        &#34;&#34;&#34; Send message &#34;&#34;&#34;
        result = False
        if MqttProtocol.context is not None:
                if MqttProtocol.context.debug:
                        print(&#34;Mqtt send    : %s&#34;%message.__class__.__name__)
                try:
                        await message.write(MqttProtocol.context.streamio)
                        result = True
                except Exception as err:
                        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                tools.logger.syslog(&#34;Mqtt cannot send message&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the mqtt client</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def start(**kwargs):
        &#34;&#34;&#34; Start the mqtt client &#34;&#34;&#34;
        if MqttProtocol.context is None:
                MqttProtocol.context = MqttClientContext(**kwargs)
                tools.tasking.Tasks.create_monitor(MqttStateMachine.task, **kwargs)
                tools.tasking.Tasks.create_monitor(MqttProtocol.ping_task, **kwargs)</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.subscribe"><code class="name flex">
<span>async def <span class="ident">subscribe</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Subscribe topic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def subscribe(**kwargs):
        &#34;&#34;&#34; Subscribe topic &#34;&#34;&#34;
        result = True
        if MqttProtocol.context is not None:
                result = MqttProtocol.add_topic(**kwargs)
                if result:
                        message = server.mqttmessages.MqttSubscribe(**kwargs)
                        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                result = await MqttProtocol.send(message)
        else:
                result = False
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttProtocol.unsubscribe"><code class="name flex">
<span>async def <span class="ident">unsubscribe</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsubscribe topic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def unsubscribe(**kwargs):
        &#34;&#34;&#34; Unsubscribe topic &#34;&#34;&#34;
        result = True
        if MqttProtocol.context is not None:
                message = server.mqttmessages.MqttUnsubscribe(**kwargs)
                MqttProtocol.remove_topic(**kwargs)
                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttProtocol.send(message)
        else:
                result = False
        return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine"><code class="flex name class">
<span>class <span class="ident">MqttStateMachine</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mqtt protocol management state machine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttStateMachine:
        &#34;&#34;&#34; Mqtt protocol management state machine &#34;&#34;&#34;  
        STATE_OPEN      = 1
        STATE_CONNECT   = 2
        STATE_CONNACK   = 3
        STATE_ACCEPTED  = 4
        STATE_REFUSED   = 5
        STATE_ESTABLISH = 6
        STATE_CLOSE     = 7
        STATE_WAIT      = 8

        @staticmethod
        async def state_open():
                &#34;&#34;&#34; Open mqtt state open socket &#34;&#34;&#34;
                try:
                        reader,writer = await uasyncio.open_connection(tools.strings.tostrings(MqttProtocol.context.kwargs.get(&#34;mqtt_host&#34;)), MqttProtocol.context.kwargs.get(&#34;mqtt_port&#34;))
                        MqttProtocol.context.streamio = server.mqttmessages.MqttStream(reader, writer, **MqttProtocol.context.kwargs)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CONNECT
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_connect():
                &#34;&#34;&#34; Open mqtt state send connect &#34;&#34;&#34;
                try:
                        command = server.mqttmessages.MqttConnect(**MqttProtocol.context.kwargs)
                        command.clean_session = True
                        command.keep_alive = MqttProtocol.context.kwargs.get(&#34;keep_alive&#34;,60)
                        await MqttProtocol.send(command)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CONNACK
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_connack():
                &#34;&#34;&#34; Wait connection acknowledge state &#34;&#34;&#34;
                await MqttStateMachine.state_receive()

        @staticmethod
        async def state_accepted():
                &#34;&#34;&#34; Connection mqtt accepted state &#34;&#34;&#34;
                try:
                        if len(MqttProtocol.subscriptions) &gt; 0:
                                command = server.mqttmessages.MqttSubscribe()
                                for subscription in MqttProtocol.subscriptions.values():
                                        command.add_topic(subscription.topic, subscription.qos)
                                await MqttProtocol.send(command)
                        if len(MqttProtocol.publications) &gt; 0:
                                for publication in MqttProtocol.publications:
                                        await MqttProtocol.send(publication)
                                        publication.dup = 1
                        MqttProtocol.context.state = MqttStateMachine.STATE_ESTABLISH
                        tools.logger.syslog(&#34;Mqtt established (client_id=&#39;%s&#39;)&#34;%MqttProtocol.context.kwargs.get(&#34;client_id&#34;,&#34;&#34;))
                        MqttProtocol.context.last_establish  = tools.strings.ticks()//1000
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_establish():
                &#34;&#34;&#34; Established mqtt state &#34;&#34;&#34;
                await MqttStateMachine.state_receive()

        @staticmethod
        async def state_receive():
                &#34;&#34;&#34; Wait and treat message &#34;&#34;&#34;
                try:
                        try:
                                # Read and decode message
                                message = await uasyncio.wait_for(server.mqttmessages.MqttMessage.receive(MqttProtocol.context.streamio), MqttProtocol.context.keep_alive + MqttProtocol.context.keep_alive//2)
                        except Exception as err:
                                message = None

                        # If message decoded with success
                        if message is not None:
                                MqttProtocol.context.last_establish = tools.strings.ticks()//1000
                                if MqttProtocol.context.debug:
                                        print(&#34;Mqtt receive : %s&#34;%message.__class__.__name__)
                                # Search treatment callback
                                callback, kwargs = MqttProtocol.controls.get(message.control, [None,None])

                                # If callback found
                                if callback:
                                        # Call callback
                                        await callback(message, **kwargs)
                                else:
                                        tools.logger.syslog(&#34;Mqtt callback not found for message=%d&#34;%message.control)
                        else:
                                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                        tools.logger.syslog(&#34;Mqtt lost connection&#34;)
                                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_close():
                &#34;&#34;&#34; Close mqtt state &#34;&#34;&#34;
                try:
                        if MqttProtocol.context.streamio is not None:
                                await MqttProtocol.context.streamio.close()
                                MqttProtocol.context.streamio = None
                        MqttProtocol.context.state = MqttStateMachine.STATE_WAIT
                except Exception as err:
                        MqttProtocol.context.state = MqttStateMachine.STATE_WAIT

        @staticmethod
        async def state_wait():
                &#34;&#34;&#34; Wait mqtt state before next reconnection &#34;&#34;&#34;
                current_time = (tools.strings.ticks()//1000)
                # if the last connection dates back more than two hours
                if current_time &gt; (MqttProtocol.context.last_establish + 7200):
                        polling = 3607
                # if the last connection dates back more than an hour
                elif current_time &gt; (MqttProtocol.context.last_establish + 3600):
                        polling = 907
                # if the last connection dates back more than a quarter of an hour
                elif current_time &gt; (MqttProtocol.context.last_establish + 900):
                        polling = 179
                else:
                        polling = 11
                down = current_time - MqttProtocol.context.last_establish
                seconds = (down)%60
                mins    = (down/60)%60
                hours   = (down/3600)%24
                days    = (down/86400)
                tools.logger.syslog(&#34;Mqtt not connected since %d days, %d:%02d:%02d&#34;%(days,hours,mins,seconds))
                await uasyncio.sleep(polling)
                MqttProtocol.context.state = MqttStateMachine.STATE_OPEN

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_CONNACK)
        async def on_conn_ack(message, **kwargs):
                &#34;&#34;&#34; Conn ack treatment &#34;&#34;&#34;
                if MqttProtocol.context.state == MqttStateMachine.STATE_CONNACK:
                        if message.return_code == 0:
                                tools.logger.syslog(&#34;Mqtt connected&#34;)
                                MqttProtocol.context.state = MqttStateMachine.STATE_ACCEPTED
                        else:
                                tools.logger.syslog(&#34;Mqtt connection refused %d&#34;%message.return_code)
                                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
                else:
                        tools.logger.syslog(&#34;Mqtt unexpected connack&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PINGREQ)
        async def on_ping_req(message, **kwargs):
                &#34;&#34;&#34; Ping received &#34;&#34;&#34;
                if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttProtocol.send(server.mqttmessages.MqttPingResp())
                else:
                        tools.logger.syslog(&#34;Mqtt unexpected pingreq&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PINGRESP)
        async def on_ping_rsp(message, **kwargs):
                &#34;&#34;&#34; Ping response received &#34;&#34;&#34;
                if MqttProtocol.context.state != MqttStateMachine.STATE_ESTABLISH:
                        tools.logger.syslog(&#34;Mqtt unexpected pingres&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_SUBACK)
        async def on_sub_ack(message, **kwargs):
                &#34;&#34;&#34; Subcribe acknowledge &#34;&#34;&#34;
                if message.return_code[0] == server.mqttmessages.MQTT_SUBACK_FAILURE:
                        tools.logger.syslog(&#34;Mqtt subscribe failed&#34;)

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBACK)
        async def on_pub_ack(message, **kwargs):
                &#34;&#34;&#34; Publish ack received &#34;&#34;&#34;
                for publication in MqttProtocol.publications:
                        if publication.identifier == message.identifier:
                                MqttProtocol.publications.remove(publication)
                                break

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBREC)
        async def on_pub_rec(message, **kwargs):
                &#34;&#34;&#34; Publish received &#34;&#34;&#34;
                await MqttProtocol.send(server.mqttmessages.MqttPubRel(identifier=message.identifier))

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBREL)
        async def on_pub_rel(message, **kwargs):
                &#34;&#34;&#34; Publish release received &#34;&#34;&#34;
                await MqttProtocol.send(server.mqttmessages.MqttPubComp(identifier=message.identifier))

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBCOMP)
        async def on_pub_comp(message, **kwargs):
                &#34;&#34;&#34; Publish complete received &#34;&#34;&#34;
                MqttStateMachine.on_pub_ack(message, **kwargs)

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_UNSUBACK)
        async def on_unsub_ack(message, **kwargs):
                &#34;&#34;&#34; Unsubcribe acknowledge &#34;&#34;&#34;

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_DISCONNECT)
        async def on_disconnect(message, **kwargs):
                &#34;&#34;&#34; Disconnect received &#34;&#34;&#34;
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttProtocol.add_control(server.mqttmessages.MQTT_PUBLISH)
        async def on_publish(message, **kwargs):
                &#34;&#34;&#34; Published message &#34;&#34;&#34;
                if MqttProtocol.context.debug:
                        print(&#34;Mqtt publish topic &#39;%s&#39;, value=&#39;%s&#39;&#34;%(message.topic, message.value))
                await MqttProtocol.call_subscription(message)
                if message.qos == server.mqttmessages.MQTT_QOS_ONCE:
                        pass
                elif message.qos == server.mqttmessages.MQTT_QOS_LEAST_ONCE:
                        await MqttProtocol.send(server.mqttmessages.MqttPubAck(identifier=message.identifier))
                elif message.qos == server.mqttmessages.MQTT_QOS_EXACTLY_ONCE:
                        await MqttProtocol.send(server.mqttmessages.MqttPubRec(identifier=message.identifier))

        @staticmethod
        async def task(**kwargs):
                &#34;&#34;&#34; Manages mqtt commands received and returns responses &#34;&#34;&#34;
                try:
                        states = {
                                MqttStateMachine.STATE_OPEN      : (&#34;OPEN&#34;,      MqttStateMachine.state_open),
                                MqttStateMachine.STATE_CONNECT   : (&#34;CONNECT&#34;,   MqttStateMachine.state_connect),
                                MqttStateMachine.STATE_CONNACK   : (&#34;CONNACK&#34;,   MqttStateMachine.state_connack),
                                MqttStateMachine.STATE_ACCEPTED  : (&#34;ACCEPTED&#34;,  MqttStateMachine.state_accepted),
                                MqttStateMachine.STATE_ESTABLISH : (&#34;ESTABLISH&#34;, MqttStateMachine.state_establish),
                                MqttStateMachine.STATE_CLOSE     : (&#34;CLOSE&#34;,     MqttStateMachine.state_close),
                                MqttStateMachine.STATE_WAIT      : (&#34;WAIT&#34;,      MqttStateMachine.state_wait)
                        }
                        previous_state_name = &#34;&#34;
                        while True:
                                state_name, callback = states.get(MqttProtocol.context.state, (None,None))
                                if previous_state_name != state_name:
                                        if MqttProtocol.context.debug:
                                                print(&#34;Mqtt state   : %s&#34;%state_name)
                                        previous_state_name = state_name
                                if callback is not None:
                                        await callback()
                                else:
                                        raise server.mqttmessages.MqttException(&#34;Mqtt illegal state&#34;)
                except Exception as err:
                        tools.logger.syslog(err)
                finally:
                        await MqttStateMachine.state_close()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.server.mqttprotocol.MqttStateMachine.STATE_ACCEPTED"><code class="name">var <span class="ident">STATE_ACCEPTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.STATE_CLOSE"><code class="name">var <span class="ident">STATE_CLOSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.STATE_CONNACK"><code class="name">var <span class="ident">STATE_CONNACK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.STATE_CONNECT"><code class="name">var <span class="ident">STATE_CONNECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.STATE_ESTABLISH"><code class="name">var <span class="ident">STATE_ESTABLISH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.STATE_OPEN"><code class="name">var <span class="ident">STATE_OPEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.STATE_REFUSED"><code class="name">var <span class="ident">STATE_REFUSED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.STATE_WAIT"><code class="name">var <span class="ident">STATE_WAIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_conn_ack"><code class="name flex">
<span>async def <span class="ident">on_conn_ack</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Conn ack treatment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_CONNACK)
async def on_conn_ack(message, **kwargs):
        &#34;&#34;&#34; Conn ack treatment &#34;&#34;&#34;
        if MqttProtocol.context.state == MqttStateMachine.STATE_CONNACK:
                if message.return_code == 0:
                        tools.logger.syslog(&#34;Mqtt connected&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_ACCEPTED
                else:
                        tools.logger.syslog(&#34;Mqtt connection refused %d&#34;%message.return_code)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
        else:
                tools.logger.syslog(&#34;Mqtt unexpected connack&#34;)
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_disconnect"><code class="name flex">
<span>async def <span class="ident">on_disconnect</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_DISCONNECT)
async def on_disconnect(message, **kwargs):
        &#34;&#34;&#34; Disconnect received &#34;&#34;&#34;
        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_ping_req"><code class="name flex">
<span>async def <span class="ident">on_ping_req</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ping received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_PINGREQ)
async def on_ping_req(message, **kwargs):
        &#34;&#34;&#34; Ping received &#34;&#34;&#34;
        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                await MqttProtocol.send(server.mqttmessages.MqttPingResp())
        else:
                tools.logger.syslog(&#34;Mqtt unexpected pingreq&#34;)
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_ping_rsp"><code class="name flex">
<span>async def <span class="ident">on_ping_rsp</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ping response received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_PINGRESP)
async def on_ping_rsp(message, **kwargs):
        &#34;&#34;&#34; Ping response received &#34;&#34;&#34;
        if MqttProtocol.context.state != MqttStateMachine.STATE_ESTABLISH:
                tools.logger.syslog(&#34;Mqtt unexpected pingres&#34;)
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_pub_ack"><code class="name flex">
<span>async def <span class="ident">on_pub_ack</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish ack received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_PUBACK)
async def on_pub_ack(message, **kwargs):
        &#34;&#34;&#34; Publish ack received &#34;&#34;&#34;
        for publication in MqttProtocol.publications:
                if publication.identifier == message.identifier:
                        MqttProtocol.publications.remove(publication)
                        break</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_pub_comp"><code class="name flex">
<span>async def <span class="ident">on_pub_comp</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish complete received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_PUBCOMP)
async def on_pub_comp(message, **kwargs):
        &#34;&#34;&#34; Publish complete received &#34;&#34;&#34;
        MqttStateMachine.on_pub_ack(message, **kwargs)</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_pub_rec"><code class="name flex">
<span>async def <span class="ident">on_pub_rec</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_PUBREC)
async def on_pub_rec(message, **kwargs):
        &#34;&#34;&#34; Publish received &#34;&#34;&#34;
        await MqttProtocol.send(server.mqttmessages.MqttPubRel(identifier=message.identifier))</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_pub_rel"><code class="name flex">
<span>async def <span class="ident">on_pub_rel</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish release received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_PUBREL)
async def on_pub_rel(message, **kwargs):
        &#34;&#34;&#34; Publish release received &#34;&#34;&#34;
        await MqttProtocol.send(server.mqttmessages.MqttPubComp(identifier=message.identifier))</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_publish"><code class="name flex">
<span>async def <span class="ident">on_publish</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Published message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_PUBLISH)
async def on_publish(message, **kwargs):
        &#34;&#34;&#34; Published message &#34;&#34;&#34;
        if MqttProtocol.context.debug:
                print(&#34;Mqtt publish topic &#39;%s&#39;, value=&#39;%s&#39;&#34;%(message.topic, message.value))
        await MqttProtocol.call_subscription(message)
        if message.qos == server.mqttmessages.MQTT_QOS_ONCE:
                pass
        elif message.qos == server.mqttmessages.MQTT_QOS_LEAST_ONCE:
                await MqttProtocol.send(server.mqttmessages.MqttPubAck(identifier=message.identifier))
        elif message.qos == server.mqttmessages.MQTT_QOS_EXACTLY_ONCE:
                await MqttProtocol.send(server.mqttmessages.MqttPubRec(identifier=message.identifier))</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_sub_ack"><code class="name flex">
<span>async def <span class="ident">on_sub_ack</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Subcribe acknowledge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_SUBACK)
async def on_sub_ack(message, **kwargs):
        &#34;&#34;&#34; Subcribe acknowledge &#34;&#34;&#34;
        if message.return_code[0] == server.mqttmessages.MQTT_SUBACK_FAILURE:
                tools.logger.syslog(&#34;Mqtt subscribe failed&#34;)</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.on_unsub_ack"><code class="name flex">
<span>async def <span class="ident">on_unsub_ack</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsubcribe acknowledge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttProtocol.add_control(server.mqttmessages.MQTT_UNSUBACK)
async def on_unsub_ack(message, **kwargs):
        &#34;&#34;&#34; Unsubcribe acknowledge &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.state_accepted"><code class="name flex">
<span>async def <span class="ident">state_accepted</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connection mqtt accepted state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_accepted():
        &#34;&#34;&#34; Connection mqtt accepted state &#34;&#34;&#34;
        try:
                if len(MqttProtocol.subscriptions) &gt; 0:
                        command = server.mqttmessages.MqttSubscribe()
                        for subscription in MqttProtocol.subscriptions.values():
                                command.add_topic(subscription.topic, subscription.qos)
                        await MqttProtocol.send(command)
                if len(MqttProtocol.publications) &gt; 0:
                        for publication in MqttProtocol.publications:
                                await MqttProtocol.send(publication)
                                publication.dup = 1
                MqttProtocol.context.state = MqttStateMachine.STATE_ESTABLISH
                tools.logger.syslog(&#34;Mqtt established (client_id=&#39;%s&#39;)&#34;%MqttProtocol.context.kwargs.get(&#34;client_id&#34;,&#34;&#34;))
                MqttProtocol.context.last_establish  = tools.strings.ticks()//1000
        except Exception as err:
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.state_close"><code class="name flex">
<span>async def <span class="ident">state_close</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Close mqtt state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_close():
        &#34;&#34;&#34; Close mqtt state &#34;&#34;&#34;
        try:
                if MqttProtocol.context.streamio is not None:
                        await MqttProtocol.context.streamio.close()
                        MqttProtocol.context.streamio = None
                MqttProtocol.context.state = MqttStateMachine.STATE_WAIT
        except Exception as err:
                MqttProtocol.context.state = MqttStateMachine.STATE_WAIT</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.state_connack"><code class="name flex">
<span>async def <span class="ident">state_connack</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait connection acknowledge state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_connack():
        &#34;&#34;&#34; Wait connection acknowledge state &#34;&#34;&#34;
        await MqttStateMachine.state_receive()</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.state_connect"><code class="name flex">
<span>async def <span class="ident">state_connect</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Open mqtt state send connect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_connect():
        &#34;&#34;&#34; Open mqtt state send connect &#34;&#34;&#34;
        try:
                command = server.mqttmessages.MqttConnect(**MqttProtocol.context.kwargs)
                command.clean_session = True
                command.keep_alive = MqttProtocol.context.kwargs.get(&#34;keep_alive&#34;,60)
                await MqttProtocol.send(command)
                MqttProtocol.context.state = MqttStateMachine.STATE_CONNACK
        except Exception as err:
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.state_establish"><code class="name flex">
<span>async def <span class="ident">state_establish</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Established mqtt state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_establish():
        &#34;&#34;&#34; Established mqtt state &#34;&#34;&#34;
        await MqttStateMachine.state_receive()</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.state_open"><code class="name flex">
<span>async def <span class="ident">state_open</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Open mqtt state open socket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_open():
        &#34;&#34;&#34; Open mqtt state open socket &#34;&#34;&#34;
        try:
                reader,writer = await uasyncio.open_connection(tools.strings.tostrings(MqttProtocol.context.kwargs.get(&#34;mqtt_host&#34;)), MqttProtocol.context.kwargs.get(&#34;mqtt_port&#34;))
                MqttProtocol.context.streamio = server.mqttmessages.MqttStream(reader, writer, **MqttProtocol.context.kwargs)
                MqttProtocol.context.state = MqttStateMachine.STATE_CONNECT
        except Exception as err:
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.state_receive"><code class="name flex">
<span>async def <span class="ident">state_receive</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait and treat message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_receive():
        &#34;&#34;&#34; Wait and treat message &#34;&#34;&#34;
        try:
                try:
                        # Read and decode message
                        message = await uasyncio.wait_for(server.mqttmessages.MqttMessage.receive(MqttProtocol.context.streamio), MqttProtocol.context.keep_alive + MqttProtocol.context.keep_alive//2)
                except Exception as err:
                        message = None

                # If message decoded with success
                if message is not None:
                        MqttProtocol.context.last_establish = tools.strings.ticks()//1000
                        if MqttProtocol.context.debug:
                                print(&#34;Mqtt receive : %s&#34;%message.__class__.__name__)
                        # Search treatment callback
                        callback, kwargs = MqttProtocol.controls.get(message.control, [None,None])

                        # If callback found
                        if callback:
                                # Call callback
                                await callback(message, **kwargs)
                        else:
                                tools.logger.syslog(&#34;Mqtt callback not found for message=%d&#34;%message.control)
                else:
                        if MqttProtocol.context.state == MqttStateMachine.STATE_ESTABLISH:
                                tools.logger.syslog(&#34;Mqtt lost connection&#34;)
                        MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE
        except Exception as err:
                MqttProtocol.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.state_wait"><code class="name flex">
<span>async def <span class="ident">state_wait</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait mqtt state before next reconnection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_wait():
        &#34;&#34;&#34; Wait mqtt state before next reconnection &#34;&#34;&#34;
        current_time = (tools.strings.ticks()//1000)
        # if the last connection dates back more than two hours
        if current_time &gt; (MqttProtocol.context.last_establish + 7200):
                polling = 3607
        # if the last connection dates back more than an hour
        elif current_time &gt; (MqttProtocol.context.last_establish + 3600):
                polling = 907
        # if the last connection dates back more than a quarter of an hour
        elif current_time &gt; (MqttProtocol.context.last_establish + 900):
                polling = 179
        else:
                polling = 11
        down = current_time - MqttProtocol.context.last_establish
        seconds = (down)%60
        mins    = (down/60)%60
        hours   = (down/3600)%24
        days    = (down/86400)
        tools.logger.syslog(&#34;Mqtt not connected since %d days, %d:%02d:%02d&#34;%(days,hours,mins,seconds))
        await uasyncio.sleep(polling)
        MqttProtocol.context.state = MqttStateMachine.STATE_OPEN</code></pre>
</details>
</dd>
<dt id="lib.server.mqttprotocol.MqttStateMachine.task"><code class="name flex">
<span>async def <span class="ident">task</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages mqtt commands received and returns responses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def task(**kwargs):
        &#34;&#34;&#34; Manages mqtt commands received and returns responses &#34;&#34;&#34;
        try:
                states = {
                        MqttStateMachine.STATE_OPEN      : (&#34;OPEN&#34;,      MqttStateMachine.state_open),
                        MqttStateMachine.STATE_CONNECT   : (&#34;CONNECT&#34;,   MqttStateMachine.state_connect),
                        MqttStateMachine.STATE_CONNACK   : (&#34;CONNACK&#34;,   MqttStateMachine.state_connack),
                        MqttStateMachine.STATE_ACCEPTED  : (&#34;ACCEPTED&#34;,  MqttStateMachine.state_accepted),
                        MqttStateMachine.STATE_ESTABLISH : (&#34;ESTABLISH&#34;, MqttStateMachine.state_establish),
                        MqttStateMachine.STATE_CLOSE     : (&#34;CLOSE&#34;,     MqttStateMachine.state_close),
                        MqttStateMachine.STATE_WAIT      : (&#34;WAIT&#34;,      MqttStateMachine.state_wait)
                }
                previous_state_name = &#34;&#34;
                while True:
                        state_name, callback = states.get(MqttProtocol.context.state, (None,None))
                        if previous_state_name != state_name:
                                if MqttProtocol.context.debug:
                                        print(&#34;Mqtt state   : %s&#34;%state_name)
                                previous_state_name = state_name
                        if callback is not None:
                                await callback()
                        else:
                                raise server.mqttmessages.MqttException(&#34;Mqtt illegal state&#34;)
        except Exception as err:
                tools.logger.syslog(err)
        finally:
                await MqttStateMachine.state_close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.mqttprotocol.MqttSubscription"><code class="flex name class">
<span>class <span class="ident">MqttSubscription</span></span>
<span>(</span><span>topic, callback, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Subscription callback caller </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttSubscription:
        &#34;&#34;&#34; Subscription callback caller &#34;&#34;&#34;
        def __init__(self, topic, callback, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.topic = topic
                self.kwargs  = kwargs
                self.callback = callback
                self.qos = kwargs.get(&#34;qos&#34;,server.mqttmessages.MQTT_QOS_ONCE)

        async def call(self, message):
                &#34;&#34;&#34; Call callback registered &#34;&#34;&#34;
                await self.callback(message, **self.kwargs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqttprotocol.MqttSubscription.call"><code class="name flex">
<span>async def <span class="ident">call</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Call callback registered</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def call(self, message):
        &#34;&#34;&#34; Call callback registered &#34;&#34;&#34;
        await self.callback(message, **self.kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.server" href="index.html">lib.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.server.mqttprotocol.MqttClientContext" href="#lib.server.mqttprotocol.MqttClientContext">MqttClientContext</a></code></h4>
</li>
<li>
<h4><code><a title="lib.server.mqttprotocol.MqttProtocol" href="#lib.server.mqttprotocol.MqttProtocol">MqttProtocol</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.add_control" href="#lib.server.mqttprotocol.MqttProtocol.add_control">add_control</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.add_topic" href="#lib.server.mqttprotocol.MqttProtocol.add_topic">add_topic</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.call_subscription" href="#lib.server.mqttprotocol.MqttProtocol.call_subscription">call_subscription</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.context" href="#lib.server.mqttprotocol.MqttProtocol.context">context</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.controls" href="#lib.server.mqttprotocol.MqttProtocol.controls">controls</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.disconnect" href="#lib.server.mqttprotocol.MqttProtocol.disconnect">disconnect</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.notify_message" href="#lib.server.mqttprotocol.MqttProtocol.notify_message">notify_message</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.ping_task" href="#lib.server.mqttprotocol.MqttProtocol.ping_task">ping_task</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.publications" href="#lib.server.mqttprotocol.MqttProtocol.publications">publications</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.publish" href="#lib.server.mqttprotocol.MqttProtocol.publish">publish</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.remove_control" href="#lib.server.mqttprotocol.MqttProtocol.remove_control">remove_control</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.remove_topic" href="#lib.server.mqttprotocol.MqttProtocol.remove_topic">remove_topic</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.send" href="#lib.server.mqttprotocol.MqttProtocol.send">send</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.start" href="#lib.server.mqttprotocol.MqttProtocol.start">start</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.subscribe" href="#lib.server.mqttprotocol.MqttProtocol.subscribe">subscribe</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.subscriptions" href="#lib.server.mqttprotocol.MqttProtocol.subscriptions">subscriptions</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttProtocol.unsubscribe" href="#lib.server.mqttprotocol.MqttProtocol.unsubscribe">unsubscribe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqttprotocol.MqttStateMachine" href="#lib.server.mqttprotocol.MqttStateMachine">MqttStateMachine</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.STATE_ACCEPTED" href="#lib.server.mqttprotocol.MqttStateMachine.STATE_ACCEPTED">STATE_ACCEPTED</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.STATE_CLOSE" href="#lib.server.mqttprotocol.MqttStateMachine.STATE_CLOSE">STATE_CLOSE</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.STATE_CONNACK" href="#lib.server.mqttprotocol.MqttStateMachine.STATE_CONNACK">STATE_CONNACK</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.STATE_CONNECT" href="#lib.server.mqttprotocol.MqttStateMachine.STATE_CONNECT">STATE_CONNECT</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.STATE_ESTABLISH" href="#lib.server.mqttprotocol.MqttStateMachine.STATE_ESTABLISH">STATE_ESTABLISH</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.STATE_OPEN" href="#lib.server.mqttprotocol.MqttStateMachine.STATE_OPEN">STATE_OPEN</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.STATE_REFUSED" href="#lib.server.mqttprotocol.MqttStateMachine.STATE_REFUSED">STATE_REFUSED</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.STATE_WAIT" href="#lib.server.mqttprotocol.MqttStateMachine.STATE_WAIT">STATE_WAIT</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_conn_ack" href="#lib.server.mqttprotocol.MqttStateMachine.on_conn_ack">on_conn_ack</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_disconnect" href="#lib.server.mqttprotocol.MqttStateMachine.on_disconnect">on_disconnect</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_ping_req" href="#lib.server.mqttprotocol.MqttStateMachine.on_ping_req">on_ping_req</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_ping_rsp" href="#lib.server.mqttprotocol.MqttStateMachine.on_ping_rsp">on_ping_rsp</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_pub_ack" href="#lib.server.mqttprotocol.MqttStateMachine.on_pub_ack">on_pub_ack</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_pub_comp" href="#lib.server.mqttprotocol.MqttStateMachine.on_pub_comp">on_pub_comp</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_pub_rec" href="#lib.server.mqttprotocol.MqttStateMachine.on_pub_rec">on_pub_rec</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_pub_rel" href="#lib.server.mqttprotocol.MqttStateMachine.on_pub_rel">on_pub_rel</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_publish" href="#lib.server.mqttprotocol.MqttStateMachine.on_publish">on_publish</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_sub_ack" href="#lib.server.mqttprotocol.MqttStateMachine.on_sub_ack">on_sub_ack</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.on_unsub_ack" href="#lib.server.mqttprotocol.MqttStateMachine.on_unsub_ack">on_unsub_ack</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.state_accepted" href="#lib.server.mqttprotocol.MqttStateMachine.state_accepted">state_accepted</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.state_close" href="#lib.server.mqttprotocol.MqttStateMachine.state_close">state_close</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.state_connack" href="#lib.server.mqttprotocol.MqttStateMachine.state_connack">state_connack</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.state_connect" href="#lib.server.mqttprotocol.MqttStateMachine.state_connect">state_connect</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.state_establish" href="#lib.server.mqttprotocol.MqttStateMachine.state_establish">state_establish</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.state_open" href="#lib.server.mqttprotocol.MqttStateMachine.state_open">state_open</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.state_receive" href="#lib.server.mqttprotocol.MqttStateMachine.state_receive">state_receive</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.state_wait" href="#lib.server.mqttprotocol.MqttStateMachine.state_wait">state_wait</a></code></li>
<li><code><a title="lib.server.mqttprotocol.MqttStateMachine.task" href="#lib.server.mqttprotocol.MqttStateMachine.task">task</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqttprotocol.MqttSubscription" href="#lib.server.mqttprotocol.MqttSubscription">MqttSubscription</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqttprotocol.MqttSubscription.call" href="#lib.server.mqttprotocol.MqttSubscription.call">call</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>