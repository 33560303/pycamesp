<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lib.server.mqtt API documentation</title>
<meta name="description" content="Support for mqtt client protocol using asynchronous sockets. Support MQTT 3.11" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.server.mqtt</code></h1>
</header>
<section id="section-intro">
<p>Support for mqtt client protocol using asynchronous sockets. Support MQTT 3.11</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
# pylint:disable=consider-using-f-string
&#34;&#34;&#34; Support for mqtt client protocol using asynchronous sockets. Support MQTT 3.11 &#34;&#34;&#34;
from io import BytesIO
import uasyncio
from wifi import hostname
from server import stream
from tools import logger, strings, tasking

MQTT_UNDEFINED   = 0
MQTT_CONNECT     = 1  # Client to Server                     : Client request to connect to Server
MQTT_CONNACK     = 2  # Server to Client                     : Connect acknowledgment
MQTT_PUBLISH     = 3  # Client to Server or Server to Client : Publish message
MQTT_PUBACK      = 4  # Client to Server or Server to Client : Publish acknowledgment
MQTT_PUBREC      = 5  # Client to Server or Server to Client : Publish received (assured delivery part 1)
MQTT_PUBREL      = 6  # Client to Server or Server to Client : Publish release (assured delivery part 2)
MQTT_PUBCOMP     = 7  # Client to Server or Server to Client : Publish complete (assured delivery part 3)
MQTT_SUBSCRIBE   = 8  # Client to Server                     : Client subscribe request
MQTT_SUBACK      = 9  # Server to Client                     : Subscribe acknowledgment
MQTT_UNSUBSCRIBE = 10 # Client to Server                     : Unsubscribe request
MQTT_UNSUBACK    = 11 # Server to Client                     : Unsubscribe acknowledgment
MQTT_PINGREQ     = 12 # Client to Server                     : PING request
MQTT_PINGRESP    = 13 # Server to Client                     : PING response
MQTT_DISCONNECT  = 14 # Client to Server                     : Client is disconnecting

MQTT_QOS_ONCE         = 0 # At most once delivery
MQTT_QOS_LEAST_ONCE   = 1 # At least once delivery
MQTT_QOS_EXACTLY_ONCE = 2 # Exactly once delivery

MQTT_CONNACK_ACCEPTED              = 0 # Connection Accepted
MQTT_CONNACK_UNACCEPTABLE_PROTOCOL = 1 # Connection refused : The Server does not support the level of the MQTT protocol requested by the Client
MQTT_CONNACK_IDENTIFIER_REJECTED   = 2 # Connection refused : The Client identifier is correct UTF-8 but not allowed by the Server
MQTT_CONNACK_SERVER_UNAVAILABLE    = 3 # Connection refused : The Network Connection has been made but the MQTT service is unavailable
MQTT_CONNACK_BAD_USER              = 4 # Connection refused : Bad user name or password, the data in the user name or password is malformed
MQTT_CONNACK_NOT_AUTHORIZED        = 5 # Connection refused : The Client is not authorized to connect

MQTT_SUBACK_MAX_QOS0 = 0x00 # Success - Maximum QoS 0
MQTT_SUBACK_MAX_QOS1 = 0x01 # Success - Maximum QoS 1
MQTT_SUBACK_MAX_QOS2 = 0x02 # Success - Maximum QoS 2
MQTT_SUBACK_FAILURE  = 0x80 # Failure

class MqttException(Exception):
        &#34;&#34;&#34; Exception for MQTT layer &#34;&#34;&#34;
        def __init__(self, message):
                &#34;&#34;&#34; Exception constructor &#34;&#34;&#34;
                Exception.__init__(self)
                self.message = message

class MqttMessage:
        &#34;&#34;&#34; Selection class of commands received &#34;&#34;&#34;
        messages = {}
        identifier_base = [1]
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor 
                Parameters :
                        control    : type of message (MQTT_CONNECT,MQTT_CONNACK,MQTT_PUBLISH,MQTT_PUBACK,MQTT_PUBREC,MQTT_PUBREL,MQTT_PUBCOMP,MQTT_SUBSCRIBE,MQTT_SUBACK,MQTT_UNSUBSCRIBE,MQTT_UNSUBACK,MQTT_PINGREQ,MQTT_PINGRESP,MQTT_DISCONNECT)
                        qos        : quality of service (MQTT_QOS_ONCE,MQTT_QOS_LEAST_ONCE,MQTT_QOS_EXACTLY_ONCE)
                        retain     : retain message (0 or 1)
                        dup        : duplicate delivery control payload (0 or 1)
                        identifier : packet identifier (1 to 65535)&#34;&#34;&#34;
                if kwargs.get(&#34;header&#34;,None) is None:
                        self.control    = kwargs.get(&#34;control&#34;   ,MQTT_UNDEFINED)
                        self.qos        = kwargs.get(&#34;qos&#34;       ,MQTT_QOS_ONCE)
                        self.dup        = kwargs.get(&#34;dup&#34;       ,0)
                        self.retain     = kwargs.get(&#34;retain&#34;    ,0)
                        self.identifier = kwargs.get(&#34;identifier&#34;,None)
                        if self.identifier is None:
                                self.identifier = MqttMessage.identifier_base[0]
                                MqttMessage.identifier_base[0] += 1
                        self.header = None
                else:
                        self.decode_header(kwargs.get(&#34;header&#34;))
                self.payload = BytesIO()

        @staticmethod
        def init():
                &#34;&#34;&#34; Initialize the message selector &#34;&#34;&#34;
                if len(MqttMessage.messages) == 0:
                        MqttMessage.messages = {\
                                MQTT_CONNECT     : MqttConnect,
                                MQTT_CONNACK     : MqttConnAck,
                                MQTT_PUBLISH     : MqttPublish,
                                MQTT_PUBACK      : MqttPubAck,
                                MQTT_PUBREC      : MqttPubRec,
                                MQTT_PUBREL      : MqttPubRel,
                                MQTT_PUBCOMP     : MqttPubComp,
                                MQTT_SUBSCRIBE   : MqttSubscribe,
                                MQTT_SUBACK      : MqttSubAck,
                                MQTT_UNSUBSCRIBE : MqttUnsubscribe,
                                MQTT_UNSUBACK    : MqttUnSubAck,
                                MQTT_PINGREQ     : MqttPingReq,
                                MQTT_PINGRESP    : MqttPingResp,
                                MQTT_DISCONNECT  : MqttDisconnect,}

        @staticmethod
        async def receive(streamio):
                &#34;&#34;&#34; Wait message and return the message decoded &#34;&#34;&#34;
                MqttMessage.init()
                header = await streamio.read(1)
                if len(header) &gt; 0:
                        control = header[0] &gt;&gt; 4
                        # If message is recognized
                        if control in MqttMessage.messages:
                                # Create the right message
                                result = MqttMessage.messages[control](header=header)
                                await result.read(streamio)
                                return result
                return None

        def decode_header(self, data):
                &#34;&#34;&#34; Decode header &#34;&#34;&#34;
                self.header = data
                self.control = (data[0] &gt;&gt; 4)
                self.qos     = (data[0] &gt;&gt; 1) &amp; 3
                self.dup     = (data[0] &gt;&gt; 3) &amp; 1
                self.retain  = (data[0] &amp; 1)

        def encode_header(self):
                &#34;&#34;&#34; Encode header &#34;&#34;&#34;
                if self.control in [MQTT_CONNECT , MQTT_CONNACK, MQTT_PUBACK,
                        MQTT_PUBREC , MQTT_PUBCOMP , MQTT_SUBACK,  MQTT_UNSUBACK,
                        MQTT_PINGREQ, MQTT_PINGRESP, MQTT_DISCONNECT]:
                        return (self.control &lt;&lt; 4).to_bytes(1, &#34;big&#34;)
                elif self.control in [MQTT_SUBSCRIBE, MQTT_UNSUBSCRIBE, MQTT_PUBREL]:
                        return ((self.control &lt;&lt; 4) | 2).to_bytes(1, &#34;big&#34;)
                elif self.control in [MQTT_PUBLISH]:
                        return ((self.control  &lt;&lt; 4) | ((self.dup &amp; 1) &lt;&lt; 3) | ((self.qos &amp; 3) &lt;&lt; 1) | ((self.retain &amp; 1))).to_bytes(1, &#34;big&#34;)
                else:
                        raise MqttException(&#34;Mqtt control command not supported&#34;)

        async def write_length(self, streamio):
                &#34;&#34;&#34; Write the length of message &#34;&#34;&#34;
                length = len(self.payload.getvalue())
                x = length
                while True:
                        encoded_byte = x % 128
                        x = x &gt;&gt; 7
                        if x &gt; 0:
                                encoded_byte |= 0x80
                        await streamio.write(encoded_byte.to_bytes(1, &#34;big&#34;))
                        if x &lt;= 0:
                                break
                return length

        async def read_length(self, streamio):
                &#34;&#34;&#34; Read the length &#34;&#34;&#34;
                multiplier = 1
                length = 0
                while True:
                        encoded_byte = await streamio.read(1)
                        length += (encoded_byte[0] &amp; 0x7F) * multiplier
                        multiplier *= 128
                        if multiplier &gt; 128*128*128:
                                raise MqttException(&#34;Mqtt malformed remaining length&#34;)
                        if encoded_byte[0] &amp; 0x80 == 0:
                                break
                return length

        async def write(self, streamio):
                &#34;&#34;&#34; Write message &#34;&#34;&#34;
                await streamio.write(self.encode_header())
                self.encode()
                if await self.write_length(streamio) &gt; 0:
                        await streamio.write(self.payload.getvalue())

        async def read(self, streamio):
                &#34;&#34;&#34; Read message &#34;&#34;&#34;
                if self.header is None:
                        self.decode_header(await streamio.read(1))
                length = await self.read_length(streamio)
                if length &gt; 0:
                        self.payload = BytesIO(await streamio.read(length))
                self.decode()

        def put_string(self, data):
                &#34;&#34;&#34; Put the string with its length &#34;&#34;&#34;
                if data is not None:
                        self.put_int(len(data))
                        self.payload.write(strings.tobytes(data))

        def put_int(self, value):
                &#34;&#34;&#34; Put integer on 2 bytes &#34;&#34;&#34;
                self.payload.write(value.to_bytes(2, &#34;big&#34;))

        def put_byte(self, value):
                &#34;&#34;&#34; Put byte integer &#34;&#34;&#34;
                self.payload.write(value.to_bytes(1, &#34;big&#34;))

        def put_buffer(self, value):
                &#34;&#34;&#34; Put binary buffer &#34;&#34;&#34;
                self.payload.write(strings.tobytes(value))

        def get_string(self):
                &#34;&#34;&#34; Get the string with its length &#34;&#34;&#34;
                return strings.tostrings(self.payload.read(self.get_int()))

        def get_int(self):
                &#34;&#34;&#34; Get integer on 2 bytes &#34;&#34;&#34;
                return int.from_bytes(self.payload.read(2), &#34;big&#34;)

        def get_byte(self):
                &#34;&#34;&#34; Put byte integer &#34;&#34;&#34;
                return int.from_bytes(self.payload.read(1), &#34;big&#34;)

        def decode(self):
                &#34;&#34;&#34; Decode message (must redefined)&#34;&#34;&#34;

        def encode(self):
                &#34;&#34;&#34; Encode message (must redefined)&#34;&#34;&#34;

class MqttConnect(MqttMessage):
        &#34;&#34;&#34; Client to Server : Client request to connect to Server &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor 
                Parameters :
                        username      : user name (string)
                        password      : password (string)
                        will_retain   : this bit specifies if the Will Message is to be Retained when it is published (0 or 1)
                        will_qos      : These two bits specify the QoS level to be used when publishing the Will Message (0 or 1)
                        will_flag     : will flag see mqtt specification (0 or 1)
                        clean_session : this bit specifies the handling of the Session state (0 or 1)
                        keep_alive    : the keep alive is a time interval measured in seconds (int)
                        client_id     : the client identifier identifies the client to the server (string)
                &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_CONNECT, **kwargs)
                self.protocol_name  = &#34;MQTT&#34;
                self.protocol_level = 4 # MQTT 3.1.1
                self.username       = kwargs.get(&#34;username&#34;,None)
                self.password       = kwargs.get(&#34;password&#34;,None)
                self.will_retain    = kwargs.get(&#34;will_retain&#34;,False)
                self.will_qos       = kwargs.get(&#34;qos&#34;,MQTT_QOS_ONCE)
                self.will_flag      = kwargs.get(&#34;will_flag&#34;,False)
                self.clean_session  = kwargs.get(&#34;clean_session&#34;,False)
                self.keep_alive     = kwargs.get(&#34;keep_alive&#34;,60)
                self.client_id      = kwargs.get(&#34;client_id&#34;,&#34;%d&#34;%hostname.Hostname().get_number())

        def encode(self):
                &#34;&#34;&#34; Encode the full message &#34;&#34;&#34;
                self.put_string (self.protocol_name)
                self.put_byte   (self.protocol_level)
                self.put_byte   (self.get_flags())
                self.put_int    (self.keep_alive)
                self.put_string (self.client_id)
                self.put_string (self.username)
                self.put_string (self.password)

        def get_flags(self):
                &#34;&#34;&#34; Encode flags &#34;&#34;&#34;
                # pylint:disable=multiple-statements
                result = 0
                if self.username is not None:      result |= 0x80
                if self.password is not None:      result |= 0x40
                if self.will_retain:   result |= 0x20
                if self.will_qos:      result |= ((self.will_qos &lt;&lt; 3) &amp; 0x18)
                if self.will_flag:     result |= 4
                if self.clean_session: result |= 2
                return result

        def decode(self):
                &#34;&#34;&#34; Read content &#34;&#34;&#34;
                self.protocol_name  = self.get_string()
                self.protocol_level = self.get_byte()
                flags = self.get_byte()
                self.will_flag     = (flags &amp; 0x04) &gt;&gt; 2
                self.will_qos      = (flags &amp; 0x18) &gt;&gt; 3
                self.will_retain   = (flags &amp; 0x20) &gt;&gt; 5
                self.clean_session = (flags &amp; 0x01)
                self.keep_alive    = self.get_int()
                self.client_id     = self.get_string()
                if flags &amp; 0x80:
                        self.username  = self.get_string()
                if flags &amp; 0x40:
                        self.password  = self.get_string()

class MqttConnAck(MqttMessage):
        &#34;&#34;&#34; Server to Client : Connect acknowledgment &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor 
                Parameters :
                        return_code : return code (MQTT_CONNACK_ACCEPTED,MQTT_CONNACK_UNACCEPTABLE_PROTOCOL,MQTT_CONNACK_IDENTIFIER_REJECTED,MQTT_CONNACK_SERVER_UNAVAILABLE,MQTT_CONNACK_BAD_USER,MQTT_CONNACK_NOT_AUTHORIZED)
                        session_present_flag :  session present flag (0 or 1)
                &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_CONNACK, **kwargs)
                self.return_code          = kwargs.get(&#34;return_code&#34;,MQTT_CONNACK_ACCEPTED)
                self.session_present_flag = kwargs.get(&#34;session_present_flag&#34;,0)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.session_present_flag = self.get_byte() &amp; 0x01
                self.return_code          = self.get_byte()

        def encode(self):
                &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
                self.put_byte(self.session_present_flag &amp; 0x01)
                self.put_byte(self.return_code)

class MqttPingReq(MqttMessage):
        &#34;&#34;&#34; Client to Server : PING request &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PINGREQ, **kwargs)

class MqttPingResp(MqttMessage):
        &#34;&#34;&#34; Server to Client : PING response &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PINGRESP, **kwargs)

class MqttPublish(MqttMessage):
        &#34;&#34;&#34;Client to Server or Server to Client : Publish message &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor 
                Parameters : 
                        topic : topic name
                        value : topic value &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBLISH, **kwargs)
                self.topic = kwargs.get(&#34;topic&#34;,&#34;&#34;)
                self.value = kwargs.get(&#34;value&#34;,&#34;&#34;)
                self.identifier = 0

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.topic      = self.get_string()
                if self.qos in [MQTT_QOS_LEAST_ONCE, MQTT_QOS_EXACTLY_ONCE]:
                        self.identifier = self.get_int()
                self.value    = self.payload.read()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_string(self.topic)
                if self.qos in [MQTT_QOS_LEAST_ONCE, MQTT_QOS_EXACTLY_ONCE]:
                        self.put_int(self.identifier)
                self.put_buffer(self.value)

class MqttPubAck(MqttMessage):
        &#34;&#34;&#34; Client to Server or Server to Client : Publish acknowledgment &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBACK, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)

class MqttPubRec(MqttMessage):
        &#34;&#34;&#34; Client to Server or Server to Client : Publish received (assured delivery part 1) &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBREC, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)

class MqttPubRel(MqttMessage):
        &#34;&#34;&#34; Client to Server or Server to Client : Publish release (assured delivery part 2) &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBREL, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)

class MqttPubComp(MqttMessage):
        &#34;&#34;&#34; Client to Server or Server to Client : Publish complete (assured delivery part 3) &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBCOMP, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)

class MqttSubscribe(MqttMessage):
        &#34;&#34;&#34; Client to Server : Client subscribe request &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_SUBSCRIBE, **kwargs)
                self.topics = kwargs.get(&#34;topics&#34;,[])

        def add_topic(self, topic, qos=MQTT_QOS_ONCE):
                &#34;&#34;&#34; Add topics into subscribe &#34;&#34;&#34;
                self.topics.append((topic, qos))

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()
                self.topics = []
                while self.payload.tell() &lt; len(self.payload.getvalue()):
                        topic = self.get_string()
                        qos = self.get_byte()
                        self.add_topic(topic, qos)

        def encode(self):
                &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
                self.put_int(self.identifier)
                for topic,qos in self.topics:
                        self.put_string(topic)
                        self.put_byte(qos)

class MqttSubAck(MqttMessage):
        &#34;&#34;&#34; Server to Client : Subscribe acknowledgment &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_SUBACK, **kwargs)
                self.return_code = kwargs.get(&#34;return_code&#34;,[])

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()
                self.return_code = []
                while self.payload.tell() &lt; len(self.payload.getvalue()):
                        self.return_code.append(self.get_byte())

        def encode(self):
                &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
                self.put_int(self.identifier)
                for return_code in self.return_code:
                        self.put_byte(return_code)

class MqttUnsubscribe(MqttMessage):
        &#34;&#34;&#34; Client to Server : Unsubscribe request &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_UNSUBSCRIBE, **kwargs)
                self.topics = kwargs.get(&#34;topics&#34;,[])

        def add_topic(self, topic):
                &#34;&#34;&#34; Add topics into subscribe &#34;&#34;&#34;
                self.topics.append(topic)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()
                self.topics = []
                while self.payload.tell() &lt; len(self.payload.getvalue()):
                        topic = self.get_string()
                        self.add_topic(topic)

        def encode(self):
                &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
                self.put_int(self.identifier)
                for topic,qos in self.topics:
                        self.put_string(topic)

class MqttUnSubAck(MqttMessage):
        &#34;&#34;&#34; Server to Client : Unsubscribe acknowledgment &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_UNSUBACK, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)

class MqttDisconnect(MqttMessage):
        &#34;&#34;&#34; Client to Server : Client is disconnecting &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_DISCONNECT, **kwargs)

class MqttStream(stream.Stream):
        &#34;&#34;&#34; Read and write stream for mqtt &#34;&#34;&#34;
        def __init__(self, reader, writer):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                stream.Stream.__init__(self, reader, writer)

        async def read(self, length):
                &#34;&#34;&#34; Read data from the stream &#34;&#34;&#34;
                return await stream.Stream.read(self, length)

        async def close(self):
                &#34;&#34;&#34; Close the stream &#34;&#34;&#34;
                self.writer.close()
                self.reader.close()

class MqttSubscription:
        &#34;&#34;&#34; Subscription callback caller &#34;&#34;&#34;
        def __init__(self, topic, function, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.topic = topic
                self.kwargs  = kwargs
                self.function = function
                self.qos = kwargs.get(&#34;qos&#34;,MQTT_QOS_ONCE)

        async def call(self, message):
                &#34;&#34;&#34; Call callback registered &#34;&#34;&#34;
                await self.function(message, **self.kwargs)

class MqttClientContext:
        &#34;&#34;&#34; Context of the mqtt client &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.host       = kwargs.get(&#34;host&#34;,&#34;127.0.0.1&#34;)
                self.port       = kwargs.get(&#34;port&#34;,1883)
                self.keep_alive = kwargs.get(&#34;keep_alive&#34;,60)
                if self.keep_alive &lt; 10:
                        self.keep_alive = 10
                self.kwargs     = kwargs
                self.streamio   = None
                self.state = MqttStateMachine.STATE_OPEN
                self.debug      = kwargs.get(&#34;debug&#34;,False)
                self.retry_count= 0

class MqttClient:
        &#34;&#34;&#34; Manages an mqtt client &#34;&#34;&#34;
        subscriptions = {}
        controls = {}
        context = None

        @staticmethod
        def init(**kwargs):
                &#34;&#34;&#34; Start the mqtt client &#34;&#34;&#34;
                MqttClient.context = MqttClientContext(**kwargs)

        @staticmethod
        async def send(command):
                &#34;&#34;&#34; Send command &#34;&#34;&#34;
                if MqttClient.context.debug:
                        print(&#34;Mqtt send    : %s&#34;%command.__class__.__name__)
                await command.write(MqttClient.context.streamio)

        @staticmethod
        async def disconnect():
                &#34;&#34;&#34; Send diconnect message &#34;&#34;&#34;
                if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttClient.send(MqttDisconnect())
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def subscribe(topic, qos=MQTT_QOS_ONCE):
                &#34;&#34;&#34; Subscribe one topic &#34;&#34;&#34;
                command = MqttSubscribe()
                command.add_topic(topic, qos)
                await MqttClient.send(command)

        @staticmethod
        async def subscribe_all():
                &#34;&#34;&#34; Subscribe all topic registed &#34;&#34;&#34;
                if len(MqttClient.subscriptions) &gt; 0:
                        command = MqttSubscribe()
                        for subscription in MqttClient.subscriptions.values():
                                command.add_topic(subscription.topic, subscription.qos)
                        await MqttClient.send(command)

        @staticmethod
        async def ping_task():
                &#34;&#34;&#34; Ping server periodicaly &#34;&#34;&#34;
                if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttClient.send(MqttPingReq())
                        await uasyncio.sleep(MqttClient.context.keep_alive - 5)
                else:
                        await uasyncio.sleep(1)

        @staticmethod
        def add_subscription(topic, **kwargs):
                &#34;&#34;&#34; Add a callback on subscription &#34;&#34;&#34;
                def add_subscription(function):
                        MqttClient.subscriptions[strings.tostrings(topic)] = MqttSubscription(topic, function, **kwargs)
                        return function
                return add_subscription

        @staticmethod
        def remove_subscription(topic):
                &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
                subscription = MqttClient.subscriptions.get(topic, None)
                if subscription:
                        del MqttClient.subscriptions[topic]

        @staticmethod
        async def call_subscription(message):
                &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
                subscription = MqttClient.subscriptions.get(strings.tostrings(message.topic), (None,None,None))
                if subscription is not None:
                        await subscription.call(message)

        @staticmethod
        def add_control(control, **kwargs):
                &#34;&#34;&#34; Add a callback to control payload &#34;&#34;&#34;
                def add_control(function):
                        MqttClient.controls[control] = (function, kwargs)
                        return function
                return add_control

        @staticmethod
        def remove_control(control):
                &#34;&#34;&#34; Remove callback on control payload &#34;&#34;&#34;
                control = MqttClient.controls.get(control, None)
                if control is not None:
                        del MqttClient.controls[control]

class MqttStateMachine:
        &#34;&#34;&#34; Mqtt protocol management state machine &#34;&#34;&#34;  
        STATE_OPEN      = 1
        STATE_CONNECT   = 2
        STATE_CONNACK   = 3
        STATE_ACCEPTED  = 4
        STATE_REFUSED   = 5
        STATE_ESTABLISH = 6
        STATE_CLOSE     = 7
        STATE_WAIT      = 8

        @staticmethod
        async def state_open():
                &#34;&#34;&#34; Open mqtt state open socket &#34;&#34;&#34;
                try:
                        reader,writer = await uasyncio.open_connection(strings.tostrings(MqttClient.context.host), MqttClient.context.port)
                        MqttClient.context.streamio = MqttStream(reader, writer)
                        MqttClient.context.state = MqttStateMachine.STATE_CONNECT
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_connect():
                &#34;&#34;&#34; Open mqtt state send connect &#34;&#34;&#34;
                try:
                        command = MqttConnect(**MqttClient.context.kwargs)
                        command.clean_session = True
                        command.keep_alive = MqttClient.context.keep_alive
                        await MqttClient.send(command)
                        MqttClient.context.retry_count = 0
                        MqttClient.context.state = MqttStateMachine.STATE_CONNACK
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_connack():
                &#34;&#34;&#34; Wait connection acknoledge state &#34;&#34;&#34;
                await MqttStateMachine.state_receive()

        @staticmethod
        async def state_accepted():
                &#34;&#34;&#34; Connection mqtt accepted state &#34;&#34;&#34;
                try:
                        if len(MqttClient.subscriptions) &gt; 0:
                                command = MqttSubscribe()
                                for subscription in MqttClient.subscriptions.values():
                                        command.add_topic(subscription.topic, subscription.qos)
                                await MqttClient.send(command)
                        MqttClient.context.state = MqttStateMachine.STATE_ESTABLISH
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_establish():
                &#34;&#34;&#34; Established mqtt state &#34;&#34;&#34;
                await MqttStateMachine.state_receive()

        @staticmethod
        async def state_receive():
                &#34;&#34;&#34; Wait and treat message &#34;&#34;&#34;
                try:
                        # Read and decode message
                        message = await MqttMessage.receive(MqttClient.context.streamio)

                        # If message decoded with success
                        if message is not None:
                                if MqttClient.context.debug:
                                        print(&#34;Mqtt receive : %s&#34;%message.__class__.__name__)
                                # Search treatment callback
                                callback, kwargs = MqttClient.controls.get(message.control, [None,None])

                                # If callback found
                                if callback:
                                        # Call callback
                                        await callback(message, **kwargs)
                                else:
                                        logger.syslog(&#34;Mqtt callback not found for message=%d&#34;%message.control)
                        else:
                                logger.syslog(&#34;Mqtt lost connection&#34;)
                                MqttClient.context.state = MqttStateMachine.STATE_CLOSE
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_close():
                &#34;&#34;&#34; Close mqtt state &#34;&#34;&#34;
                try:
                        if MqttClient.context.streamio is not None:
                                await MqttClient.context.streamio.close()
                                MqttClient.context.streamio = None
                        MqttClient.context.state = MqttStateMachine.STATE_WAIT
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_WAIT

        @staticmethod
        async def state_wait():
                &#34;&#34;&#34; Wait mqtt state before next reconnection &#34;&#34;&#34;
                await uasyncio.sleep(1)
                display = False
                if   MqttClient.context.retry_count &lt;= 60   and MqttClient.context.retry_count % 15 == 0:
                        display = True
                elif MqttClient.context.retry_count &lt;= 600  and MqttClient.context.retry_count % 60 == 0:
                        display = True
                elif MqttClient.context.retry_count &lt;= 3600 and MqttClient.context.retry_count % 3600 == 0:
                        display = True
                if display:
                        logger.syslog(&#34;Mqtt not connected since %d s&#34;%(MqttClient.context.retry_count))
                MqttClient.context.retry_count += 1
                MqttClient.context.state = MqttStateMachine.STATE_OPEN

        @staticmethod
        @MqttClient.add_control(MQTT_CONNACK)
        async def on_conn_ack(message, **kwargs):
                &#34;&#34;&#34; Conn ack treatment &#34;&#34;&#34;
                if MqttClient.context.state == MqttStateMachine.STATE_CONNACK:
                        if message.return_code == 0:
                                logger.syslog(&#34;Mqtt connected&#34;)
                                MqttClient.context.state = MqttStateMachine.STATE_ACCEPTED
                        else:
                                logger.syslog(&#34;Mqtt connection refused %d&#34;%message.return_code)
                                MqttClient.context.state = MqttStateMachine.STATE_CLOSE
                else:
                        logger.syslog(&#34;Mqtt unexpected connack&#34;)
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttClient.add_control(MQTT_PINGREQ)
        async def on_ping_req(message, **kwargs):
                &#34;&#34;&#34; Ping received &#34;&#34;&#34;
                if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttClient.send(MqttPingResp())
                else:
                        logger.syslog(&#34;Mqtt unexpected pingreq&#34;)
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttClient.add_control(MQTT_PINGRESP)
        async def on_ping_rsp(message, **kwargs):
                &#34;&#34;&#34; Ping response received &#34;&#34;&#34;
                if MqttClient.context.state != MqttStateMachine.STATE_ESTABLISH:
                        logger.syslog(&#34;Mqtt unexpected pingres&#34;)
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttClient.add_control(MQTT_SUBACK)
        async def on_sub_ack(message, **kwargs):
                &#34;&#34;&#34; Subcribe acknoledge &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_PUBACK)
        async def on_pub_ack(message, **kwargs):
                &#34;&#34;&#34; Publish ack received &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_PUBREC)
        async def on_pub_rec(message, **kwargs):
                &#34;&#34;&#34; Publish received &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_PUBREL)
        async def on_pub_rel(message, **kwargs):
                &#34;&#34;&#34; Publish release received &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_PUBCOMP)
        async def on_pub_comp(message, **kwargs):
                &#34;&#34;&#34; Publish complete received &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_UNSUBACK)
        async def on_unsub_ack(message, **kwargs):
                &#34;&#34;&#34; Unsubcribe acknoledge &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_DISCONNECT)
        async def on_disconnect(message, **kwargs):
                &#34;&#34;&#34; Disconnect received &#34;&#34;&#34;
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttClient.add_control(MQTT_PUBLISH)
        async def on_publish(message, **kwargs):
                &#34;&#34;&#34; Published message &#34;&#34;&#34;
                if MqttClient.context.debug:
                        print(&#34;Mqtt publish topic &#39;%s&#39;, value=&#39;%s&#39;&#34;%(message.topic, message.value))
                if message.qos == MQTT_QOS_ONCE:
                        pass
                elif message.qos == MQTT_QOS_LEAST_ONCE:
                        await MqttClient.send(MqttPubAck(identifier=message.identifier))
                elif message.qos == MQTT_QOS_EXACTLY_ONCE:
                        await MqttClient.send(MqttPubRec(identifier=message.identifier))
                await MqttClient.call_subscription(message)

        @staticmethod
        async def client_task():
                &#34;&#34;&#34; Manages mqtt commands received and returns responses &#34;&#34;&#34;
                try:
                        states = {
                                MqttStateMachine.STATE_OPEN      : (&#34;OPEN&#34;,      MqttStateMachine.state_open),
                                MqttStateMachine.STATE_CONNECT   : (&#34;CONNECT&#34;,   MqttStateMachine.state_connect),
                                MqttStateMachine.STATE_CONNACK   : (&#34;CONNACK&#34;,   MqttStateMachine.state_connack),
                                MqttStateMachine.STATE_ACCEPTED  : (&#34;ACCEPTED&#34;,  MqttStateMachine.state_accepted),
                                MqttStateMachine.STATE_ESTABLISH : (&#34;ESTABLISH&#34;, MqttStateMachine.state_establish),
                                MqttStateMachine.STATE_CLOSE     : (&#34;CLOSE&#34;,     MqttStateMachine.state_close),
                                MqttStateMachine.STATE_WAIT      : (&#34;WAIT&#34;,      MqttStateMachine.state_wait)
                        }
                        previous_state_name = &#34;&#34;
                        while True:
                                state_name, callback = states.get(MqttClient.context.state, (None,None))
                                if previous_state_name != state_name:
                                        if MqttClient.context.debug:
                                                print(&#34;Mqtt state   : %s&#34;%state_name)
                                        previous_state_name = state_name
                                if callback is not None:
                                        await callback()
                                else:
                                        raise MqttException(&#34;Mqtt illegal state&#34;)
                except Exception as err:
                        logger.syslog(err)
                finally:
                        await MqttStateMachine.state_close()

async def mqtt_client_task(**kwargs):
        &#34;&#34;&#34; Mqtt task &#34;&#34;&#34;
        MqttClient.init(**kwargs)
        await tasking.task_monitoring(MqttStateMachine.client_task)

async def mqtt_ping_task():
        &#34;&#34;&#34; Mqtt ping task &#34;&#34;&#34;
        await tasking.task_monitoring(MqttClient.ping_task)

def start(loop, **kwargs):
        &#34;&#34;&#34; Start mqtt client.
        
        Parameters :
                loop       : asynchronous loop
                host       : mqtt broker ip address (string)
                port       : mqtt broker port (int)
                keep_alive : the keep alive is a time interval measured in seconds (int)
                username   : user name (string)
                password   : password (string)
                debug      : True for see debug information (bool)
        &#34;&#34;&#34;
        loop.create_task(mqtt_client_task(**kwargs))
        loop.create_task(mqtt_ping_task())

def mqtt_test(loop, **kwargs):
        &#34;&#34;&#34; Sample mqtt test code
        Parameters :
                loop       : asynchronous loop
                host       : mqtt broker ip address (string)
                port       : mqtt broker port (int)
                keep_alive : the keep alive is a time interval measured in seconds (int)
                username   : user name (string)
                password   : password (string)
                debug      : True for see debug information (bool)
        
        Example :
                mqtt_test(loop, host=&#34;192.168.1.28&#34;, port=1883, keep_alive=120, username=&#34;username&#34;, password=&#34;password&#34;, debug=True)
        &#34;&#34;&#34;
        @MqttClient.add_subscription(&#39;testtopic&#39;)
        async def on_topic(message, **kwargs):
                &#34;&#34;&#34; Example of the mqtt subscription
                to test publish : 
                    mosquitto_pub -h 192.168.1.28 -p 1883 -t testtopic -u username -P password -q 2 -m &#34;my test topic&#34; &#34;&#34;&#34;
                print(&#34;on_topic called  %s&#34;%strings.tostrings(message.value))

        @MqttClient.add_subscription(&#39;forward_message&#39;)
        async def on_forward_message(message, **kwargs):
                &#34;&#34;&#34;Example of the mqtt subscription with emission of a message
                To test subscribe :
                   mosquitto_sub -h 192.168.1.28 -p 1883 -t receive_message -u username -P password
                To test publish :
                   mosquitto_pub -h 192.168.1.28 -p 1883 -t forward_message -u username -P password -q 2 -m &#34;Hello world&#34; &#34;&#34;&#34;
                print(&#34;on_forward_message  %s&#34;%strings.tostrings(message.value))
                await MqttClient.send(MqttPublish(topic=&#34;receive_message&#34;, value=message.value))

        # Example to open mqtt client
        start(loop, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lib.server.mqtt.mqtt_client_task"><code class="name flex">
<span>async def <span class="ident">mqtt_client_task</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mqtt task</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def mqtt_client_task(**kwargs):
        &#34;&#34;&#34; Mqtt task &#34;&#34;&#34;
        MqttClient.init(**kwargs)
        await tasking.task_monitoring(MqttStateMachine.client_task)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.mqtt_ping_task"><code class="name flex">
<span>async def <span class="ident">mqtt_ping_task</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mqtt ping task</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def mqtt_ping_task():
        &#34;&#34;&#34; Mqtt ping task &#34;&#34;&#34;
        await tasking.task_monitoring(MqttClient.ping_task)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.mqtt_test"><code class="name flex">
<span>def <span class="ident">mqtt_test</span></span>(<span>loop, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample mqtt test code
Parameters :
loop
: asynchronous loop
host
: mqtt broker ip address (string)
port
: mqtt broker port (int)
keep_alive : the keep alive is a time interval measured in seconds (int)
username
: user name (string)
password
: password (string)
debug
: True for see debug information (bool)</p>
<p>Example :
mqtt_test(loop, host="192.168.1.28", port=1883, keep_alive=120, username="username", password="password", debug=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mqtt_test(loop, **kwargs):
        &#34;&#34;&#34; Sample mqtt test code
        Parameters :
                loop       : asynchronous loop
                host       : mqtt broker ip address (string)
                port       : mqtt broker port (int)
                keep_alive : the keep alive is a time interval measured in seconds (int)
                username   : user name (string)
                password   : password (string)
                debug      : True for see debug information (bool)
        
        Example :
                mqtt_test(loop, host=&#34;192.168.1.28&#34;, port=1883, keep_alive=120, username=&#34;username&#34;, password=&#34;password&#34;, debug=True)
        &#34;&#34;&#34;
        @MqttClient.add_subscription(&#39;testtopic&#39;)
        async def on_topic(message, **kwargs):
                &#34;&#34;&#34; Example of the mqtt subscription
                to test publish : 
                    mosquitto_pub -h 192.168.1.28 -p 1883 -t testtopic -u username -P password -q 2 -m &#34;my test topic&#34; &#34;&#34;&#34;
                print(&#34;on_topic called  %s&#34;%strings.tostrings(message.value))

        @MqttClient.add_subscription(&#39;forward_message&#39;)
        async def on_forward_message(message, **kwargs):
                &#34;&#34;&#34;Example of the mqtt subscription with emission of a message
                To test subscribe :
                   mosquitto_sub -h 192.168.1.28 -p 1883 -t receive_message -u username -P password
                To test publish :
                   mosquitto_pub -h 192.168.1.28 -p 1883 -t forward_message -u username -P password -q 2 -m &#34;Hello world&#34; &#34;&#34;&#34;
                print(&#34;on_forward_message  %s&#34;%strings.tostrings(message.value))
                await MqttClient.send(MqttPublish(topic=&#34;receive_message&#34;, value=message.value))

        # Example to open mqtt client
        start(loop, **kwargs)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>loop, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Start mqtt client.</p>
<p>Parameters :
loop
: asynchronous loop
host
: mqtt broker ip address (string)
port
: mqtt broker port (int)
keep_alive : the keep alive is a time interval measured in seconds (int)
username
: user name (string)
password
: password (string)
debug
: True for see debug information (bool)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(loop, **kwargs):
        &#34;&#34;&#34; Start mqtt client.
        
        Parameters :
                loop       : asynchronous loop
                host       : mqtt broker ip address (string)
                port       : mqtt broker port (int)
                keep_alive : the keep alive is a time interval measured in seconds (int)
                username   : user name (string)
                password   : password (string)
                debug      : True for see debug information (bool)
        &#34;&#34;&#34;
        loop.create_task(mqtt_client_task(**kwargs))
        loop.create_task(mqtt_ping_task())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.server.mqtt.MqttClient"><code class="flex name class">
<span>class <span class="ident">MqttClient</span></span>
</code></dt>
<dd>
<div class="desc"><p>Manages an mqtt client</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttClient:
        &#34;&#34;&#34; Manages an mqtt client &#34;&#34;&#34;
        subscriptions = {}
        controls = {}
        context = None

        @staticmethod
        def init(**kwargs):
                &#34;&#34;&#34; Start the mqtt client &#34;&#34;&#34;
                MqttClient.context = MqttClientContext(**kwargs)

        @staticmethod
        async def send(command):
                &#34;&#34;&#34; Send command &#34;&#34;&#34;
                if MqttClient.context.debug:
                        print(&#34;Mqtt send    : %s&#34;%command.__class__.__name__)
                await command.write(MqttClient.context.streamio)

        @staticmethod
        async def disconnect():
                &#34;&#34;&#34; Send diconnect message &#34;&#34;&#34;
                if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttClient.send(MqttDisconnect())
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def subscribe(topic, qos=MQTT_QOS_ONCE):
                &#34;&#34;&#34; Subscribe one topic &#34;&#34;&#34;
                command = MqttSubscribe()
                command.add_topic(topic, qos)
                await MqttClient.send(command)

        @staticmethod
        async def subscribe_all():
                &#34;&#34;&#34; Subscribe all topic registed &#34;&#34;&#34;
                if len(MqttClient.subscriptions) &gt; 0:
                        command = MqttSubscribe()
                        for subscription in MqttClient.subscriptions.values():
                                command.add_topic(subscription.topic, subscription.qos)
                        await MqttClient.send(command)

        @staticmethod
        async def ping_task():
                &#34;&#34;&#34; Ping server periodicaly &#34;&#34;&#34;
                if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttClient.send(MqttPingReq())
                        await uasyncio.sleep(MqttClient.context.keep_alive - 5)
                else:
                        await uasyncio.sleep(1)

        @staticmethod
        def add_subscription(topic, **kwargs):
                &#34;&#34;&#34; Add a callback on subscription &#34;&#34;&#34;
                def add_subscription(function):
                        MqttClient.subscriptions[strings.tostrings(topic)] = MqttSubscription(topic, function, **kwargs)
                        return function
                return add_subscription

        @staticmethod
        def remove_subscription(topic):
                &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
                subscription = MqttClient.subscriptions.get(topic, None)
                if subscription:
                        del MqttClient.subscriptions[topic]

        @staticmethod
        async def call_subscription(message):
                &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
                subscription = MqttClient.subscriptions.get(strings.tostrings(message.topic), (None,None,None))
                if subscription is not None:
                        await subscription.call(message)

        @staticmethod
        def add_control(control, **kwargs):
                &#34;&#34;&#34; Add a callback to control payload &#34;&#34;&#34;
                def add_control(function):
                        MqttClient.controls[control] = (function, kwargs)
                        return function
                return add_control

        @staticmethod
        def remove_control(control):
                &#34;&#34;&#34; Remove callback on control payload &#34;&#34;&#34;
                control = MqttClient.controls.get(control, None)
                if control is not None:
                        del MqttClient.controls[control]</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.server.mqtt.MqttClient.context"><code class="name">var <span class="ident">context</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttClient.controls"><code class="name">var <span class="ident">controls</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttClient.subscriptions"><code class="name">var <span class="ident">subscriptions</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttClient.add_control"><code class="name flex">
<span>def <span class="ident">add_control</span></span>(<span>control, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a callback to control payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_control(control, **kwargs):
        &#34;&#34;&#34; Add a callback to control payload &#34;&#34;&#34;
        def add_control(function):
                MqttClient.controls[control] = (function, kwargs)
                return function
        return add_control</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.add_subscription"><code class="name flex">
<span>def <span class="ident">add_subscription</span></span>(<span>topic, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a callback on subscription</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_subscription(topic, **kwargs):
        &#34;&#34;&#34; Add a callback on subscription &#34;&#34;&#34;
        def add_subscription(function):
                MqttClient.subscriptions[strings.tostrings(topic)] = MqttSubscription(topic, function, **kwargs)
                return function
        return add_subscription</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.call_subscription"><code class="name flex">
<span>async def <span class="ident">call_subscription</span></span>(<span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove callback on subscription</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def call_subscription(message):
        &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
        subscription = MqttClient.subscriptions.get(strings.tostrings(message.topic), (None,None,None))
        if subscription is not None:
                await subscription.call(message)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.disconnect"><code class="name flex">
<span>async def <span class="ident">disconnect</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Send diconnect message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def disconnect():
        &#34;&#34;&#34; Send diconnect message &#34;&#34;&#34;
        if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                await MqttClient.send(MqttDisconnect())
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the mqtt client</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def init(**kwargs):
        &#34;&#34;&#34; Start the mqtt client &#34;&#34;&#34;
        MqttClient.context = MqttClientContext(**kwargs)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.ping_task"><code class="name flex">
<span>async def <span class="ident">ping_task</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Ping server periodicaly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def ping_task():
        &#34;&#34;&#34; Ping server periodicaly &#34;&#34;&#34;
        if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                await MqttClient.send(MqttPingReq())
                await uasyncio.sleep(MqttClient.context.keep_alive - 5)
        else:
                await uasyncio.sleep(1)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.remove_control"><code class="name flex">
<span>def <span class="ident">remove_control</span></span>(<span>control)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove callback on control payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_control(control):
        &#34;&#34;&#34; Remove callback on control payload &#34;&#34;&#34;
        control = MqttClient.controls.get(control, None)
        if control is not None:
                del MqttClient.controls[control]</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.remove_subscription"><code class="name flex">
<span>def <span class="ident">remove_subscription</span></span>(<span>topic)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove callback on subscription</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_subscription(topic):
        &#34;&#34;&#34; Remove callback on subscription &#34;&#34;&#34;
        subscription = MqttClient.subscriptions.get(topic, None)
        if subscription:
                del MqttClient.subscriptions[topic]</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>command)</span>
</code></dt>
<dd>
<div class="desc"><p>Send command</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def send(command):
        &#34;&#34;&#34; Send command &#34;&#34;&#34;
        if MqttClient.context.debug:
                print(&#34;Mqtt send    : %s&#34;%command.__class__.__name__)
        await command.write(MqttClient.context.streamio)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.subscribe"><code class="name flex">
<span>async def <span class="ident">subscribe</span></span>(<span>topic, qos=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Subscribe one topic</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def subscribe(topic, qos=MQTT_QOS_ONCE):
        &#34;&#34;&#34; Subscribe one topic &#34;&#34;&#34;
        command = MqttSubscribe()
        command.add_topic(topic, qos)
        await MqttClient.send(command)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttClient.subscribe_all"><code class="name flex">
<span>async def <span class="ident">subscribe_all</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Subscribe all topic registed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def subscribe_all():
        &#34;&#34;&#34; Subscribe all topic registed &#34;&#34;&#34;
        if len(MqttClient.subscriptions) &gt; 0:
                command = MqttSubscribe()
                for subscription in MqttClient.subscriptions.values():
                        command.add_topic(subscription.topic, subscription.qos)
                await MqttClient.send(command)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.mqtt.MqttClientContext"><code class="flex name class">
<span>class <span class="ident">MqttClientContext</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Context of the mqtt client </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttClientContext:
        &#34;&#34;&#34; Context of the mqtt client &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.host       = kwargs.get(&#34;host&#34;,&#34;127.0.0.1&#34;)
                self.port       = kwargs.get(&#34;port&#34;,1883)
                self.keep_alive = kwargs.get(&#34;keep_alive&#34;,60)
                if self.keep_alive &lt; 10:
                        self.keep_alive = 10
                self.kwargs     = kwargs
                self.streamio   = None
                self.state = MqttStateMachine.STATE_OPEN
                self.debug      = kwargs.get(&#34;debug&#34;,False)
                self.retry_count= 0</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttConnAck"><code class="flex name class">
<span>class <span class="ident">MqttConnAck</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Server to Client : Connect acknowledgment </p>
<p>Constructor
Parameters :
return_code : return code (MQTT_CONNACK_ACCEPTED,MQTT_CONNACK_UNACCEPTABLE_PROTOCOL,MQTT_CONNACK_IDENTIFIER_REJECTED,MQTT_CONNACK_SERVER_UNAVAILABLE,MQTT_CONNACK_BAD_USER,MQTT_CONNACK_NOT_AUTHORIZED)
session_present_flag :
session present flag (0 or 1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttConnAck(MqttMessage):
        &#34;&#34;&#34; Server to Client : Connect acknowledgment &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor 
                Parameters :
                        return_code : return code (MQTT_CONNACK_ACCEPTED,MQTT_CONNACK_UNACCEPTABLE_PROTOCOL,MQTT_CONNACK_IDENTIFIER_REJECTED,MQTT_CONNACK_SERVER_UNAVAILABLE,MQTT_CONNACK_BAD_USER,MQTT_CONNACK_NOT_AUTHORIZED)
                        session_present_flag :  session present flag (0 or 1)
                &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_CONNACK, **kwargs)
                self.return_code          = kwargs.get(&#34;return_code&#34;,MQTT_CONNACK_ACCEPTED)
                self.session_present_flag = kwargs.get(&#34;session_present_flag&#34;,0)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.session_present_flag = self.get_byte() &amp; 0x01
                self.return_code          = self.get_byte()

        def encode(self):
                &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
                self.put_byte(self.session_present_flag &amp; 0x01)
                self.put_byte(self.return_code)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttConnAck.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.session_present_flag = self.get_byte() &amp; 0x01
        self.return_code          = self.get_byte()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttConnAck.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
        self.put_byte(self.session_present_flag &amp; 0x01)
        self.put_byte(self.return_code)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttConnect"><code class="flex name class">
<span>class <span class="ident">MqttConnect</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server : Client request to connect to Server </p>
<p>Constructor
Parameters :
username
: user name (string)
password
: password (string)
will_retain
: this bit specifies if the Will Message is to be Retained when it is published (0 or 1)
will_qos
: These two bits specify the QoS level to be used when publishing the Will Message (0 or 1)
will_flag
: will flag see mqtt specification (0 or 1)
clean_session : this bit specifies the handling of the Session state (0 or 1)
keep_alive
: the keep alive is a time interval measured in seconds (int)
client_id
: the client identifier identifies the client to the server (string)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttConnect(MqttMessage):
        &#34;&#34;&#34; Client to Server : Client request to connect to Server &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor 
                Parameters :
                        username      : user name (string)
                        password      : password (string)
                        will_retain   : this bit specifies if the Will Message is to be Retained when it is published (0 or 1)
                        will_qos      : These two bits specify the QoS level to be used when publishing the Will Message (0 or 1)
                        will_flag     : will flag see mqtt specification (0 or 1)
                        clean_session : this bit specifies the handling of the Session state (0 or 1)
                        keep_alive    : the keep alive is a time interval measured in seconds (int)
                        client_id     : the client identifier identifies the client to the server (string)
                &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_CONNECT, **kwargs)
                self.protocol_name  = &#34;MQTT&#34;
                self.protocol_level = 4 # MQTT 3.1.1
                self.username       = kwargs.get(&#34;username&#34;,None)
                self.password       = kwargs.get(&#34;password&#34;,None)
                self.will_retain    = kwargs.get(&#34;will_retain&#34;,False)
                self.will_qos       = kwargs.get(&#34;qos&#34;,MQTT_QOS_ONCE)
                self.will_flag      = kwargs.get(&#34;will_flag&#34;,False)
                self.clean_session  = kwargs.get(&#34;clean_session&#34;,False)
                self.keep_alive     = kwargs.get(&#34;keep_alive&#34;,60)
                self.client_id      = kwargs.get(&#34;client_id&#34;,&#34;%d&#34;%hostname.Hostname().get_number())

        def encode(self):
                &#34;&#34;&#34; Encode the full message &#34;&#34;&#34;
                self.put_string (self.protocol_name)
                self.put_byte   (self.protocol_level)
                self.put_byte   (self.get_flags())
                self.put_int    (self.keep_alive)
                self.put_string (self.client_id)
                self.put_string (self.username)
                self.put_string (self.password)

        def get_flags(self):
                &#34;&#34;&#34; Encode flags &#34;&#34;&#34;
                # pylint:disable=multiple-statements
                result = 0
                if self.username is not None:      result |= 0x80
                if self.password is not None:      result |= 0x40
                if self.will_retain:   result |= 0x20
                if self.will_qos:      result |= ((self.will_qos &lt;&lt; 3) &amp; 0x18)
                if self.will_flag:     result |= 4
                if self.clean_session: result |= 2
                return result

        def decode(self):
                &#34;&#34;&#34; Read content &#34;&#34;&#34;
                self.protocol_name  = self.get_string()
                self.protocol_level = self.get_byte()
                flags = self.get_byte()
                self.will_flag     = (flags &amp; 0x04) &gt;&gt; 2
                self.will_qos      = (flags &amp; 0x18) &gt;&gt; 3
                self.will_retain   = (flags &amp; 0x20) &gt;&gt; 5
                self.clean_session = (flags &amp; 0x01)
                self.keep_alive    = self.get_int()
                self.client_id     = self.get_string()
                if flags &amp; 0x80:
                        self.username  = self.get_string()
                if flags &amp; 0x40:
                        self.password  = self.get_string()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttConnect.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Read content</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Read content &#34;&#34;&#34;
        self.protocol_name  = self.get_string()
        self.protocol_level = self.get_byte()
        flags = self.get_byte()
        self.will_flag     = (flags &amp; 0x04) &gt;&gt; 2
        self.will_qos      = (flags &amp; 0x18) &gt;&gt; 3
        self.will_retain   = (flags &amp; 0x20) &gt;&gt; 5
        self.clean_session = (flags &amp; 0x01)
        self.keep_alive    = self.get_int()
        self.client_id     = self.get_string()
        if flags &amp; 0x80:
                self.username  = self.get_string()
        if flags &amp; 0x40:
                self.password  = self.get_string()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttConnect.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the full message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode the full message &#34;&#34;&#34;
        self.put_string (self.protocol_name)
        self.put_byte   (self.protocol_level)
        self.put_byte   (self.get_flags())
        self.put_int    (self.keep_alive)
        self.put_string (self.client_id)
        self.put_string (self.username)
        self.put_string (self.password)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttConnect.get_flags"><code class="name flex">
<span>def <span class="ident">get_flags</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode flags</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_flags(self):
        &#34;&#34;&#34; Encode flags &#34;&#34;&#34;
        # pylint:disable=multiple-statements
        result = 0
        if self.username is not None:      result |= 0x80
        if self.password is not None:      result |= 0x40
        if self.will_retain:   result |= 0x20
        if self.will_qos:      result |= ((self.will_qos &lt;&lt; 3) &amp; 0x18)
        if self.will_flag:     result |= 4
        if self.clean_session: result |= 2
        return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttDisconnect"><code class="flex name class">
<span>class <span class="ident">MqttDisconnect</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server : Client is disconnecting </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttDisconnect(MqttMessage):
        &#34;&#34;&#34; Client to Server : Client is disconnecting &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_DISCONNECT, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode" href="#lib.server.mqtt.MqttMessage.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode" href="#lib.server.mqtt.MqttMessage.encode">encode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttException"><code class="flex name class">
<span>class <span class="ident">MqttException</span></span>
<span>(</span><span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception for MQTT layer </p>
<p>Exception constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttException(Exception):
        &#34;&#34;&#34; Exception for MQTT layer &#34;&#34;&#34;
        def __init__(self, message):
                &#34;&#34;&#34; Exception constructor &#34;&#34;&#34;
                Exception.__init__(self)
                self.message = message</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttMessage"><code class="flex name class">
<span>class <span class="ident">MqttMessage</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Selection class of commands received </p>
<p>Constructor
Parameters :
control
: type of message (MQTT_CONNECT,MQTT_CONNACK,MQTT_PUBLISH,MQTT_PUBACK,MQTT_PUBREC,MQTT_PUBREL,MQTT_PUBCOMP,MQTT_SUBSCRIBE,MQTT_SUBACK,MQTT_UNSUBSCRIBE,MQTT_UNSUBACK,MQTT_PINGREQ,MQTT_PINGRESP,MQTT_DISCONNECT)
qos
: quality of service (MQTT_QOS_ONCE,MQTT_QOS_LEAST_ONCE,MQTT_QOS_EXACTLY_ONCE)
retain
: retain message (0 or 1)
dup
: duplicate delivery control payload (0 or 1)
identifier : packet identifier (1 to 65535)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttMessage:
        &#34;&#34;&#34; Selection class of commands received &#34;&#34;&#34;
        messages = {}
        identifier_base = [1]
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor 
                Parameters :
                        control    : type of message (MQTT_CONNECT,MQTT_CONNACK,MQTT_PUBLISH,MQTT_PUBACK,MQTT_PUBREC,MQTT_PUBREL,MQTT_PUBCOMP,MQTT_SUBSCRIBE,MQTT_SUBACK,MQTT_UNSUBSCRIBE,MQTT_UNSUBACK,MQTT_PINGREQ,MQTT_PINGRESP,MQTT_DISCONNECT)
                        qos        : quality of service (MQTT_QOS_ONCE,MQTT_QOS_LEAST_ONCE,MQTT_QOS_EXACTLY_ONCE)
                        retain     : retain message (0 or 1)
                        dup        : duplicate delivery control payload (0 or 1)
                        identifier : packet identifier (1 to 65535)&#34;&#34;&#34;
                if kwargs.get(&#34;header&#34;,None) is None:
                        self.control    = kwargs.get(&#34;control&#34;   ,MQTT_UNDEFINED)
                        self.qos        = kwargs.get(&#34;qos&#34;       ,MQTT_QOS_ONCE)
                        self.dup        = kwargs.get(&#34;dup&#34;       ,0)
                        self.retain     = kwargs.get(&#34;retain&#34;    ,0)
                        self.identifier = kwargs.get(&#34;identifier&#34;,None)
                        if self.identifier is None:
                                self.identifier = MqttMessage.identifier_base[0]
                                MqttMessage.identifier_base[0] += 1
                        self.header = None
                else:
                        self.decode_header(kwargs.get(&#34;header&#34;))
                self.payload = BytesIO()

        @staticmethod
        def init():
                &#34;&#34;&#34; Initialize the message selector &#34;&#34;&#34;
                if len(MqttMessage.messages) == 0:
                        MqttMessage.messages = {\
                                MQTT_CONNECT     : MqttConnect,
                                MQTT_CONNACK     : MqttConnAck,
                                MQTT_PUBLISH     : MqttPublish,
                                MQTT_PUBACK      : MqttPubAck,
                                MQTT_PUBREC      : MqttPubRec,
                                MQTT_PUBREL      : MqttPubRel,
                                MQTT_PUBCOMP     : MqttPubComp,
                                MQTT_SUBSCRIBE   : MqttSubscribe,
                                MQTT_SUBACK      : MqttSubAck,
                                MQTT_UNSUBSCRIBE : MqttUnsubscribe,
                                MQTT_UNSUBACK    : MqttUnSubAck,
                                MQTT_PINGREQ     : MqttPingReq,
                                MQTT_PINGRESP    : MqttPingResp,
                                MQTT_DISCONNECT  : MqttDisconnect,}

        @staticmethod
        async def receive(streamio):
                &#34;&#34;&#34; Wait message and return the message decoded &#34;&#34;&#34;
                MqttMessage.init()
                header = await streamio.read(1)
                if len(header) &gt; 0:
                        control = header[0] &gt;&gt; 4
                        # If message is recognized
                        if control in MqttMessage.messages:
                                # Create the right message
                                result = MqttMessage.messages[control](header=header)
                                await result.read(streamio)
                                return result
                return None

        def decode_header(self, data):
                &#34;&#34;&#34; Decode header &#34;&#34;&#34;
                self.header = data
                self.control = (data[0] &gt;&gt; 4)
                self.qos     = (data[0] &gt;&gt; 1) &amp; 3
                self.dup     = (data[0] &gt;&gt; 3) &amp; 1
                self.retain  = (data[0] &amp; 1)

        def encode_header(self):
                &#34;&#34;&#34; Encode header &#34;&#34;&#34;
                if self.control in [MQTT_CONNECT , MQTT_CONNACK, MQTT_PUBACK,
                        MQTT_PUBREC , MQTT_PUBCOMP , MQTT_SUBACK,  MQTT_UNSUBACK,
                        MQTT_PINGREQ, MQTT_PINGRESP, MQTT_DISCONNECT]:
                        return (self.control &lt;&lt; 4).to_bytes(1, &#34;big&#34;)
                elif self.control in [MQTT_SUBSCRIBE, MQTT_UNSUBSCRIBE, MQTT_PUBREL]:
                        return ((self.control &lt;&lt; 4) | 2).to_bytes(1, &#34;big&#34;)
                elif self.control in [MQTT_PUBLISH]:
                        return ((self.control  &lt;&lt; 4) | ((self.dup &amp; 1) &lt;&lt; 3) | ((self.qos &amp; 3) &lt;&lt; 1) | ((self.retain &amp; 1))).to_bytes(1, &#34;big&#34;)
                else:
                        raise MqttException(&#34;Mqtt control command not supported&#34;)

        async def write_length(self, streamio):
                &#34;&#34;&#34; Write the length of message &#34;&#34;&#34;
                length = len(self.payload.getvalue())
                x = length
                while True:
                        encoded_byte = x % 128
                        x = x &gt;&gt; 7
                        if x &gt; 0:
                                encoded_byte |= 0x80
                        await streamio.write(encoded_byte.to_bytes(1, &#34;big&#34;))
                        if x &lt;= 0:
                                break
                return length

        async def read_length(self, streamio):
                &#34;&#34;&#34; Read the length &#34;&#34;&#34;
                multiplier = 1
                length = 0
                while True:
                        encoded_byte = await streamio.read(1)
                        length += (encoded_byte[0] &amp; 0x7F) * multiplier
                        multiplier *= 128
                        if multiplier &gt; 128*128*128:
                                raise MqttException(&#34;Mqtt malformed remaining length&#34;)
                        if encoded_byte[0] &amp; 0x80 == 0:
                                break
                return length

        async def write(self, streamio):
                &#34;&#34;&#34; Write message &#34;&#34;&#34;
                await streamio.write(self.encode_header())
                self.encode()
                if await self.write_length(streamio) &gt; 0:
                        await streamio.write(self.payload.getvalue())

        async def read(self, streamio):
                &#34;&#34;&#34; Read message &#34;&#34;&#34;
                if self.header is None:
                        self.decode_header(await streamio.read(1))
                length = await self.read_length(streamio)
                if length &gt; 0:
                        self.payload = BytesIO(await streamio.read(length))
                self.decode()

        def put_string(self, data):
                &#34;&#34;&#34; Put the string with its length &#34;&#34;&#34;
                if data is not None:
                        self.put_int(len(data))
                        self.payload.write(strings.tobytes(data))

        def put_int(self, value):
                &#34;&#34;&#34; Put integer on 2 bytes &#34;&#34;&#34;
                self.payload.write(value.to_bytes(2, &#34;big&#34;))

        def put_byte(self, value):
                &#34;&#34;&#34; Put byte integer &#34;&#34;&#34;
                self.payload.write(value.to_bytes(1, &#34;big&#34;))

        def put_buffer(self, value):
                &#34;&#34;&#34; Put binary buffer &#34;&#34;&#34;
                self.payload.write(strings.tobytes(value))

        def get_string(self):
                &#34;&#34;&#34; Get the string with its length &#34;&#34;&#34;
                return strings.tostrings(self.payload.read(self.get_int()))

        def get_int(self):
                &#34;&#34;&#34; Get integer on 2 bytes &#34;&#34;&#34;
                return int.from_bytes(self.payload.read(2), &#34;big&#34;)

        def get_byte(self):
                &#34;&#34;&#34; Put byte integer &#34;&#34;&#34;
                return int.from_bytes(self.payload.read(1), &#34;big&#34;)

        def decode(self):
                &#34;&#34;&#34; Decode message (must redefined)&#34;&#34;&#34;

        def encode(self):
                &#34;&#34;&#34; Encode message (must redefined)&#34;&#34;&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttConnAck" href="#lib.server.mqtt.MqttConnAck">MqttConnAck</a></li>
<li><a title="lib.server.mqtt.MqttConnect" href="#lib.server.mqtt.MqttConnect">MqttConnect</a></li>
<li><a title="lib.server.mqtt.MqttDisconnect" href="#lib.server.mqtt.MqttDisconnect">MqttDisconnect</a></li>
<li><a title="lib.server.mqtt.MqttPingReq" href="#lib.server.mqtt.MqttPingReq">MqttPingReq</a></li>
<li><a title="lib.server.mqtt.MqttPingResp" href="#lib.server.mqtt.MqttPingResp">MqttPingResp</a></li>
<li><a title="lib.server.mqtt.MqttPubAck" href="#lib.server.mqtt.MqttPubAck">MqttPubAck</a></li>
<li><a title="lib.server.mqtt.MqttPubComp" href="#lib.server.mqtt.MqttPubComp">MqttPubComp</a></li>
<li><a title="lib.server.mqtt.MqttPubRec" href="#lib.server.mqtt.MqttPubRec">MqttPubRec</a></li>
<li><a title="lib.server.mqtt.MqttPubRel" href="#lib.server.mqtt.MqttPubRel">MqttPubRel</a></li>
<li><a title="lib.server.mqtt.MqttPublish" href="#lib.server.mqtt.MqttPublish">MqttPublish</a></li>
<li><a title="lib.server.mqtt.MqttSubAck" href="#lib.server.mqtt.MqttSubAck">MqttSubAck</a></li>
<li><a title="lib.server.mqtt.MqttSubscribe" href="#lib.server.mqtt.MqttSubscribe">MqttSubscribe</a></li>
<li><a title="lib.server.mqtt.MqttUnSubAck" href="#lib.server.mqtt.MqttUnSubAck">MqttUnSubAck</a></li>
<li><a title="lib.server.mqtt.MqttUnsubscribe" href="#lib.server.mqtt.MqttUnsubscribe">MqttUnsubscribe</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lib.server.mqtt.MqttMessage.identifier_base"><code class="name">var <span class="ident">identifier_base</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttMessage.messages"><code class="name">var <span class="ident">messages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttMessage.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the message selector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def init():
        &#34;&#34;&#34; Initialize the message selector &#34;&#34;&#34;
        if len(MqttMessage.messages) == 0:
                MqttMessage.messages = {\
                        MQTT_CONNECT     : MqttConnect,
                        MQTT_CONNACK     : MqttConnAck,
                        MQTT_PUBLISH     : MqttPublish,
                        MQTT_PUBACK      : MqttPubAck,
                        MQTT_PUBREC      : MqttPubRec,
                        MQTT_PUBREL      : MqttPubRel,
                        MQTT_PUBCOMP     : MqttPubComp,
                        MQTT_SUBSCRIBE   : MqttSubscribe,
                        MQTT_SUBACK      : MqttSubAck,
                        MQTT_UNSUBSCRIBE : MqttUnsubscribe,
                        MQTT_UNSUBACK    : MqttUnSubAck,
                        MQTT_PINGREQ     : MqttPingReq,
                        MQTT_PINGRESP    : MqttPingResp,
                        MQTT_DISCONNECT  : MqttDisconnect,}</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.receive"><code class="name flex">
<span>async def <span class="ident">receive</span></span>(<span>streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait message and return the message decoded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def receive(streamio):
        &#34;&#34;&#34; Wait message and return the message decoded &#34;&#34;&#34;
        MqttMessage.init()
        header = await streamio.read(1)
        if len(header) &gt; 0:
                control = header[0] &gt;&gt; 4
                # If message is recognized
                if control in MqttMessage.messages:
                        # Create the right message
                        result = MqttMessage.messages[control](header=header)
                        await result.read(streamio)
                        return result
        return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttMessage.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode message (must redefined)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode message (must redefined)&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.decode_header"><code class="name flex">
<span>def <span class="ident">decode_header</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_header(self, data):
        &#34;&#34;&#34; Decode header &#34;&#34;&#34;
        self.header = data
        self.control = (data[0] &gt;&gt; 4)
        self.qos     = (data[0] &gt;&gt; 1) &amp; 3
        self.dup     = (data[0] &gt;&gt; 3) &amp; 1
        self.retain  = (data[0] &amp; 1)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode message (must redefined)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode message (must redefined)&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.encode_header"><code class="name flex">
<span>def <span class="ident">encode_header</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_header(self):
        &#34;&#34;&#34; Encode header &#34;&#34;&#34;
        if self.control in [MQTT_CONNECT , MQTT_CONNACK, MQTT_PUBACK,
                MQTT_PUBREC , MQTT_PUBCOMP , MQTT_SUBACK,  MQTT_UNSUBACK,
                MQTT_PINGREQ, MQTT_PINGRESP, MQTT_DISCONNECT]:
                return (self.control &lt;&lt; 4).to_bytes(1, &#34;big&#34;)
        elif self.control in [MQTT_SUBSCRIBE, MQTT_UNSUBSCRIBE, MQTT_PUBREL]:
                return ((self.control &lt;&lt; 4) | 2).to_bytes(1, &#34;big&#34;)
        elif self.control in [MQTT_PUBLISH]:
                return ((self.control  &lt;&lt; 4) | ((self.dup &amp; 1) &lt;&lt; 3) | ((self.qos &amp; 3) &lt;&lt; 1) | ((self.retain &amp; 1))).to_bytes(1, &#34;big&#34;)
        else:
                raise MqttException(&#34;Mqtt control command not supported&#34;)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.get_byte"><code class="name flex">
<span>def <span class="ident">get_byte</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Put byte integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_byte(self):
        &#34;&#34;&#34; Put byte integer &#34;&#34;&#34;
        return int.from_bytes(self.payload.read(1), &#34;big&#34;)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.get_int"><code class="name flex">
<span>def <span class="ident">get_int</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get integer on 2 bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_int(self):
        &#34;&#34;&#34; Get integer on 2 bytes &#34;&#34;&#34;
        return int.from_bytes(self.payload.read(2), &#34;big&#34;)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.get_string"><code class="name flex">
<span>def <span class="ident">get_string</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the string with its length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_string(self):
        &#34;&#34;&#34; Get the string with its length &#34;&#34;&#34;
        return strings.tostrings(self.payload.read(self.get_int()))</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.put_buffer"><code class="name flex">
<span>def <span class="ident">put_buffer</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Put binary buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_buffer(self, value):
        &#34;&#34;&#34; Put binary buffer &#34;&#34;&#34;
        self.payload.write(strings.tobytes(value))</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.put_byte"><code class="name flex">
<span>def <span class="ident">put_byte</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Put byte integer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_byte(self, value):
        &#34;&#34;&#34; Put byte integer &#34;&#34;&#34;
        self.payload.write(value.to_bytes(1, &#34;big&#34;))</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.put_int"><code class="name flex">
<span>def <span class="ident">put_int</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Put integer on 2 bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_int(self, value):
        &#34;&#34;&#34; Put integer on 2 bytes &#34;&#34;&#34;
        self.payload.write(value.to_bytes(2, &#34;big&#34;))</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.put_string"><code class="name flex">
<span>def <span class="ident">put_string</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Put the string with its length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_string(self, data):
        &#34;&#34;&#34; Put the string with its length &#34;&#34;&#34;
        if data is not None:
                self.put_int(len(data))
                self.payload.write(strings.tobytes(data))</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.read"><code class="name flex">
<span>async def <span class="ident">read</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Read message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def read(self, streamio):
        &#34;&#34;&#34; Read message &#34;&#34;&#34;
        if self.header is None:
                self.decode_header(await streamio.read(1))
        length = await self.read_length(streamio)
        if length &gt; 0:
                self.payload = BytesIO(await streamio.read(length))
        self.decode()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.read_length"><code class="name flex">
<span>async def <span class="ident">read_length</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def read_length(self, streamio):
        &#34;&#34;&#34; Read the length &#34;&#34;&#34;
        multiplier = 1
        length = 0
        while True:
                encoded_byte = await streamio.read(1)
                length += (encoded_byte[0] &amp; 0x7F) * multiplier
                multiplier *= 128
                if multiplier &gt; 128*128*128:
                        raise MqttException(&#34;Mqtt malformed remaining length&#34;)
                if encoded_byte[0] &amp; 0x80 == 0:
                        break
        return length</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.write"><code class="name flex">
<span>async def <span class="ident">write</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Write message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def write(self, streamio):
        &#34;&#34;&#34; Write message &#34;&#34;&#34;
        await streamio.write(self.encode_header())
        self.encode()
        if await self.write_length(streamio) &gt; 0:
                await streamio.write(self.payload.getvalue())</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttMessage.write_length"><code class="name flex">
<span>async def <span class="ident">write_length</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the length of message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def write_length(self, streamio):
        &#34;&#34;&#34; Write the length of message &#34;&#34;&#34;
        length = len(self.payload.getvalue())
        x = length
        while True:
                encoded_byte = x % 128
                x = x &gt;&gt; 7
                if x &gt; 0:
                        encoded_byte |= 0x80
                await streamio.write(encoded_byte.to_bytes(1, &#34;big&#34;))
                if x &lt;= 0:
                        break
        return length</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.mqtt.MqttPingReq"><code class="flex name class">
<span>class <span class="ident">MqttPingReq</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server : PING request </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttPingReq(MqttMessage):
        &#34;&#34;&#34; Client to Server : PING request &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PINGREQ, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode" href="#lib.server.mqtt.MqttMessage.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode" href="#lib.server.mqtt.MqttMessage.encode">encode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttPingResp"><code class="flex name class">
<span>class <span class="ident">MqttPingResp</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Server to Client : PING response </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttPingResp(MqttMessage):
        &#34;&#34;&#34; Server to Client : PING response &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PINGRESP, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode" href="#lib.server.mqtt.MqttMessage.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode" href="#lib.server.mqtt.MqttMessage.encode">encode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttPubAck"><code class="flex name class">
<span>class <span class="ident">MqttPubAck</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server or Server to Client : Publish acknowledgment </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttPubAck(MqttMessage):
        &#34;&#34;&#34; Client to Server or Server to Client : Publish acknowledgment &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBACK, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttPubAck.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.identifier = self.get_int()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttPubAck.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
        self.put_int(self.identifier)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttPubComp"><code class="flex name class">
<span>class <span class="ident">MqttPubComp</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server or Server to Client : Publish complete (assured delivery part 3) </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttPubComp(MqttMessage):
        &#34;&#34;&#34; Client to Server or Server to Client : Publish complete (assured delivery part 3) &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBCOMP, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttPubComp.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.identifier = self.get_int()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttPubComp.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
        self.put_int(self.identifier)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttPubRec"><code class="flex name class">
<span>class <span class="ident">MqttPubRec</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server or Server to Client : Publish received (assured delivery part 1) </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttPubRec(MqttMessage):
        &#34;&#34;&#34; Client to Server or Server to Client : Publish received (assured delivery part 1) &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBREC, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttPubRec.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.identifier = self.get_int()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttPubRec.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
        self.put_int(self.identifier)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttPubRel"><code class="flex name class">
<span>class <span class="ident">MqttPubRel</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server or Server to Client : Publish release (assured delivery part 2) </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttPubRel(MqttMessage):
        &#34;&#34;&#34; Client to Server or Server to Client : Publish release (assured delivery part 2) &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBREL, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttPubRel.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.identifier = self.get_int()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttPubRel.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
        self.put_int(self.identifier)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttPublish"><code class="flex name class">
<span>class <span class="ident">MqttPublish</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server or Server to Client : Publish message </p>
<p>Constructor
Parameters :
topic : topic name
value : topic value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttPublish(MqttMessage):
        &#34;&#34;&#34;Client to Server or Server to Client : Publish message &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor 
                Parameters : 
                        topic : topic name
                        value : topic value &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_PUBLISH, **kwargs)
                self.topic = kwargs.get(&#34;topic&#34;,&#34;&#34;)
                self.value = kwargs.get(&#34;value&#34;,&#34;&#34;)
                self.identifier = 0

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.topic      = self.get_string()
                if self.qos in [MQTT_QOS_LEAST_ONCE, MQTT_QOS_EXACTLY_ONCE]:
                        self.identifier = self.get_int()
                self.value    = self.payload.read()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_string(self.topic)
                if self.qos in [MQTT_QOS_LEAST_ONCE, MQTT_QOS_EXACTLY_ONCE]:
                        self.put_int(self.identifier)
                self.put_buffer(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttPublish.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.topic      = self.get_string()
        if self.qos in [MQTT_QOS_LEAST_ONCE, MQTT_QOS_EXACTLY_ONCE]:
                self.identifier = self.get_int()
        self.value    = self.payload.read()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttPublish.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
        self.put_string(self.topic)
        if self.qos in [MQTT_QOS_LEAST_ONCE, MQTT_QOS_EXACTLY_ONCE]:
                self.put_int(self.identifier)
        self.put_buffer(self.value)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine"><code class="flex name class">
<span>class <span class="ident">MqttStateMachine</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mqtt protocol management state machine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttStateMachine:
        &#34;&#34;&#34; Mqtt protocol management state machine &#34;&#34;&#34;  
        STATE_OPEN      = 1
        STATE_CONNECT   = 2
        STATE_CONNACK   = 3
        STATE_ACCEPTED  = 4
        STATE_REFUSED   = 5
        STATE_ESTABLISH = 6
        STATE_CLOSE     = 7
        STATE_WAIT      = 8

        @staticmethod
        async def state_open():
                &#34;&#34;&#34; Open mqtt state open socket &#34;&#34;&#34;
                try:
                        reader,writer = await uasyncio.open_connection(strings.tostrings(MqttClient.context.host), MqttClient.context.port)
                        MqttClient.context.streamio = MqttStream(reader, writer)
                        MqttClient.context.state = MqttStateMachine.STATE_CONNECT
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_connect():
                &#34;&#34;&#34; Open mqtt state send connect &#34;&#34;&#34;
                try:
                        command = MqttConnect(**MqttClient.context.kwargs)
                        command.clean_session = True
                        command.keep_alive = MqttClient.context.keep_alive
                        await MqttClient.send(command)
                        MqttClient.context.retry_count = 0
                        MqttClient.context.state = MqttStateMachine.STATE_CONNACK
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_connack():
                &#34;&#34;&#34; Wait connection acknoledge state &#34;&#34;&#34;
                await MqttStateMachine.state_receive()

        @staticmethod
        async def state_accepted():
                &#34;&#34;&#34; Connection mqtt accepted state &#34;&#34;&#34;
                try:
                        if len(MqttClient.subscriptions) &gt; 0:
                                command = MqttSubscribe()
                                for subscription in MqttClient.subscriptions.values():
                                        command.add_topic(subscription.topic, subscription.qos)
                                await MqttClient.send(command)
                        MqttClient.context.state = MqttStateMachine.STATE_ESTABLISH
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_establish():
                &#34;&#34;&#34; Established mqtt state &#34;&#34;&#34;
                await MqttStateMachine.state_receive()

        @staticmethod
        async def state_receive():
                &#34;&#34;&#34; Wait and treat message &#34;&#34;&#34;
                try:
                        # Read and decode message
                        message = await MqttMessage.receive(MqttClient.context.streamio)

                        # If message decoded with success
                        if message is not None:
                                if MqttClient.context.debug:
                                        print(&#34;Mqtt receive : %s&#34;%message.__class__.__name__)
                                # Search treatment callback
                                callback, kwargs = MqttClient.controls.get(message.control, [None,None])

                                # If callback found
                                if callback:
                                        # Call callback
                                        await callback(message, **kwargs)
                                else:
                                        logger.syslog(&#34;Mqtt callback not found for message=%d&#34;%message.control)
                        else:
                                logger.syslog(&#34;Mqtt lost connection&#34;)
                                MqttClient.context.state = MqttStateMachine.STATE_CLOSE
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        async def state_close():
                &#34;&#34;&#34; Close mqtt state &#34;&#34;&#34;
                try:
                        if MqttClient.context.streamio is not None:
                                await MqttClient.context.streamio.close()
                                MqttClient.context.streamio = None
                        MqttClient.context.state = MqttStateMachine.STATE_WAIT
                except Exception as error:
                        MqttClient.context.state = MqttStateMachine.STATE_WAIT

        @staticmethod
        async def state_wait():
                &#34;&#34;&#34; Wait mqtt state before next reconnection &#34;&#34;&#34;
                await uasyncio.sleep(1)
                display = False
                if   MqttClient.context.retry_count &lt;= 60   and MqttClient.context.retry_count % 15 == 0:
                        display = True
                elif MqttClient.context.retry_count &lt;= 600  and MqttClient.context.retry_count % 60 == 0:
                        display = True
                elif MqttClient.context.retry_count &lt;= 3600 and MqttClient.context.retry_count % 3600 == 0:
                        display = True
                if display:
                        logger.syslog(&#34;Mqtt not connected since %d s&#34;%(MqttClient.context.retry_count))
                MqttClient.context.retry_count += 1
                MqttClient.context.state = MqttStateMachine.STATE_OPEN

        @staticmethod
        @MqttClient.add_control(MQTT_CONNACK)
        async def on_conn_ack(message, **kwargs):
                &#34;&#34;&#34; Conn ack treatment &#34;&#34;&#34;
                if MqttClient.context.state == MqttStateMachine.STATE_CONNACK:
                        if message.return_code == 0:
                                logger.syslog(&#34;Mqtt connected&#34;)
                                MqttClient.context.state = MqttStateMachine.STATE_ACCEPTED
                        else:
                                logger.syslog(&#34;Mqtt connection refused %d&#34;%message.return_code)
                                MqttClient.context.state = MqttStateMachine.STATE_CLOSE
                else:
                        logger.syslog(&#34;Mqtt unexpected connack&#34;)
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttClient.add_control(MQTT_PINGREQ)
        async def on_ping_req(message, **kwargs):
                &#34;&#34;&#34; Ping received &#34;&#34;&#34;
                if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                        await MqttClient.send(MqttPingResp())
                else:
                        logger.syslog(&#34;Mqtt unexpected pingreq&#34;)
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttClient.add_control(MQTT_PINGRESP)
        async def on_ping_rsp(message, **kwargs):
                &#34;&#34;&#34; Ping response received &#34;&#34;&#34;
                if MqttClient.context.state != MqttStateMachine.STATE_ESTABLISH:
                        logger.syslog(&#34;Mqtt unexpected pingres&#34;)
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttClient.add_control(MQTT_SUBACK)
        async def on_sub_ack(message, **kwargs):
                &#34;&#34;&#34; Subcribe acknoledge &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_PUBACK)
        async def on_pub_ack(message, **kwargs):
                &#34;&#34;&#34; Publish ack received &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_PUBREC)
        async def on_pub_rec(message, **kwargs):
                &#34;&#34;&#34; Publish received &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_PUBREL)
        async def on_pub_rel(message, **kwargs):
                &#34;&#34;&#34; Publish release received &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_PUBCOMP)
        async def on_pub_comp(message, **kwargs):
                &#34;&#34;&#34; Publish complete received &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_UNSUBACK)
        async def on_unsub_ack(message, **kwargs):
                &#34;&#34;&#34; Unsubcribe acknoledge &#34;&#34;&#34;

        @staticmethod
        @MqttClient.add_control(MQTT_DISCONNECT)
        async def on_disconnect(message, **kwargs):
                &#34;&#34;&#34; Disconnect received &#34;&#34;&#34;
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE

        @staticmethod
        @MqttClient.add_control(MQTT_PUBLISH)
        async def on_publish(message, **kwargs):
                &#34;&#34;&#34; Published message &#34;&#34;&#34;
                if MqttClient.context.debug:
                        print(&#34;Mqtt publish topic &#39;%s&#39;, value=&#39;%s&#39;&#34;%(message.topic, message.value))
                if message.qos == MQTT_QOS_ONCE:
                        pass
                elif message.qos == MQTT_QOS_LEAST_ONCE:
                        await MqttClient.send(MqttPubAck(identifier=message.identifier))
                elif message.qos == MQTT_QOS_EXACTLY_ONCE:
                        await MqttClient.send(MqttPubRec(identifier=message.identifier))
                await MqttClient.call_subscription(message)

        @staticmethod
        async def client_task():
                &#34;&#34;&#34; Manages mqtt commands received and returns responses &#34;&#34;&#34;
                try:
                        states = {
                                MqttStateMachine.STATE_OPEN      : (&#34;OPEN&#34;,      MqttStateMachine.state_open),
                                MqttStateMachine.STATE_CONNECT   : (&#34;CONNECT&#34;,   MqttStateMachine.state_connect),
                                MqttStateMachine.STATE_CONNACK   : (&#34;CONNACK&#34;,   MqttStateMachine.state_connack),
                                MqttStateMachine.STATE_ACCEPTED  : (&#34;ACCEPTED&#34;,  MqttStateMachine.state_accepted),
                                MqttStateMachine.STATE_ESTABLISH : (&#34;ESTABLISH&#34;, MqttStateMachine.state_establish),
                                MqttStateMachine.STATE_CLOSE     : (&#34;CLOSE&#34;,     MqttStateMachine.state_close),
                                MqttStateMachine.STATE_WAIT      : (&#34;WAIT&#34;,      MqttStateMachine.state_wait)
                        }
                        previous_state_name = &#34;&#34;
                        while True:
                                state_name, callback = states.get(MqttClient.context.state, (None,None))
                                if previous_state_name != state_name:
                                        if MqttClient.context.debug:
                                                print(&#34;Mqtt state   : %s&#34;%state_name)
                                        previous_state_name = state_name
                                if callback is not None:
                                        await callback()
                                else:
                                        raise MqttException(&#34;Mqtt illegal state&#34;)
                except Exception as err:
                        logger.syslog(err)
                finally:
                        await MqttStateMachine.state_close()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.server.mqtt.MqttStateMachine.STATE_ACCEPTED"><code class="name">var <span class="ident">STATE_ACCEPTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.STATE_CLOSE"><code class="name">var <span class="ident">STATE_CLOSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.STATE_CONNACK"><code class="name">var <span class="ident">STATE_CONNACK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.STATE_CONNECT"><code class="name">var <span class="ident">STATE_CONNECT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.STATE_ESTABLISH"><code class="name">var <span class="ident">STATE_ESTABLISH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.STATE_OPEN"><code class="name">var <span class="ident">STATE_OPEN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.STATE_REFUSED"><code class="name">var <span class="ident">STATE_REFUSED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.STATE_WAIT"><code class="name">var <span class="ident">STATE_WAIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttStateMachine.client_task"><code class="name flex">
<span>async def <span class="ident">client_task</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages mqtt commands received and returns responses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def client_task():
        &#34;&#34;&#34; Manages mqtt commands received and returns responses &#34;&#34;&#34;
        try:
                states = {
                        MqttStateMachine.STATE_OPEN      : (&#34;OPEN&#34;,      MqttStateMachine.state_open),
                        MqttStateMachine.STATE_CONNECT   : (&#34;CONNECT&#34;,   MqttStateMachine.state_connect),
                        MqttStateMachine.STATE_CONNACK   : (&#34;CONNACK&#34;,   MqttStateMachine.state_connack),
                        MqttStateMachine.STATE_ACCEPTED  : (&#34;ACCEPTED&#34;,  MqttStateMachine.state_accepted),
                        MqttStateMachine.STATE_ESTABLISH : (&#34;ESTABLISH&#34;, MqttStateMachine.state_establish),
                        MqttStateMachine.STATE_CLOSE     : (&#34;CLOSE&#34;,     MqttStateMachine.state_close),
                        MqttStateMachine.STATE_WAIT      : (&#34;WAIT&#34;,      MqttStateMachine.state_wait)
                }
                previous_state_name = &#34;&#34;
                while True:
                        state_name, callback = states.get(MqttClient.context.state, (None,None))
                        if previous_state_name != state_name:
                                if MqttClient.context.debug:
                                        print(&#34;Mqtt state   : %s&#34;%state_name)
                                previous_state_name = state_name
                        if callback is not None:
                                await callback()
                        else:
                                raise MqttException(&#34;Mqtt illegal state&#34;)
        except Exception as err:
                logger.syslog(err)
        finally:
                await MqttStateMachine.state_close()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_conn_ack"><code class="name flex">
<span>async def <span class="ident">on_conn_ack</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Conn ack treatment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_CONNACK)
async def on_conn_ack(message, **kwargs):
        &#34;&#34;&#34; Conn ack treatment &#34;&#34;&#34;
        if MqttClient.context.state == MqttStateMachine.STATE_CONNACK:
                if message.return_code == 0:
                        logger.syslog(&#34;Mqtt connected&#34;)
                        MqttClient.context.state = MqttStateMachine.STATE_ACCEPTED
                else:
                        logger.syslog(&#34;Mqtt connection refused %d&#34;%message.return_code)
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE
        else:
                logger.syslog(&#34;Mqtt unexpected connack&#34;)
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_disconnect"><code class="name flex">
<span>async def <span class="ident">on_disconnect</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Disconnect received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_DISCONNECT)
async def on_disconnect(message, **kwargs):
        &#34;&#34;&#34; Disconnect received &#34;&#34;&#34;
        MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_ping_req"><code class="name flex">
<span>async def <span class="ident">on_ping_req</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ping received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_PINGREQ)
async def on_ping_req(message, **kwargs):
        &#34;&#34;&#34; Ping received &#34;&#34;&#34;
        if MqttClient.context.state == MqttStateMachine.STATE_ESTABLISH:
                await MqttClient.send(MqttPingResp())
        else:
                logger.syslog(&#34;Mqtt unexpected pingreq&#34;)
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_ping_rsp"><code class="name flex">
<span>async def <span class="ident">on_ping_rsp</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ping response received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_PINGRESP)
async def on_ping_rsp(message, **kwargs):
        &#34;&#34;&#34; Ping response received &#34;&#34;&#34;
        if MqttClient.context.state != MqttStateMachine.STATE_ESTABLISH:
                logger.syslog(&#34;Mqtt unexpected pingres&#34;)
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_pub_ack"><code class="name flex">
<span>async def <span class="ident">on_pub_ack</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish ack received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_PUBACK)
async def on_pub_ack(message, **kwargs):
        &#34;&#34;&#34; Publish ack received &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_pub_comp"><code class="name flex">
<span>async def <span class="ident">on_pub_comp</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish complete received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_PUBCOMP)
async def on_pub_comp(message, **kwargs):
        &#34;&#34;&#34; Publish complete received &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_pub_rec"><code class="name flex">
<span>async def <span class="ident">on_pub_rec</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_PUBREC)
async def on_pub_rec(message, **kwargs):
        &#34;&#34;&#34; Publish received &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_pub_rel"><code class="name flex">
<span>async def <span class="ident">on_pub_rel</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Publish release received</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_PUBREL)
async def on_pub_rel(message, **kwargs):
        &#34;&#34;&#34; Publish release received &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_publish"><code class="name flex">
<span>async def <span class="ident">on_publish</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Published message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_PUBLISH)
async def on_publish(message, **kwargs):
        &#34;&#34;&#34; Published message &#34;&#34;&#34;
        if MqttClient.context.debug:
                print(&#34;Mqtt publish topic &#39;%s&#39;, value=&#39;%s&#39;&#34;%(message.topic, message.value))
        if message.qos == MQTT_QOS_ONCE:
                pass
        elif message.qos == MQTT_QOS_LEAST_ONCE:
                await MqttClient.send(MqttPubAck(identifier=message.identifier))
        elif message.qos == MQTT_QOS_EXACTLY_ONCE:
                await MqttClient.send(MqttPubRec(identifier=message.identifier))
        await MqttClient.call_subscription(message)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_sub_ack"><code class="name flex">
<span>async def <span class="ident">on_sub_ack</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Subcribe acknoledge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_SUBACK)
async def on_sub_ack(message, **kwargs):
        &#34;&#34;&#34; Subcribe acknoledge &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.on_unsub_ack"><code class="name flex">
<span>async def <span class="ident">on_unsub_ack</span></span>(<span>message, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsubcribe acknoledge</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@MqttClient.add_control(MQTT_UNSUBACK)
async def on_unsub_ack(message, **kwargs):
        &#34;&#34;&#34; Unsubcribe acknoledge &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.state_accepted"><code class="name flex">
<span>async def <span class="ident">state_accepted</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Connection mqtt accepted state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_accepted():
        &#34;&#34;&#34; Connection mqtt accepted state &#34;&#34;&#34;
        try:
                if len(MqttClient.subscriptions) &gt; 0:
                        command = MqttSubscribe()
                        for subscription in MqttClient.subscriptions.values():
                                command.add_topic(subscription.topic, subscription.qos)
                        await MqttClient.send(command)
                MqttClient.context.state = MqttStateMachine.STATE_ESTABLISH
        except Exception as error:
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.state_close"><code class="name flex">
<span>async def <span class="ident">state_close</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Close mqtt state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_close():
        &#34;&#34;&#34; Close mqtt state &#34;&#34;&#34;
        try:
                if MqttClient.context.streamio is not None:
                        await MqttClient.context.streamio.close()
                        MqttClient.context.streamio = None
                MqttClient.context.state = MqttStateMachine.STATE_WAIT
        except Exception as error:
                MqttClient.context.state = MqttStateMachine.STATE_WAIT</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.state_connack"><code class="name flex">
<span>async def <span class="ident">state_connack</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait connection acknoledge state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_connack():
        &#34;&#34;&#34; Wait connection acknoledge state &#34;&#34;&#34;
        await MqttStateMachine.state_receive()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.state_connect"><code class="name flex">
<span>async def <span class="ident">state_connect</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Open mqtt state send connect</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_connect():
        &#34;&#34;&#34; Open mqtt state send connect &#34;&#34;&#34;
        try:
                command = MqttConnect(**MqttClient.context.kwargs)
                command.clean_session = True
                command.keep_alive = MqttClient.context.keep_alive
                await MqttClient.send(command)
                MqttClient.context.retry_count = 0
                MqttClient.context.state = MqttStateMachine.STATE_CONNACK
        except Exception as error:
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.state_establish"><code class="name flex">
<span>async def <span class="ident">state_establish</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Established mqtt state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_establish():
        &#34;&#34;&#34; Established mqtt state &#34;&#34;&#34;
        await MqttStateMachine.state_receive()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.state_open"><code class="name flex">
<span>async def <span class="ident">state_open</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Open mqtt state open socket</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_open():
        &#34;&#34;&#34; Open mqtt state open socket &#34;&#34;&#34;
        try:
                reader,writer = await uasyncio.open_connection(strings.tostrings(MqttClient.context.host), MqttClient.context.port)
                MqttClient.context.streamio = MqttStream(reader, writer)
                MqttClient.context.state = MqttStateMachine.STATE_CONNECT
        except Exception as error:
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.state_receive"><code class="name flex">
<span>async def <span class="ident">state_receive</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait and treat message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_receive():
        &#34;&#34;&#34; Wait and treat message &#34;&#34;&#34;
        try:
                # Read and decode message
                message = await MqttMessage.receive(MqttClient.context.streamio)

                # If message decoded with success
                if message is not None:
                        if MqttClient.context.debug:
                                print(&#34;Mqtt receive : %s&#34;%message.__class__.__name__)
                        # Search treatment callback
                        callback, kwargs = MqttClient.controls.get(message.control, [None,None])

                        # If callback found
                        if callback:
                                # Call callback
                                await callback(message, **kwargs)
                        else:
                                logger.syslog(&#34;Mqtt callback not found for message=%d&#34;%message.control)
                else:
                        logger.syslog(&#34;Mqtt lost connection&#34;)
                        MqttClient.context.state = MqttStateMachine.STATE_CLOSE
        except Exception as error:
                MqttClient.context.state = MqttStateMachine.STATE_CLOSE</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStateMachine.state_wait"><code class="name flex">
<span>async def <span class="ident">state_wait</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait mqtt state before next reconnection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def state_wait():
        &#34;&#34;&#34; Wait mqtt state before next reconnection &#34;&#34;&#34;
        await uasyncio.sleep(1)
        display = False
        if   MqttClient.context.retry_count &lt;= 60   and MqttClient.context.retry_count % 15 == 0:
                display = True
        elif MqttClient.context.retry_count &lt;= 600  and MqttClient.context.retry_count % 60 == 0:
                display = True
        elif MqttClient.context.retry_count &lt;= 3600 and MqttClient.context.retry_count % 3600 == 0:
                display = True
        if display:
                logger.syslog(&#34;Mqtt not connected since %d s&#34;%(MqttClient.context.retry_count))
        MqttClient.context.retry_count += 1
        MqttClient.context.state = MqttStateMachine.STATE_OPEN</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.mqtt.MqttStream"><code class="flex name class">
<span>class <span class="ident">MqttStream</span></span>
<span>(</span><span>reader, writer)</span>
</code></dt>
<dd>
<div class="desc"><p>Read and write stream for mqtt </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttStream(stream.Stream):
        &#34;&#34;&#34; Read and write stream for mqtt &#34;&#34;&#34;
        def __init__(self, reader, writer):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                stream.Stream.__init__(self, reader, writer)

        async def read(self, length):
                &#34;&#34;&#34; Read data from the stream &#34;&#34;&#34;
                return await stream.Stream.read(self, length)

        async def close(self):
                &#34;&#34;&#34; Close the stream &#34;&#34;&#34;
                self.writer.close()
                self.reader.close()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>server.stream.Stream</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttStream.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
        &#34;&#34;&#34; Close the stream &#34;&#34;&#34;
        self.writer.close()
        self.reader.close()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttStream.read"><code class="name flex">
<span>async def <span class="ident">read</span></span>(<span>self, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Read data from the stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def read(self, length):
        &#34;&#34;&#34; Read data from the stream &#34;&#34;&#34;
        return await stream.Stream.read(self, length)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.mqtt.MqttSubAck"><code class="flex name class">
<span>class <span class="ident">MqttSubAck</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Server to Client : Subscribe acknowledgment </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttSubAck(MqttMessage):
        &#34;&#34;&#34; Server to Client : Subscribe acknowledgment &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_SUBACK, **kwargs)
                self.return_code = kwargs.get(&#34;return_code&#34;,[])

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()
                self.return_code = []
                while self.payload.tell() &lt; len(self.payload.getvalue()):
                        self.return_code.append(self.get_byte())

        def encode(self):
                &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
                self.put_int(self.identifier)
                for return_code in self.return_code:
                        self.put_byte(return_code)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttSubAck.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.identifier = self.get_int()
        self.return_code = []
        while self.payload.tell() &lt; len(self.payload.getvalue()):
                self.return_code.append(self.get_byte())</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttSubAck.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
        self.put_int(self.identifier)
        for return_code in self.return_code:
                self.put_byte(return_code)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttSubscribe"><code class="flex name class">
<span>class <span class="ident">MqttSubscribe</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server : Client subscribe request </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttSubscribe(MqttMessage):
        &#34;&#34;&#34; Client to Server : Client subscribe request &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_SUBSCRIBE, **kwargs)
                self.topics = kwargs.get(&#34;topics&#34;,[])

        def add_topic(self, topic, qos=MQTT_QOS_ONCE):
                &#34;&#34;&#34; Add topics into subscribe &#34;&#34;&#34;
                self.topics.append((topic, qos))

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()
                self.topics = []
                while self.payload.tell() &lt; len(self.payload.getvalue()):
                        topic = self.get_string()
                        qos = self.get_byte()
                        self.add_topic(topic, qos)

        def encode(self):
                &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
                self.put_int(self.identifier)
                for topic,qos in self.topics:
                        self.put_string(topic)
                        self.put_byte(qos)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttSubscribe.add_topic"><code class="name flex">
<span>def <span class="ident">add_topic</span></span>(<span>self, topic, qos=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Add topics into subscribe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_topic(self, topic, qos=MQTT_QOS_ONCE):
        &#34;&#34;&#34; Add topics into subscribe &#34;&#34;&#34;
        self.topics.append((topic, qos))</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttSubscribe.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.identifier = self.get_int()
        self.topics = []
        while self.payload.tell() &lt; len(self.payload.getvalue()):
                topic = self.get_string()
                qos = self.get_byte()
                self.add_topic(topic, qos)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttSubscribe.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
        self.put_int(self.identifier)
        for topic,qos in self.topics:
                self.put_string(topic)
                self.put_byte(qos)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttSubscription"><code class="flex name class">
<span>class <span class="ident">MqttSubscription</span></span>
<span>(</span><span>topic, function, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Subscription callback caller </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttSubscription:
        &#34;&#34;&#34; Subscription callback caller &#34;&#34;&#34;
        def __init__(self, topic, function, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.topic = topic
                self.kwargs  = kwargs
                self.function = function
                self.qos = kwargs.get(&#34;qos&#34;,MQTT_QOS_ONCE)

        async def call(self, message):
                &#34;&#34;&#34; Call callback registered &#34;&#34;&#34;
                await self.function(message, **self.kwargs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttSubscription.call"><code class="name flex">
<span>async def <span class="ident">call</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Call callback registered</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def call(self, message):
        &#34;&#34;&#34; Call callback registered &#34;&#34;&#34;
        await self.function(message, **self.kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.mqtt.MqttUnSubAck"><code class="flex name class">
<span>class <span class="ident">MqttUnSubAck</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Server to Client : Unsubscribe acknowledgment </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttUnSubAck(MqttMessage):
        &#34;&#34;&#34; Server to Client : Unsubscribe acknowledgment &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_UNSUBACK, **kwargs)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()

        def encode(self):
                &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
                self.put_int(self.identifier)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttUnSubAck.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.identifier = self.get_int()</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttUnSubAck.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode the payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode the payload &#34;&#34;&#34;
        self.put_int(self.identifier)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.mqtt.MqttUnsubscribe"><code class="flex name class">
<span>class <span class="ident">MqttUnsubscribe</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Client to Server : Unsubscribe request </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MqttUnsubscribe(MqttMessage):
        &#34;&#34;&#34; Client to Server : Unsubscribe request &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MqttMessage.__init__(self, control=MQTT_UNSUBSCRIBE, **kwargs)
                self.topics = kwargs.get(&#34;topics&#34;,[])

        def add_topic(self, topic):
                &#34;&#34;&#34; Add topics into subscribe &#34;&#34;&#34;
                self.topics.append(topic)

        def decode(self):
                &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
                self.identifier = self.get_int()
                self.topics = []
                while self.payload.tell() &lt; len(self.payload.getvalue()):
                        topic = self.get_string()
                        self.add_topic(topic)

        def encode(self):
                &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
                self.put_int(self.identifier)
                for topic,qos in self.topics:
                        self.put_string(topic)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.mqtt.MqttUnsubscribe.add_topic"><code class="name flex">
<span>def <span class="ident">add_topic</span></span>(<span>self, topic)</span>
</code></dt>
<dd>
<div class="desc"><p>Add topics into subscribe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_topic(self, topic):
        &#34;&#34;&#34; Add topics into subscribe &#34;&#34;&#34;
        self.topics.append(topic)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttUnsubscribe.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode(self):
        &#34;&#34;&#34; Decode payload &#34;&#34;&#34;
        self.identifier = self.get_int()
        self.topics = []
        while self.payload.tell() &lt; len(self.payload.getvalue()):
                topic = self.get_string()
                self.add_topic(topic)</code></pre>
</details>
</dd>
<dt id="lib.server.mqtt.MqttUnsubscribe.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode payload</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode(self):
        &#34;&#34;&#34; Encode payload &#34;&#34;&#34;
        self.put_int(self.identifier)
        for topic,qos in self.topics:
                self.put_string(topic)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.server" href="index.html">lib.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lib.server.mqtt.mqtt_client_task" href="#lib.server.mqtt.mqtt_client_task">mqtt_client_task</a></code></li>
<li><code><a title="lib.server.mqtt.mqtt_ping_task" href="#lib.server.mqtt.mqtt_ping_task">mqtt_ping_task</a></code></li>
<li><code><a title="lib.server.mqtt.mqtt_test" href="#lib.server.mqtt.mqtt_test">mqtt_test</a></code></li>
<li><code><a title="lib.server.mqtt.start" href="#lib.server.mqtt.start">start</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.server.mqtt.MqttClient" href="#lib.server.mqtt.MqttClient">MqttClient</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.server.mqtt.MqttClient.add_control" href="#lib.server.mqtt.MqttClient.add_control">add_control</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.add_subscription" href="#lib.server.mqtt.MqttClient.add_subscription">add_subscription</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.call_subscription" href="#lib.server.mqtt.MqttClient.call_subscription">call_subscription</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.context" href="#lib.server.mqtt.MqttClient.context">context</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.controls" href="#lib.server.mqtt.MqttClient.controls">controls</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.disconnect" href="#lib.server.mqtt.MqttClient.disconnect">disconnect</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.init" href="#lib.server.mqtt.MqttClient.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.ping_task" href="#lib.server.mqtt.MqttClient.ping_task">ping_task</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.remove_control" href="#lib.server.mqtt.MqttClient.remove_control">remove_control</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.remove_subscription" href="#lib.server.mqtt.MqttClient.remove_subscription">remove_subscription</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.send" href="#lib.server.mqtt.MqttClient.send">send</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.subscribe" href="#lib.server.mqtt.MqttClient.subscribe">subscribe</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.subscribe_all" href="#lib.server.mqtt.MqttClient.subscribe_all">subscribe_all</a></code></li>
<li><code><a title="lib.server.mqtt.MqttClient.subscriptions" href="#lib.server.mqtt.MqttClient.subscriptions">subscriptions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttClientContext" href="#lib.server.mqtt.MqttClientContext">MqttClientContext</a></code></h4>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttConnAck" href="#lib.server.mqtt.MqttConnAck">MqttConnAck</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttConnAck.decode" href="#lib.server.mqtt.MqttConnAck.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttConnAck.encode" href="#lib.server.mqtt.MqttConnAck.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttConnect" href="#lib.server.mqtt.MqttConnect">MqttConnect</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttConnect.decode" href="#lib.server.mqtt.MqttConnect.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttConnect.encode" href="#lib.server.mqtt.MqttConnect.encode">encode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttConnect.get_flags" href="#lib.server.mqtt.MqttConnect.get_flags">get_flags</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttDisconnect" href="#lib.server.mqtt.MqttDisconnect">MqttDisconnect</a></code></h4>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttException" href="#lib.server.mqtt.MqttException">MqttException</a></code></h4>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttMessage" href="#lib.server.mqtt.MqttMessage">MqttMessage</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.server.mqtt.MqttMessage.decode" href="#lib.server.mqtt.MqttMessage.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.decode_header" href="#lib.server.mqtt.MqttMessage.decode_header">decode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode" href="#lib.server.mqtt.MqttMessage.encode">encode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.encode_header" href="#lib.server.mqtt.MqttMessage.encode_header">encode_header</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_byte" href="#lib.server.mqtt.MqttMessage.get_byte">get_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_int" href="#lib.server.mqtt.MqttMessage.get_int">get_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.get_string" href="#lib.server.mqtt.MqttMessage.get_string">get_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.identifier_base" href="#lib.server.mqtt.MqttMessage.identifier_base">identifier_base</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.init" href="#lib.server.mqtt.MqttMessage.init">init</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.messages" href="#lib.server.mqtt.MqttMessage.messages">messages</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_buffer" href="#lib.server.mqtt.MqttMessage.put_buffer">put_buffer</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_byte" href="#lib.server.mqtt.MqttMessage.put_byte">put_byte</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_int" href="#lib.server.mqtt.MqttMessage.put_int">put_int</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.put_string" href="#lib.server.mqtt.MqttMessage.put_string">put_string</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read" href="#lib.server.mqtt.MqttMessage.read">read</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.read_length" href="#lib.server.mqtt.MqttMessage.read_length">read_length</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.receive" href="#lib.server.mqtt.MqttMessage.receive">receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write" href="#lib.server.mqtt.MqttMessage.write">write</a></code></li>
<li><code><a title="lib.server.mqtt.MqttMessage.write_length" href="#lib.server.mqtt.MqttMessage.write_length">write_length</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttPingReq" href="#lib.server.mqtt.MqttPingReq">MqttPingReq</a></code></h4>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttPingResp" href="#lib.server.mqtt.MqttPingResp">MqttPingResp</a></code></h4>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttPubAck" href="#lib.server.mqtt.MqttPubAck">MqttPubAck</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttPubAck.decode" href="#lib.server.mqtt.MqttPubAck.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttPubAck.encode" href="#lib.server.mqtt.MqttPubAck.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttPubComp" href="#lib.server.mqtt.MqttPubComp">MqttPubComp</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttPubComp.decode" href="#lib.server.mqtt.MqttPubComp.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttPubComp.encode" href="#lib.server.mqtt.MqttPubComp.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttPubRec" href="#lib.server.mqtt.MqttPubRec">MqttPubRec</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttPubRec.decode" href="#lib.server.mqtt.MqttPubRec.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttPubRec.encode" href="#lib.server.mqtt.MqttPubRec.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttPubRel" href="#lib.server.mqtt.MqttPubRel">MqttPubRel</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttPubRel.decode" href="#lib.server.mqtt.MqttPubRel.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttPubRel.encode" href="#lib.server.mqtt.MqttPubRel.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttPublish" href="#lib.server.mqtt.MqttPublish">MqttPublish</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttPublish.decode" href="#lib.server.mqtt.MqttPublish.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttPublish.encode" href="#lib.server.mqtt.MqttPublish.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttStateMachine" href="#lib.server.mqtt.MqttStateMachine">MqttStateMachine</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.server.mqtt.MqttStateMachine.STATE_ACCEPTED" href="#lib.server.mqtt.MqttStateMachine.STATE_ACCEPTED">STATE_ACCEPTED</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.STATE_CLOSE" href="#lib.server.mqtt.MqttStateMachine.STATE_CLOSE">STATE_CLOSE</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.STATE_CONNACK" href="#lib.server.mqtt.MqttStateMachine.STATE_CONNACK">STATE_CONNACK</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.STATE_CONNECT" href="#lib.server.mqtt.MqttStateMachine.STATE_CONNECT">STATE_CONNECT</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.STATE_ESTABLISH" href="#lib.server.mqtt.MqttStateMachine.STATE_ESTABLISH">STATE_ESTABLISH</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.STATE_OPEN" href="#lib.server.mqtt.MqttStateMachine.STATE_OPEN">STATE_OPEN</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.STATE_REFUSED" href="#lib.server.mqtt.MqttStateMachine.STATE_REFUSED">STATE_REFUSED</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.STATE_WAIT" href="#lib.server.mqtt.MqttStateMachine.STATE_WAIT">STATE_WAIT</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.client_task" href="#lib.server.mqtt.MqttStateMachine.client_task">client_task</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_conn_ack" href="#lib.server.mqtt.MqttStateMachine.on_conn_ack">on_conn_ack</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_disconnect" href="#lib.server.mqtt.MqttStateMachine.on_disconnect">on_disconnect</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_ping_req" href="#lib.server.mqtt.MqttStateMachine.on_ping_req">on_ping_req</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_ping_rsp" href="#lib.server.mqtt.MqttStateMachine.on_ping_rsp">on_ping_rsp</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_pub_ack" href="#lib.server.mqtt.MqttStateMachine.on_pub_ack">on_pub_ack</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_pub_comp" href="#lib.server.mqtt.MqttStateMachine.on_pub_comp">on_pub_comp</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_pub_rec" href="#lib.server.mqtt.MqttStateMachine.on_pub_rec">on_pub_rec</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_pub_rel" href="#lib.server.mqtt.MqttStateMachine.on_pub_rel">on_pub_rel</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_publish" href="#lib.server.mqtt.MqttStateMachine.on_publish">on_publish</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_sub_ack" href="#lib.server.mqtt.MqttStateMachine.on_sub_ack">on_sub_ack</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.on_unsub_ack" href="#lib.server.mqtt.MqttStateMachine.on_unsub_ack">on_unsub_ack</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.state_accepted" href="#lib.server.mqtt.MqttStateMachine.state_accepted">state_accepted</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.state_close" href="#lib.server.mqtt.MqttStateMachine.state_close">state_close</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.state_connack" href="#lib.server.mqtt.MqttStateMachine.state_connack">state_connack</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.state_connect" href="#lib.server.mqtt.MqttStateMachine.state_connect">state_connect</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.state_establish" href="#lib.server.mqtt.MqttStateMachine.state_establish">state_establish</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.state_open" href="#lib.server.mqtt.MqttStateMachine.state_open">state_open</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.state_receive" href="#lib.server.mqtt.MqttStateMachine.state_receive">state_receive</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStateMachine.state_wait" href="#lib.server.mqtt.MqttStateMachine.state_wait">state_wait</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttStream" href="#lib.server.mqtt.MqttStream">MqttStream</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttStream.close" href="#lib.server.mqtt.MqttStream.close">close</a></code></li>
<li><code><a title="lib.server.mqtt.MqttStream.read" href="#lib.server.mqtt.MqttStream.read">read</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttSubAck" href="#lib.server.mqtt.MqttSubAck">MqttSubAck</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttSubAck.decode" href="#lib.server.mqtt.MqttSubAck.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttSubAck.encode" href="#lib.server.mqtt.MqttSubAck.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttSubscribe" href="#lib.server.mqtt.MqttSubscribe">MqttSubscribe</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttSubscribe.add_topic" href="#lib.server.mqtt.MqttSubscribe.add_topic">add_topic</a></code></li>
<li><code><a title="lib.server.mqtt.MqttSubscribe.decode" href="#lib.server.mqtt.MqttSubscribe.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttSubscribe.encode" href="#lib.server.mqtt.MqttSubscribe.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttSubscription" href="#lib.server.mqtt.MqttSubscription">MqttSubscription</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttSubscription.call" href="#lib.server.mqtt.MqttSubscription.call">call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttUnSubAck" href="#lib.server.mqtt.MqttUnSubAck">MqttUnSubAck</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttUnSubAck.decode" href="#lib.server.mqtt.MqttUnSubAck.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttUnSubAck.encode" href="#lib.server.mqtt.MqttUnSubAck.encode">encode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.mqtt.MqttUnsubscribe" href="#lib.server.mqtt.MqttUnsubscribe">MqttUnsubscribe</a></code></h4>
<ul class="">
<li><code><a title="lib.server.mqtt.MqttUnsubscribe.add_topic" href="#lib.server.mqtt.MqttUnsubscribe.add_topic">add_topic</a></code></li>
<li><code><a title="lib.server.mqtt.MqttUnsubscribe.decode" href="#lib.server.mqtt.MqttUnsubscribe.decode">decode</a></code></li>
<li><code><a title="lib.server.mqtt.MqttUnsubscribe.encode" href="#lib.server.mqtt.MqttUnsubscribe.encode">encode</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>