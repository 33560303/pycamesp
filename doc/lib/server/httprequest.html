<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lib.server.httprequest API documentation</title>
<meta name="description" content="These classes manage http responses and requests.
The set of request and response are in bytes format.
I no longer use tools.strings., because they â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.server.httprequest</code></h1>
</header>
<section id="section-intro">
<p>These classes manage http responses and requests.
The set of request and response are in bytes format.
I no longer use tools.strings., because they are between 20 and 30 times slower.
It may sound a bit more complicated, but it's a lot quick.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under Pycameresp License
# Copyright (c) 2023 Remi BERTHOLET
# historically based on :
# https://github.com/jczic/MicroWebSrv/blob/master/microWebSocket.py
# but I have modified a lot, there must still be some original functions.
# pylint:disable=consider-using-f-string
&#34;&#34;&#34; These classes manage http responses and requests.
The set of request and response are in bytes format.
I no longer use tools.strings., because they are between 20 and 30 times slower.
It may sound a bit more complicated, but it&#39;s a lot quick.
&#34;&#34;&#34;
import hashlib
import time
from binascii import hexlify, b2a_base64
import collections
import server.stream
import server.urlparser
import tools.logger
import tools.filesystem
import tools.strings

MIMES = {\
        b&#34;.txt&#34;   : b&#34;text/plain&#34;,
        b&#34;.py&#34;    : b&#34;text/plain&#34;,
        b&#34;.html&#34;  : b&#34;text/html&#34;,
        b&#34;.css&#34;   : b&#34;text/css&#34;,
        b&#34;.htm&#34;   : b&#34;text/html&#34;,
        b&#34;.csv&#34;   : b&#34;text/csv&#34;,
        b&#34;.log&#34;   : b&#34;text/plain&#34;,
        b&#34;.1&#34;     : b&#34;text/plain&#34;,
        b&#34;.2&#34;     : b&#34;text/plain&#34;,
        b&#34;.3&#34;     : b&#34;text/plain&#34;,
        b&#34;.4&#34;     : b&#34;text/plain&#34;,
        b&#34;.js&#34;    : b&#34;application/javascript&#34;,
        b&#34;.xml&#34;   : b&#34;application/xml&#34;,
        b&#34;.xhtml&#34; : b&#34;application/xhtml+xml&#34;,
        b&#34;.json&#34;  : b&#34;application/json&#34;,
        b&#34;.zip&#34;   : b&#34;application/zip&#34;,
        b&#34;.pdf&#34;   : b&#34;application/pdf&#34;,
        b&#34;.ts&#34;    : b&#34;application/typescript&#34;,
        b&#34;.woff&#34;  : b&#34;font/woff&#34;,
        b&#34;.woff2&#34; : b&#34;font/woff2&#34;,
        b&#34;.ttf&#34;   : b&#34;font/ttf&#34;,
        b&#34;.otf&#34;   : b&#34;font/otf&#34;,
        b&#34;.jpg&#34;   : b&#34;image/jpeg&#34;,
        b&#34;.png&#34;   : b&#34;image/png&#34;,
        b&#34;.gif&#34;   : b&#34;image/gif&#34;,
        b&#34;.jpeg&#34;  : b&#34;image/jpeg&#34;,
        b&#34;.svg&#34;   : b&#34;image/svg+xml&#34;,
        b&#34;.ico&#34;   : b&#34;image/x-icon&#34;,
        b&#34;.bin&#34;   : b&#34;application/octet-stream&#34;
}

class Http:
        &#34;&#34;&#34; Http request or reponse &#34;&#34;&#34;
        def __init__(self, request = True, remoteaddr= b&#34;&#34;, port = 0, name=&#34;&#34;):
                &#34;&#34;&#34; Constructor from http request or response &#34;&#34;&#34;
                self.port       = port
                self.name       = name
                self.remoteaddr = remoteaddr
                self.path       = b&#34;&#34;
                self.method     = b&#34;POST&#34;
                self.headers    = collections.OrderedDict()
                self.params     = collections.OrderedDict()
                self.cookies    = collections.OrderedDict()
                self.parts      = []
                self.status     = 0
                self.content    = None
                self.content_file = None
                self.identifier = None
                self.request    = request
                self.chunk_size = 0

        def __del__(self):
                if self.content_file is not None:
                        tools.filesystem.remove(self.content_file)

        def get_expiration(self, expiration):
                &#34;&#34;&#34; Get cookie expiration date &#34;&#34;&#34;
                result = b&#34;; Max-Age=%d&#34;%expiration
                return result

        def get_cookie(self, name):
                &#34;&#34;&#34; Get cookie value &#34;&#34;&#34;
                try:
                        return self.cookies.get(name, None)
                except:
                        return None

        def set_cookie(self, name, value=None, expiration=None, http_only=False):
                &#34;&#34;&#34; Set cookie &#34;&#34;&#34;
                if value is None:
                        if name in self.cookies:
                                del self.cookies[name]
                else:
                        self.cookies[name] = (value, expiration, http_only)

        def get_header(self, name):
                &#34;&#34;&#34; Get the http request header &#34;&#34;&#34;
                try:
                        return self.headers.get(name, None)
                except:
                        return None

        def set_header(self, name, value):
                &#34;&#34;&#34; Set the http request header &#34;&#34;&#34;
                if value is None:
                        del self.headers[name]
                else:
                        self.headers[name] = value

        def set_method(self, method):
                &#34;&#34;&#34; Set http request method (POST or GET) &#34;&#34;&#34;
                self.method = method

        def get_path(self):
                &#34;&#34;&#34; Get the path of the request or response &#34;&#34;&#34;
                return self.path

        def set_path(self, path):
                &#34;&#34;&#34; Define the past of the request or response &#34;&#34;&#34;
                self.path = path

        def add_part(self, part):
                &#34;&#34;&#34; Add part of the request. Used for multipart request &#34;&#34;&#34;
                self.parts.append(part)

        def get_status(self):
                &#34;&#34;&#34; Get the status value &#34;&#34;&#34;
                return self.status

        def set_status(self, status):
                &#34;&#34;&#34; Set the status value &#34;&#34;&#34;
                self.status = status

        def set_content(self, content):
                &#34;&#34;&#34; Set the content of the request or response (can be an instance of html template) &#34;&#34;&#34;
                if type(content) == type(&#34;&#34;):
                        self.content = ContentText(content)
                else:
                        self.content = content

        def get_content(self):
                &#34;&#34;&#34; Get the content of the request or response &#34;&#34;&#34;
                return self.content

        def get_id(self):
                &#34;&#34;&#34; Get the unique identifier of the request or response. Used for multipart request &#34;&#34;&#34;
                hash_ = hashlib.sha256()
                ids = b&#34;%d&#34;%time.time()
                hash_.update(ids)
                return hexlify(hash_.digest())[32:]

        async def unserialize(self, streamio):
                &#34;&#34;&#34; Unserialize the request or response in the stream &#34;&#34;&#34;
                data = await streamio.readline()
                if data != b&#34;&#34;:
                        urlparser = server.urlparser.UrlParser(data, True)
                        spl = data.split()
                        if len(spl) &gt;= 2:
                                self.method = urlparser.method
                                path = spl[1]
                                if self.request is False:
                                        self.status = path
                                self.path   = urlparser.path
                                self.params = urlparser.params
                                await self.unserialize_headers(streamio)
                        else:
                                await self.read_content(streamio)

        async def read_content(self, streamio):
                &#34;&#34;&#34; Read the content of http request &#34;&#34;&#34;
                if self.headers.get(b&#34;Transfer-Encoding&#34;,b&#34;&#34;) == b&#34;chunked&#34;:
                        length = await streamio.readline()
                        length = eval(tools.strings.tostrings(b&#34;0x%s&#34;%length.strip()))
                        self.chunk_size = length
                        chunk = True
                else:
                        length = int(self.headers.get(b&#34;Content-Length&#34;,b&#34;0&#34;))
                        chunk = False
                await self.read_data(length, streamio, chunk)

        async def read_data(self, length, streamio, chunk=False):
                &#34;&#34;&#34; Read data with length &#34;&#34;&#34;
                # If data small write in memory
                if length &lt; 4096:
                        if chunk is False or self.content is None:
                                self.content = b&#34;&#34;
                        data = b&#34;&#34;
                        while len(data) &lt; length:
                                data += await streamio.read(length - len(data))
                        self.content += data
                # Data too big write in file
                else:
                        self.content_file = &#34;%d.tmp&#34;%id(self)

                        print(&#34;Begin upload reception&#34;)
                        if chunk is False:
                                attrib = &#34;wb&#34;
                        else:
                                attrib = &#34;ab&#34;
                        with open(self.content_file, attrib) as content:
                                while content.tell() &lt; length:
                                        buffer = await streamio.read(length - content.tell())
                                        content.write(buffer)
                                        length_read = content.tell()
                                        print(&#34;  %d%% received&#34;%(length_read*100 // length))
                        print(&#34;End upload reception&#34;)

        def get_content_filename(self):
                &#34;&#34;&#34; Copy the content into file &#34;&#34;&#34;
                if self.content is not None:
                        self.content_file = &#34;%d.tmp&#34;%id(self)
                        with open(self.content_file, &#34;wb&#34;) as content:
                                content.write(self.content)
                        self.content = None
                return self.content_file

        async def unserialize_headers(self, streamio):
                &#34;&#34;&#34; Extract http header &#34;&#34;&#34;
                while True:
                        header = await streamio.readline()
                        if header == b&#34;\r\n&#34;:
                                if self.method == b&#34;POST&#34;:
                                        await self.read_content(streamio)
                                        self.params = server.urlparser.UrlParser.parse_params(self.content)
                                elif self.request is False or self.method == b&#34;PUT&#34;:
                                        await self.read_content(streamio)
                                break
                        name, value = header.split(b&#34;:&#34;, 1)
                        if name == b&#34;Cookie&#34;:
                                cookies = value.split(b&#34;;&#34;)
                                for cookie in cookies:
                                        cookieName,cookieValue=cookie.split(b&#34;=&#34;)
                                        self.cookies[cookieName.strip()] = cookieValue.strip()
                        else:
                                self.headers[name] = value.strip()

        async def serialize(self, streamio, page=None):
                &#34;&#34;&#34; Serialize request or response in the stream &#34;&#34;&#34;
                io = server.stream.Bufferedio(streamio)
                result = await self.serialize_header(io)
                result += await self.serialize_body(io)
                if page:
                        await page.write(io)
                await io.close()
                return result

        async def serialize_header(self, streamio):
                &#34;&#34;&#34; Serialize the header of http request or response &#34;&#34;&#34;
                if self.request:
                        result = await streamio.write(b&#34;%s %s %s\r\n&#34;%(self.method, self.path, b&#34;HTTP/1.1&#34;))
                else:
                        result = await streamio.write(b&#34;HTTP/1.1 %s NA\r\n&#34;%(self.status))

                try:
                        createIdentifier = False
                        if len(self.parts) &gt; 0:
                                createIdentifier = True
                        # If multipart request detected
                        if b&#34;multipart&#34; in self.headers[b&#34;Content-Type&#34;] :
                                createIdentifier = True
                except:
                        pass

                # If identifier required (multipart request)
                if self.identifier is None and createIdentifier:
                        self.identifier = self.get_id()

                # Serialize http header
                for header, value in self.headers.items():
                        if self.identifier is not None:
                                if header == b&#34;Content-Type&#34;:
                                        value += b&#34;; boundary=%s&#34;%self.identifier
                        result += await streamio.write(b&#34;%s: %s\r\n&#34;%(header, value))

                # Serialize cookies
                for name, value in self.cookies.items():
                        if self.request:
                                setget = b&#34;&#34;
                        else:
                                setget = b&#34;Set-&#34;

                        http_only = b&#34;&#34;
                        if len(value) &gt;= 3:
                                if value[2] is True:
                                        http_only = b&#34;; HttpOnly&#34;
                                if name == b&#34;session&#34;:
                                        http_only += b&#34;; Path=/&#34;
                        result += await streamio.write(b&#34;%sCookie: %s=%s%s%s\r\n&#34;%(setget, name, value[0], self.get_expiration(value[1]), http_only))
                return result

        async def serialize_body(self, streamio):
                &#34;&#34;&#34; Serialize body &#34;&#34;&#34;
                result = 0
                no_end = False
                # If content existing
                if self.content is not None:
                        try:
                                # If content is a bytes string
                                if type(self.content) == type(b&#34;&#34;):
                                        result += await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                                        result += await streamio.write(self.content)
                                else:
                                        # Serialize object
                                        result += await self.content.serialize(streamio)
                                        no_end = True
                        except Exception as err:
                                tools.logger.syslog(err)
                                # Serialize error detected
                                result += await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                                result += await streamio.write(tools.strings.tostrings(tools.logger.exception(err)))
                # If multipart detected
                elif len(self.parts) &gt; 0:
                        # If the header is a multipart
                        if self.headers[b&#34;Content-Type&#34;] == b&#34;multipart/form-data&#34;:
                                length = 0
                                # Set the size of identifier
                                for part in self.parts:
                                        length += 2
                                        length += await part.get_size(self.identifier)
                                length += len(self.identifier)
                                length += 6

                                # Write multipart identifier
                                result += await streamio.write(b&#34;Content-Length: %d\r\n\r\n&#34;%(length))
                                result += await streamio.write(b&#34;--%s&#34;%self.identifier)

                        # Serialize all parts of the multipart
                        for part in self.parts:
                                result += await streamio.write(b&#34;\r\n&#34;)
                                result += await part.serialize(self.identifier, streamio)

                        # Terminate multipart request
                        if self.headers[b&#34;Content-Type&#34;] != b&#34;multipart/x-mixed-replace&#34;:
                                result += await streamio.write(b&#34;--&#34;)

                if no_end is False:
                        # Terminate serialize request or response
                        result += await streamio.write(b&#34;\r\n&#34;)
                return result

class ContentText:
        &#34;&#34;&#34; Class that contains a text &#34;&#34;&#34;
        def __init__(self, text, content_type=None):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.text = text
                self.content_type = content_type
                if content_type is None:
                        self.content_type = b&#34;text/plain&#34;

        async def serialize(self, streamio):
                &#34;&#34;&#34; Serialize text content &#34;&#34;&#34;
                result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
                result += await streamio.write(self.text)
                return result

class ContentFile:
        &#34;&#34;&#34; Class that contains a file &#34;&#34;&#34;
        def __init__(self, filename, content_type=None, base64=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                # pylint:disable=global-variable-not-assigned
                if type(filename) == type([]):
                        self.filenames = filename
                else:
                        self.filenames = [filename]
                self.base64 = base64
                if content_type is None:
                        global MIMES
                        ext = tools.filesystem.splitext(tools.strings.tostrings(self.filenames[0]))[1]
                        self.content_type = MIMES.get(tools.strings.tobytes(ext),b&#34;text/plain&#34;)
                else:
                        self.content_type = content_type

        async def serialize_file(self, filename, streamio):
                &#34;&#34;&#34; Serialize the content of file named filename &#34;&#34;&#34;
                result = 0
                found = False

                filename = tools.strings.tostrings(filename)

                # If file existing
                if tools.filesystem.exists(filename):
                        with open(tools.strings.tostrings(filename), &#34;rb&#34;) as f:
                                found = True
                                result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
                                if server.stream.Bufferedio.is_enough_memory():
                                        step = 1440*10
                                else:
                                        step = 512
                                buf = bytearray(step)
                                f.seek(0,2)
                                size = f.tell()
                                f.seek(0)

                                if self.base64 and step % 3 != 0:
                                        step = (step//3)*3

                                length_written = 0

                                while size &gt; 0:
                                        if size &lt; step:
                                                buf = bytearray(size)
                                        length = f.readinto(buf)
                                        size -= length
                                        if self.base64:
                                                length_written += await streamio.write(b2a_base64(buf))
                                        else:
                                                length_written += await streamio.write(buf)
                                result += length_written
                else:
                        tools.logger.syslog(&#34;%s file not found&#34;%filename)
                return result, found

        async def serialize(self, streamio):
                &#34;&#34;&#34; Serialize file &#34;&#34;&#34;
                found = False
                result = 0
                try:
                        # print(&#34;Begin send %s&#34;%tools.strings.tostrings(self.filename))
                        for filename in self.filenames:
                                r, f = await self.serialize_file(filename, streamio)
                                result += r
                                if f:
                                        found = True
                        # print(&#34;End send %s&#34;%tools.strings.tostrings(self.filename))
                except Exception as err:
                        pass
                if found is False:
                        result = await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                        filenames = b&#34;&#34;
                        for filename in self.filenames:
                                filenames += tools.strings.tobytes(filename) + b&#34; &#34;
                        result += await streamio.write(b&#34;File %s not found&#34;%tools.strings.tobytes(filename))
                return result

class ContentBuffer:
        &#34;&#34;&#34; Class that contains a buffer &#34;&#34;&#34;
        def __init__(self, filename, buffer, content_type=None):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                # pylint:disable=global-variable-not-assigned
                self.filename = filename
                self.buffer = buffer
                if content_type is None:
                        global MIMES
                        ext = tools.filesystem.splitext(tools.strings.tostrings(filename))[1]
                        self.content_type = MIMES.get(tools.strings.tobytes(ext),b&#34;text/plain&#34;)
                else:
                        self.content_type = content_type

        async def serialize(self, streamio):
                &#34;&#34;&#34; Serialize a buffer &#34;&#34;&#34;
                try:
                        b = self.buffer[0]
                        result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
                        result += await streamio.write(tools.strings.tobytes(self.buffer))
                except Exception as err:
                        result = await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                        result += await streamio.write(b&#34;Nothing&#34;)
                return result

class PartText:
        &#34;&#34;&#34; Class that contains a text, used in multipart request or response &#34;&#34;&#34;
        def __init__(self, name, value):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.name  = name
                self.value = value

        async def serialize(self, identifier, streamio):
                &#34;&#34;&#34; Serialize multipart text part &#34;&#34;&#34;
                result = await streamio.write(b&#39;Content-Disposition: form-data; name=&#34;%s&#34;\r\n&#39;%(self.name))
                result += await streamio.write(b&#39;Content-Type: text/plain \r\n&#39;)
                result += await streamio.write(b&#34;\r\n%s\r\n&#34;%self.value)
                result += await streamio.write(b&#34;--%s&#34;%identifier)
                return result

        async def get_size(self, identifier):
                &#34;&#34;&#34; Get the size of this part &#34;&#34;&#34;
                result = await self.serialize(identifier, server.stream.Bytesio())
                return result

class PartFile:
        &#34;&#34;&#34; Class that contains a file, used in multipart request or response &#34;&#34;&#34;
        def __init__(self, name, filename, content_type):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.name = name
                self.filename = filename
                self.content_type = content_type

        async def serialize_header(self, identifier, streamio):
                &#34;&#34;&#34; Serialize multi part header of file &#34;&#34;&#34;
                result = await streamio.write(b&#39;Content-Disposition: form-data; name=&#34;%s&#34;; filename=&#34;%s&#34;\r\n&#39;%(self.name, self.filename))
                result += await streamio.write(b&#39;Content-Type: %s\r\n&#39;%self.content_type)
                return result

        async def serialize(self, identifier, streamio):
                &#34;&#34;&#34; Serialize multi part file &#34;&#34;&#34;
                result = await self.serialize_header(identifier, streamio)
                with open(tools.strings.tostrings(self.filename),&#34;rb&#34;) as file:
                        part = file.read()
                result += await streamio.write(b&#34;\r\n%s\r\n&#34;%part)
                result +=  await streamio.write(b&#34;--%s&#34;%identifier)
                return result

        async def get_size(self, identifier):
                &#34;&#34;&#34; Get the size of multi part file &#34;&#34;&#34;
                header_size = await self.serialize_header(identifier, server.stream.Bytesio())
                file_size = tools.filesystem.filesize((tools.strings.tostrings(self.filename)))
                return header_size + file_size + 4 + len(identifier) + 2

class PartBin(PartFile):
        &#34;&#34;&#34; Class that contains a binary data, used in multipart request or response &#34;&#34;&#34;
        def __init__(self, name, filename, binary, content_type):
                PartFile.__init__(self, name, filename, content_type)
                self.binary = binary

        async def serialize(self, identifier, streamio):
                &#34;&#34;&#34; Serialize multi part binary data &#34;&#34;&#34;
                result = await self.serialize_header(identifier, streamio)
                result += await streamio.write(b&#34;\r\n%s\r\n&#34;%self.binary)
                result +=  await streamio.write(b&#34;--%s&#34;%identifier)
                return result

        async def get_size(self, identifier):
                &#34;&#34;&#34; Get the size of multi part binary data &#34;&#34;&#34;
                headerSize = await self.serialize_header(identifier, server.stream.Bytesio())
                fileSize = len(self.binary)
                return headerSize + fileSize + 4 + len(identifier) + 2

class HttpResponse(Http):
        &#34;&#34;&#34; Http response send to web browser client &#34;&#34;&#34;
        def __init__(self, streamio, remoteaddr= b&#34;&#34;, port = 0, name = &#34;&#34;):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                Http.__init__(self, request=False, remoteaddr=remoteaddr, port=port, name=name)
                self.chunk_size = 0
                self.streamio = streamio

        async def send(self, content=None, status=b&#34;200&#34;, headers=None):
                &#34;&#34;&#34; Send response to client web browser &#34;&#34;&#34;
                if headers is None:
                        headers = {}
                self.set_content(content)
                self.set_status(status)
                if headers is not None:
                        for name, value in headers.items():
                                self.set_header(name, value)
                return await self.serialize(self.streamio)

        async def send_error(self, status, content=None):
                &#34;&#34;&#34; Send error to the client web browser &#34;&#34;&#34;
                return await self.send(status=status, content=content)

        async def send_not_found(self, err=None):
                &#34;&#34;&#34; Send page not found &#34;&#34;&#34;
                if err is None:
                        content = b&#34;&#34;
                elif type(err) == type(b&#34;&#34;) or type(err) == type(&#34;&#34;):
                        content = tools.strings.tobytes(err)
                else:
                        content = tools.strings.tobytes(tools.logger.exception(err))
                return await self.send_error(status=b&#34;404&#34;, content=content)

        async def send_ok(self, content=None):
                &#34;&#34;&#34; Send ok to the client web browser &#34;&#34;&#34;
                return await self.send_error(status=b&#34;200&#34;, content=content)

        async def send_file(self, filename, mime_type=None, headers=None, base64=False):
                &#34;&#34;&#34; Send a file to the client web browser &#34;&#34;&#34;
                return await self.send(content=ContentFile(filename, mime_type, base64), status=b&#34;200&#34;, headers=headers)

        async def send_buffer(self, filename, buffer, mime_type=None, headers=None):
                &#34;&#34;&#34; Send a file to the client web browser &#34;&#34;&#34;
                return await self.send(content=ContentBuffer(filename, buffer, mime_type), status=b&#34;200&#34;, headers=headers)

        async def send_page(self, page):
                &#34;&#34;&#34; Send a template page to the client web browser &#34;&#34;&#34;
                self.set_content(None)
                self.set_status(b&#34;200&#34;)
                await self.serialize(self.streamio, page)

        async def receive(self, streamio=None):
                &#34;&#34;&#34; Receive request from client &#34;&#34;&#34;
                if streamio is None:
                        streamio = self.streamio
                await self.unserialize(streamio)

class HttpRequest(Http):
        &#34;&#34;&#34; Http request received from web browser client &#34;&#34;&#34;
        def __init__(self, streamio, remoteaddr= b&#34;&#34;, port = 0, name=&#34;&#34;):
                &#34;&#34;&#34; Constructor from http request &#34;&#34;&#34;
                Http.__init__(self, request=True, remoteaddr=remoteaddr, port=port, name=name)
                self.streamio    = streamio

        async def receive(self, streamio=None):
                &#34;&#34;&#34; Receive request from client &#34;&#34;&#34;
                if streamio is None:
                        streamio = self.streamio
                await self.unserialize(streamio)

        async def send(self, streamio=None):
                &#34;&#34;&#34; Send request to server &#34;&#34;&#34;
                if streamio is None:
                        streamio = self.streamio
                await self.serialize(streamio)

        @staticmethod
        def to_html(message):
                &#34;&#34;&#34; Convert message with special characters into html text &#34;&#34;&#34;
                result = b&#34;&#34;
                for char in message:
                        if (char &gt;= 0x30 and char &lt;= 0x39) or \
                           (char &gt;= 0x41 and char &lt;= 0x5A) or \
                           (char &gt;= 0x61 and char &lt;= 0x7A):
                                result += char.to_bytes(1,&#34;big&#34;)
                        else:
                                result += b&#34;&amp;#%d;&#34;%char
                return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.server.httprequest.ContentBuffer"><code class="flex name class">
<span>class <span class="ident">ContentBuffer</span></span>
<span>(</span><span>filename, buffer, content_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that contains a buffer </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContentBuffer:
        &#34;&#34;&#34; Class that contains a buffer &#34;&#34;&#34;
        def __init__(self, filename, buffer, content_type=None):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                # pylint:disable=global-variable-not-assigned
                self.filename = filename
                self.buffer = buffer
                if content_type is None:
                        global MIMES
                        ext = tools.filesystem.splitext(tools.strings.tostrings(filename))[1]
                        self.content_type = MIMES.get(tools.strings.tobytes(ext),b&#34;text/plain&#34;)
                else:
                        self.content_type = content_type

        async def serialize(self, streamio):
                &#34;&#34;&#34; Serialize a buffer &#34;&#34;&#34;
                try:
                        b = self.buffer[0]
                        result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
                        result += await streamio.write(tools.strings.tobytes(self.buffer))
                except Exception as err:
                        result = await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                        result += await streamio.write(b&#34;Nothing&#34;)
                return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.ContentBuffer.serialize"><code class="name flex">
<span>async def <span class="ident">serialize</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize a buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize(self, streamio):
        &#34;&#34;&#34; Serialize a buffer &#34;&#34;&#34;
        try:
                b = self.buffer[0]
                result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
                result += await streamio.write(tools.strings.tobytes(self.buffer))
        except Exception as err:
                result = await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                result += await streamio.write(b&#34;Nothing&#34;)
        return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.httprequest.ContentFile"><code class="flex name class">
<span>class <span class="ident">ContentFile</span></span>
<span>(</span><span>filename, content_type=None, base64=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that contains a file </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContentFile:
        &#34;&#34;&#34; Class that contains a file &#34;&#34;&#34;
        def __init__(self, filename, content_type=None, base64=False):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                # pylint:disable=global-variable-not-assigned
                if type(filename) == type([]):
                        self.filenames = filename
                else:
                        self.filenames = [filename]
                self.base64 = base64
                if content_type is None:
                        global MIMES
                        ext = tools.filesystem.splitext(tools.strings.tostrings(self.filenames[0]))[1]
                        self.content_type = MIMES.get(tools.strings.tobytes(ext),b&#34;text/plain&#34;)
                else:
                        self.content_type = content_type

        async def serialize_file(self, filename, streamio):
                &#34;&#34;&#34; Serialize the content of file named filename &#34;&#34;&#34;
                result = 0
                found = False

                filename = tools.strings.tostrings(filename)

                # If file existing
                if tools.filesystem.exists(filename):
                        with open(tools.strings.tostrings(filename), &#34;rb&#34;) as f:
                                found = True
                                result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
                                if server.stream.Bufferedio.is_enough_memory():
                                        step = 1440*10
                                else:
                                        step = 512
                                buf = bytearray(step)
                                f.seek(0,2)
                                size = f.tell()
                                f.seek(0)

                                if self.base64 and step % 3 != 0:
                                        step = (step//3)*3

                                length_written = 0

                                while size &gt; 0:
                                        if size &lt; step:
                                                buf = bytearray(size)
                                        length = f.readinto(buf)
                                        size -= length
                                        if self.base64:
                                                length_written += await streamio.write(b2a_base64(buf))
                                        else:
                                                length_written += await streamio.write(buf)
                                result += length_written
                else:
                        tools.logger.syslog(&#34;%s file not found&#34;%filename)
                return result, found

        async def serialize(self, streamio):
                &#34;&#34;&#34; Serialize file &#34;&#34;&#34;
                found = False
                result = 0
                try:
                        # print(&#34;Begin send %s&#34;%tools.strings.tostrings(self.filename))
                        for filename in self.filenames:
                                r, f = await self.serialize_file(filename, streamio)
                                result += r
                                if f:
                                        found = True
                        # print(&#34;End send %s&#34;%tools.strings.tostrings(self.filename))
                except Exception as err:
                        pass
                if found is False:
                        result = await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                        filenames = b&#34;&#34;
                        for filename in self.filenames:
                                filenames += tools.strings.tobytes(filename) + b&#34; &#34;
                        result += await streamio.write(b&#34;File %s not found&#34;%tools.strings.tobytes(filename))
                return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.ContentFile.serialize"><code class="name flex">
<span>async def <span class="ident">serialize</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize(self, streamio):
        &#34;&#34;&#34; Serialize file &#34;&#34;&#34;
        found = False
        result = 0
        try:
                # print(&#34;Begin send %s&#34;%tools.strings.tostrings(self.filename))
                for filename in self.filenames:
                        r, f = await self.serialize_file(filename, streamio)
                        result += r
                        if f:
                                found = True
                # print(&#34;End send %s&#34;%tools.strings.tostrings(self.filename))
        except Exception as err:
                pass
        if found is False:
                result = await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                filenames = b&#34;&#34;
                for filename in self.filenames:
                        filenames += tools.strings.tobytes(filename) + b&#34; &#34;
                result += await streamio.write(b&#34;File %s not found&#34;%tools.strings.tobytes(filename))
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.ContentFile.serialize_file"><code class="name flex">
<span>async def <span class="ident">serialize_file</span></span>(<span>self, filename, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize the content of file named filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize_file(self, filename, streamio):
        &#34;&#34;&#34; Serialize the content of file named filename &#34;&#34;&#34;
        result = 0
        found = False

        filename = tools.strings.tostrings(filename)

        # If file existing
        if tools.filesystem.exists(filename):
                with open(tools.strings.tostrings(filename), &#34;rb&#34;) as f:
                        found = True
                        result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
                        if server.stream.Bufferedio.is_enough_memory():
                                step = 1440*10
                        else:
                                step = 512
                        buf = bytearray(step)
                        f.seek(0,2)
                        size = f.tell()
                        f.seek(0)

                        if self.base64 and step % 3 != 0:
                                step = (step//3)*3

                        length_written = 0

                        while size &gt; 0:
                                if size &lt; step:
                                        buf = bytearray(size)
                                length = f.readinto(buf)
                                size -= length
                                if self.base64:
                                        length_written += await streamio.write(b2a_base64(buf))
                                else:
                                        length_written += await streamio.write(buf)
                        result += length_written
        else:
                tools.logger.syslog(&#34;%s file not found&#34;%filename)
        return result, found</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.httprequest.ContentText"><code class="flex name class">
<span>class <span class="ident">ContentText</span></span>
<span>(</span><span>text, content_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that contains a text </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContentText:
        &#34;&#34;&#34; Class that contains a text &#34;&#34;&#34;
        def __init__(self, text, content_type=None):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.text = text
                self.content_type = content_type
                if content_type is None:
                        self.content_type = b&#34;text/plain&#34;

        async def serialize(self, streamio):
                &#34;&#34;&#34; Serialize text content &#34;&#34;&#34;
                result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
                result += await streamio.write(self.text)
                return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.ContentText.serialize"><code class="name flex">
<span>async def <span class="ident">serialize</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize text content</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize(self, streamio):
        &#34;&#34;&#34; Serialize text content &#34;&#34;&#34;
        result = await streamio.write(b&#39;Content-Type: %s\r\n\r\n&#39;%(self.content_type))
        result += await streamio.write(self.text)
        return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.httprequest.Http"><code class="flex name class">
<span>class <span class="ident">Http</span></span>
<span>(</span><span>request=True, remoteaddr=b'', port=0, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Http request or reponse </p>
<p>Constructor from http request or response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Http:
        &#34;&#34;&#34; Http request or reponse &#34;&#34;&#34;
        def __init__(self, request = True, remoteaddr= b&#34;&#34;, port = 0, name=&#34;&#34;):
                &#34;&#34;&#34; Constructor from http request or response &#34;&#34;&#34;
                self.port       = port
                self.name       = name
                self.remoteaddr = remoteaddr
                self.path       = b&#34;&#34;
                self.method     = b&#34;POST&#34;
                self.headers    = collections.OrderedDict()
                self.params     = collections.OrderedDict()
                self.cookies    = collections.OrderedDict()
                self.parts      = []
                self.status     = 0
                self.content    = None
                self.content_file = None
                self.identifier = None
                self.request    = request
                self.chunk_size = 0

        def __del__(self):
                if self.content_file is not None:
                        tools.filesystem.remove(self.content_file)

        def get_expiration(self, expiration):
                &#34;&#34;&#34; Get cookie expiration date &#34;&#34;&#34;
                result = b&#34;; Max-Age=%d&#34;%expiration
                return result

        def get_cookie(self, name):
                &#34;&#34;&#34; Get cookie value &#34;&#34;&#34;
                try:
                        return self.cookies.get(name, None)
                except:
                        return None

        def set_cookie(self, name, value=None, expiration=None, http_only=False):
                &#34;&#34;&#34; Set cookie &#34;&#34;&#34;
                if value is None:
                        if name in self.cookies:
                                del self.cookies[name]
                else:
                        self.cookies[name] = (value, expiration, http_only)

        def get_header(self, name):
                &#34;&#34;&#34; Get the http request header &#34;&#34;&#34;
                try:
                        return self.headers.get(name, None)
                except:
                        return None

        def set_header(self, name, value):
                &#34;&#34;&#34; Set the http request header &#34;&#34;&#34;
                if value is None:
                        del self.headers[name]
                else:
                        self.headers[name] = value

        def set_method(self, method):
                &#34;&#34;&#34; Set http request method (POST or GET) &#34;&#34;&#34;
                self.method = method

        def get_path(self):
                &#34;&#34;&#34; Get the path of the request or response &#34;&#34;&#34;
                return self.path

        def set_path(self, path):
                &#34;&#34;&#34; Define the past of the request or response &#34;&#34;&#34;
                self.path = path

        def add_part(self, part):
                &#34;&#34;&#34; Add part of the request. Used for multipart request &#34;&#34;&#34;
                self.parts.append(part)

        def get_status(self):
                &#34;&#34;&#34; Get the status value &#34;&#34;&#34;
                return self.status

        def set_status(self, status):
                &#34;&#34;&#34; Set the status value &#34;&#34;&#34;
                self.status = status

        def set_content(self, content):
                &#34;&#34;&#34; Set the content of the request or response (can be an instance of html template) &#34;&#34;&#34;
                if type(content) == type(&#34;&#34;):
                        self.content = ContentText(content)
                else:
                        self.content = content

        def get_content(self):
                &#34;&#34;&#34; Get the content of the request or response &#34;&#34;&#34;
                return self.content

        def get_id(self):
                &#34;&#34;&#34; Get the unique identifier of the request or response. Used for multipart request &#34;&#34;&#34;
                hash_ = hashlib.sha256()
                ids = b&#34;%d&#34;%time.time()
                hash_.update(ids)
                return hexlify(hash_.digest())[32:]

        async def unserialize(self, streamio):
                &#34;&#34;&#34; Unserialize the request or response in the stream &#34;&#34;&#34;
                data = await streamio.readline()
                if data != b&#34;&#34;:
                        urlparser = server.urlparser.UrlParser(data, True)
                        spl = data.split()
                        if len(spl) &gt;= 2:
                                self.method = urlparser.method
                                path = spl[1]
                                if self.request is False:
                                        self.status = path
                                self.path   = urlparser.path
                                self.params = urlparser.params
                                await self.unserialize_headers(streamio)
                        else:
                                await self.read_content(streamio)

        async def read_content(self, streamio):
                &#34;&#34;&#34; Read the content of http request &#34;&#34;&#34;
                if self.headers.get(b&#34;Transfer-Encoding&#34;,b&#34;&#34;) == b&#34;chunked&#34;:
                        length = await streamio.readline()
                        length = eval(tools.strings.tostrings(b&#34;0x%s&#34;%length.strip()))
                        self.chunk_size = length
                        chunk = True
                else:
                        length = int(self.headers.get(b&#34;Content-Length&#34;,b&#34;0&#34;))
                        chunk = False
                await self.read_data(length, streamio, chunk)

        async def read_data(self, length, streamio, chunk=False):
                &#34;&#34;&#34; Read data with length &#34;&#34;&#34;
                # If data small write in memory
                if length &lt; 4096:
                        if chunk is False or self.content is None:
                                self.content = b&#34;&#34;
                        data = b&#34;&#34;
                        while len(data) &lt; length:
                                data += await streamio.read(length - len(data))
                        self.content += data
                # Data too big write in file
                else:
                        self.content_file = &#34;%d.tmp&#34;%id(self)

                        print(&#34;Begin upload reception&#34;)
                        if chunk is False:
                                attrib = &#34;wb&#34;
                        else:
                                attrib = &#34;ab&#34;
                        with open(self.content_file, attrib) as content:
                                while content.tell() &lt; length:
                                        buffer = await streamio.read(length - content.tell())
                                        content.write(buffer)
                                        length_read = content.tell()
                                        print(&#34;  %d%% received&#34;%(length_read*100 // length))
                        print(&#34;End upload reception&#34;)

        def get_content_filename(self):
                &#34;&#34;&#34; Copy the content into file &#34;&#34;&#34;
                if self.content is not None:
                        self.content_file = &#34;%d.tmp&#34;%id(self)
                        with open(self.content_file, &#34;wb&#34;) as content:
                                content.write(self.content)
                        self.content = None
                return self.content_file

        async def unserialize_headers(self, streamio):
                &#34;&#34;&#34; Extract http header &#34;&#34;&#34;
                while True:
                        header = await streamio.readline()
                        if header == b&#34;\r\n&#34;:
                                if self.method == b&#34;POST&#34;:
                                        await self.read_content(streamio)
                                        self.params = server.urlparser.UrlParser.parse_params(self.content)
                                elif self.request is False or self.method == b&#34;PUT&#34;:
                                        await self.read_content(streamio)
                                break
                        name, value = header.split(b&#34;:&#34;, 1)
                        if name == b&#34;Cookie&#34;:
                                cookies = value.split(b&#34;;&#34;)
                                for cookie in cookies:
                                        cookieName,cookieValue=cookie.split(b&#34;=&#34;)
                                        self.cookies[cookieName.strip()] = cookieValue.strip()
                        else:
                                self.headers[name] = value.strip()

        async def serialize(self, streamio, page=None):
                &#34;&#34;&#34; Serialize request or response in the stream &#34;&#34;&#34;
                io = server.stream.Bufferedio(streamio)
                result = await self.serialize_header(io)
                result += await self.serialize_body(io)
                if page:
                        await page.write(io)
                await io.close()
                return result

        async def serialize_header(self, streamio):
                &#34;&#34;&#34; Serialize the header of http request or response &#34;&#34;&#34;
                if self.request:
                        result = await streamio.write(b&#34;%s %s %s\r\n&#34;%(self.method, self.path, b&#34;HTTP/1.1&#34;))
                else:
                        result = await streamio.write(b&#34;HTTP/1.1 %s NA\r\n&#34;%(self.status))

                try:
                        createIdentifier = False
                        if len(self.parts) &gt; 0:
                                createIdentifier = True
                        # If multipart request detected
                        if b&#34;multipart&#34; in self.headers[b&#34;Content-Type&#34;] :
                                createIdentifier = True
                except:
                        pass

                # If identifier required (multipart request)
                if self.identifier is None and createIdentifier:
                        self.identifier = self.get_id()

                # Serialize http header
                for header, value in self.headers.items():
                        if self.identifier is not None:
                                if header == b&#34;Content-Type&#34;:
                                        value += b&#34;; boundary=%s&#34;%self.identifier
                        result += await streamio.write(b&#34;%s: %s\r\n&#34;%(header, value))

                # Serialize cookies
                for name, value in self.cookies.items():
                        if self.request:
                                setget = b&#34;&#34;
                        else:
                                setget = b&#34;Set-&#34;

                        http_only = b&#34;&#34;
                        if len(value) &gt;= 3:
                                if value[2] is True:
                                        http_only = b&#34;; HttpOnly&#34;
                                if name == b&#34;session&#34;:
                                        http_only += b&#34;; Path=/&#34;
                        result += await streamio.write(b&#34;%sCookie: %s=%s%s%s\r\n&#34;%(setget, name, value[0], self.get_expiration(value[1]), http_only))
                return result

        async def serialize_body(self, streamio):
                &#34;&#34;&#34; Serialize body &#34;&#34;&#34;
                result = 0
                no_end = False
                # If content existing
                if self.content is not None:
                        try:
                                # If content is a bytes string
                                if type(self.content) == type(b&#34;&#34;):
                                        result += await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                                        result += await streamio.write(self.content)
                                else:
                                        # Serialize object
                                        result += await self.content.serialize(streamio)
                                        no_end = True
                        except Exception as err:
                                tools.logger.syslog(err)
                                # Serialize error detected
                                result += await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                                result += await streamio.write(tools.strings.tostrings(tools.logger.exception(err)))
                # If multipart detected
                elif len(self.parts) &gt; 0:
                        # If the header is a multipart
                        if self.headers[b&#34;Content-Type&#34;] == b&#34;multipart/form-data&#34;:
                                length = 0
                                # Set the size of identifier
                                for part in self.parts:
                                        length += 2
                                        length += await part.get_size(self.identifier)
                                length += len(self.identifier)
                                length += 6

                                # Write multipart identifier
                                result += await streamio.write(b&#34;Content-Length: %d\r\n\r\n&#34;%(length))
                                result += await streamio.write(b&#34;--%s&#34;%self.identifier)

                        # Serialize all parts of the multipart
                        for part in self.parts:
                                result += await streamio.write(b&#34;\r\n&#34;)
                                result += await part.serialize(self.identifier, streamio)

                        # Terminate multipart request
                        if self.headers[b&#34;Content-Type&#34;] != b&#34;multipart/x-mixed-replace&#34;:
                                result += await streamio.write(b&#34;--&#34;)

                if no_end is False:
                        # Terminate serialize request or response
                        result += await streamio.write(b&#34;\r\n&#34;)
                return result</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lib.server.httprequest.HttpRequest" href="#lib.server.httprequest.HttpRequest">HttpRequest</a></li>
<li><a title="lib.server.httprequest.HttpResponse" href="#lib.server.httprequest.HttpResponse">HttpResponse</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.Http.add_part"><code class="name flex">
<span>def <span class="ident">add_part</span></span>(<span>self, part)</span>
</code></dt>
<dd>
<div class="desc"><p>Add part of the request. Used for multipart request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_part(self, part):
        &#34;&#34;&#34; Add part of the request. Used for multipart request &#34;&#34;&#34;
        self.parts.append(part)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.get_content"><code class="name flex">
<span>def <span class="ident">get_content</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the content of the request or response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content(self):
        &#34;&#34;&#34; Get the content of the request or response &#34;&#34;&#34;
        return self.content</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.get_content_filename"><code class="name flex">
<span>def <span class="ident">get_content_filename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy the content into file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_content_filename(self):
        &#34;&#34;&#34; Copy the content into file &#34;&#34;&#34;
        if self.content is not None:
                self.content_file = &#34;%d.tmp&#34;%id(self)
                with open(self.content_file, &#34;wb&#34;) as content:
                        content.write(self.content)
                self.content = None
        return self.content_file</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.get_cookie"><code class="name flex">
<span>def <span class="ident">get_cookie</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cookie value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cookie(self, name):
        &#34;&#34;&#34; Get cookie value &#34;&#34;&#34;
        try:
                return self.cookies.get(name, None)
        except:
                return None</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.get_expiration"><code class="name flex">
<span>def <span class="ident">get_expiration</span></span>(<span>self, expiration)</span>
</code></dt>
<dd>
<div class="desc"><p>Get cookie expiration date</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expiration(self, expiration):
        &#34;&#34;&#34; Get cookie expiration date &#34;&#34;&#34;
        result = b&#34;; Max-Age=%d&#34;%expiration
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.get_header"><code class="name flex">
<span>def <span class="ident">get_header</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the http request header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_header(self, name):
        &#34;&#34;&#34; Get the http request header &#34;&#34;&#34;
        try:
                return self.headers.get(name, None)
        except:
                return None</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.get_id"><code class="name flex">
<span>def <span class="ident">get_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the unique identifier of the request or response. Used for multipart request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_id(self):
        &#34;&#34;&#34; Get the unique identifier of the request or response. Used for multipart request &#34;&#34;&#34;
        hash_ = hashlib.sha256()
        ids = b&#34;%d&#34;%time.time()
        hash_.update(ids)
        return hexlify(hash_.digest())[32:]</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.get_path"><code class="name flex">
<span>def <span class="ident">get_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the path of the request or response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path(self):
        &#34;&#34;&#34; Get the path of the request or response &#34;&#34;&#34;
        return self.path</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the status value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self):
        &#34;&#34;&#34; Get the status value &#34;&#34;&#34;
        return self.status</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.read_content"><code class="name flex">
<span>async def <span class="ident">read_content</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the content of http request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def read_content(self, streamio):
        &#34;&#34;&#34; Read the content of http request &#34;&#34;&#34;
        if self.headers.get(b&#34;Transfer-Encoding&#34;,b&#34;&#34;) == b&#34;chunked&#34;:
                length = await streamio.readline()
                length = eval(tools.strings.tostrings(b&#34;0x%s&#34;%length.strip()))
                self.chunk_size = length
                chunk = True
        else:
                length = int(self.headers.get(b&#34;Content-Length&#34;,b&#34;0&#34;))
                chunk = False
        await self.read_data(length, streamio, chunk)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.read_data"><code class="name flex">
<span>async def <span class="ident">read_data</span></span>(<span>self, length, streamio, chunk=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read data with length</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def read_data(self, length, streamio, chunk=False):
        &#34;&#34;&#34; Read data with length &#34;&#34;&#34;
        # If data small write in memory
        if length &lt; 4096:
                if chunk is False or self.content is None:
                        self.content = b&#34;&#34;
                data = b&#34;&#34;
                while len(data) &lt; length:
                        data += await streamio.read(length - len(data))
                self.content += data
        # Data too big write in file
        else:
                self.content_file = &#34;%d.tmp&#34;%id(self)

                print(&#34;Begin upload reception&#34;)
                if chunk is False:
                        attrib = &#34;wb&#34;
                else:
                        attrib = &#34;ab&#34;
                with open(self.content_file, attrib) as content:
                        while content.tell() &lt; length:
                                buffer = await streamio.read(length - content.tell())
                                content.write(buffer)
                                length_read = content.tell()
                                print(&#34;  %d%% received&#34;%(length_read*100 // length))
                print(&#34;End upload reception&#34;)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.serialize"><code class="name flex">
<span>async def <span class="ident">serialize</span></span>(<span>self, streamio, page=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize request or response in the stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize(self, streamio, page=None):
        &#34;&#34;&#34; Serialize request or response in the stream &#34;&#34;&#34;
        io = server.stream.Bufferedio(streamio)
        result = await self.serialize_header(io)
        result += await self.serialize_body(io)
        if page:
                await page.write(io)
        await io.close()
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.serialize_body"><code class="name flex">
<span>async def <span class="ident">serialize_body</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize body</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize_body(self, streamio):
        &#34;&#34;&#34; Serialize body &#34;&#34;&#34;
        result = 0
        no_end = False
        # If content existing
        if self.content is not None:
                try:
                        # If content is a bytes string
                        if type(self.content) == type(b&#34;&#34;):
                                result += await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                                result += await streamio.write(self.content)
                        else:
                                # Serialize object
                                result += await self.content.serialize(streamio)
                                no_end = True
                except Exception as err:
                        tools.logger.syslog(err)
                        # Serialize error detected
                        result += await streamio.write(b&#39;Content-Type: text/plain\r\n\r\n&#39;)
                        result += await streamio.write(tools.strings.tostrings(tools.logger.exception(err)))
        # If multipart detected
        elif len(self.parts) &gt; 0:
                # If the header is a multipart
                if self.headers[b&#34;Content-Type&#34;] == b&#34;multipart/form-data&#34;:
                        length = 0
                        # Set the size of identifier
                        for part in self.parts:
                                length += 2
                                length += await part.get_size(self.identifier)
                        length += len(self.identifier)
                        length += 6

                        # Write multipart identifier
                        result += await streamio.write(b&#34;Content-Length: %d\r\n\r\n&#34;%(length))
                        result += await streamio.write(b&#34;--%s&#34;%self.identifier)

                # Serialize all parts of the multipart
                for part in self.parts:
                        result += await streamio.write(b&#34;\r\n&#34;)
                        result += await part.serialize(self.identifier, streamio)

                # Terminate multipart request
                if self.headers[b&#34;Content-Type&#34;] != b&#34;multipart/x-mixed-replace&#34;:
                        result += await streamio.write(b&#34;--&#34;)

        if no_end is False:
                # Terminate serialize request or response
                result += await streamio.write(b&#34;\r\n&#34;)
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.serialize_header"><code class="name flex">
<span>async def <span class="ident">serialize_header</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize the header of http request or response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize_header(self, streamio):
        &#34;&#34;&#34; Serialize the header of http request or response &#34;&#34;&#34;
        if self.request:
                result = await streamio.write(b&#34;%s %s %s\r\n&#34;%(self.method, self.path, b&#34;HTTP/1.1&#34;))
        else:
                result = await streamio.write(b&#34;HTTP/1.1 %s NA\r\n&#34;%(self.status))

        try:
                createIdentifier = False
                if len(self.parts) &gt; 0:
                        createIdentifier = True
                # If multipart request detected
                if b&#34;multipart&#34; in self.headers[b&#34;Content-Type&#34;] :
                        createIdentifier = True
        except:
                pass

        # If identifier required (multipart request)
        if self.identifier is None and createIdentifier:
                self.identifier = self.get_id()

        # Serialize http header
        for header, value in self.headers.items():
                if self.identifier is not None:
                        if header == b&#34;Content-Type&#34;:
                                value += b&#34;; boundary=%s&#34;%self.identifier
                result += await streamio.write(b&#34;%s: %s\r\n&#34;%(header, value))

        # Serialize cookies
        for name, value in self.cookies.items():
                if self.request:
                        setget = b&#34;&#34;
                else:
                        setget = b&#34;Set-&#34;

                http_only = b&#34;&#34;
                if len(value) &gt;= 3:
                        if value[2] is True:
                                http_only = b&#34;; HttpOnly&#34;
                        if name == b&#34;session&#34;:
                                http_only += b&#34;; Path=/&#34;
                result += await streamio.write(b&#34;%sCookie: %s=%s%s%s\r\n&#34;%(setget, name, value[0], self.get_expiration(value[1]), http_only))
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.set_content"><code class="name flex">
<span>def <span class="ident">set_content</span></span>(<span>self, content)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the content of the request or response (can be an instance of html template)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_content(self, content):
        &#34;&#34;&#34; Set the content of the request or response (can be an instance of html template) &#34;&#34;&#34;
        if type(content) == type(&#34;&#34;):
                self.content = ContentText(content)
        else:
                self.content = content</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.set_cookie"><code class="name flex">
<span>def <span class="ident">set_cookie</span></span>(<span>self, name, value=None, expiration=None, http_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Set cookie</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cookie(self, name, value=None, expiration=None, http_only=False):
        &#34;&#34;&#34; Set cookie &#34;&#34;&#34;
        if value is None:
                if name in self.cookies:
                        del self.cookies[name]
        else:
                self.cookies[name] = (value, expiration, http_only)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.set_header"><code class="name flex">
<span>def <span class="ident">set_header</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the http request header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_header(self, name, value):
        &#34;&#34;&#34; Set the http request header &#34;&#34;&#34;
        if value is None:
                del self.headers[name]
        else:
                self.headers[name] = value</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.set_method"><code class="name flex">
<span>def <span class="ident">set_method</span></span>(<span>self, method)</span>
</code></dt>
<dd>
<div class="desc"><p>Set http request method (POST or GET)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_method(self, method):
        &#34;&#34;&#34; Set http request method (POST or GET) &#34;&#34;&#34;
        self.method = method</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.set_path"><code class="name flex">
<span>def <span class="ident">set_path</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the past of the request or response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_path(self, path):
        &#34;&#34;&#34; Define the past of the request or response &#34;&#34;&#34;
        self.path = path</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.set_status"><code class="name flex">
<span>def <span class="ident">set_status</span></span>(<span>self, status)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the status value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_status(self, status):
        &#34;&#34;&#34; Set the status value &#34;&#34;&#34;
        self.status = status</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.unserialize"><code class="name flex">
<span>async def <span class="ident">unserialize</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Unserialize the request or response in the stream</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unserialize(self, streamio):
        &#34;&#34;&#34; Unserialize the request or response in the stream &#34;&#34;&#34;
        data = await streamio.readline()
        if data != b&#34;&#34;:
                urlparser = server.urlparser.UrlParser(data, True)
                spl = data.split()
                if len(spl) &gt;= 2:
                        self.method = urlparser.method
                        path = spl[1]
                        if self.request is False:
                                self.status = path
                        self.path   = urlparser.path
                        self.params = urlparser.params
                        await self.unserialize_headers(streamio)
                else:
                        await self.read_content(streamio)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.Http.unserialize_headers"><code class="name flex">
<span>async def <span class="ident">unserialize_headers</span></span>(<span>self, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract http header</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unserialize_headers(self, streamio):
        &#34;&#34;&#34; Extract http header &#34;&#34;&#34;
        while True:
                header = await streamio.readline()
                if header == b&#34;\r\n&#34;:
                        if self.method == b&#34;POST&#34;:
                                await self.read_content(streamio)
                                self.params = server.urlparser.UrlParser.parse_params(self.content)
                        elif self.request is False or self.method == b&#34;PUT&#34;:
                                await self.read_content(streamio)
                        break
                name, value = header.split(b&#34;:&#34;, 1)
                if name == b&#34;Cookie&#34;:
                        cookies = value.split(b&#34;;&#34;)
                        for cookie in cookies:
                                cookieName,cookieValue=cookie.split(b&#34;=&#34;)
                                self.cookies[cookieName.strip()] = cookieValue.strip()
                else:
                        self.headers[name] = value.strip()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.httprequest.HttpRequest"><code class="flex name class">
<span>class <span class="ident">HttpRequest</span></span>
<span>(</span><span>streamio, remoteaddr=b'', port=0, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Http request received from web browser client </p>
<p>Constructor from http request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpRequest(Http):
        &#34;&#34;&#34; Http request received from web browser client &#34;&#34;&#34;
        def __init__(self, streamio, remoteaddr= b&#34;&#34;, port = 0, name=&#34;&#34;):
                &#34;&#34;&#34; Constructor from http request &#34;&#34;&#34;
                Http.__init__(self, request=True, remoteaddr=remoteaddr, port=port, name=name)
                self.streamio    = streamio

        async def receive(self, streamio=None):
                &#34;&#34;&#34; Receive request from client &#34;&#34;&#34;
                if streamio is None:
                        streamio = self.streamio
                await self.unserialize(streamio)

        async def send(self, streamio=None):
                &#34;&#34;&#34; Send request to server &#34;&#34;&#34;
                if streamio is None:
                        streamio = self.streamio
                await self.serialize(streamio)

        @staticmethod
        def to_html(message):
                &#34;&#34;&#34; Convert message with special characters into html text &#34;&#34;&#34;
                result = b&#34;&#34;
                for char in message:
                        if (char &gt;= 0x30 and char &lt;= 0x39) or \
                           (char &gt;= 0x41 and char &lt;= 0x5A) or \
                           (char &gt;= 0x61 and char &lt;= 0x7A):
                                result += char.to_bytes(1,&#34;big&#34;)
                        else:
                                result += b&#34;&amp;#%d;&#34;%char
                return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.httprequest.Http" href="#lib.server.httprequest.Http">Http</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="lib.server.httprequest.HttpRequest.to_html"><code class="name flex">
<span>def <span class="ident">to_html</span></span>(<span>message)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert message with special characters into html text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_html(message):
        &#34;&#34;&#34; Convert message with special characters into html text &#34;&#34;&#34;
        result = b&#34;&#34;
        for char in message:
                if (char &gt;= 0x30 and char &lt;= 0x39) or \
                   (char &gt;= 0x41 and char &lt;= 0x5A) or \
                   (char &gt;= 0x61 and char &lt;= 0x7A):
                        result += char.to_bytes(1,&#34;big&#34;)
                else:
                        result += b&#34;&amp;#%d;&#34;%char
        return result</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.HttpRequest.receive"><code class="name flex">
<span>async def <span class="ident">receive</span></span>(<span>self, streamio=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive request from client</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive(self, streamio=None):
        &#34;&#34;&#34; Receive request from client &#34;&#34;&#34;
        if streamio is None:
                streamio = self.streamio
        await self.unserialize(streamio)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.HttpRequest.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, streamio=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send request to server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, streamio=None):
        &#34;&#34;&#34; Send request to server &#34;&#34;&#34;
        if streamio is None:
                streamio = self.streamio
        await self.serialize(streamio)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.httprequest.Http" href="#lib.server.httprequest.Http">Http</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.httprequest.Http.add_part" href="#lib.server.httprequest.Http.add_part">add_part</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_content" href="#lib.server.httprequest.Http.get_content">get_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_content_filename" href="#lib.server.httprequest.Http.get_content_filename">get_content_filename</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_cookie" href="#lib.server.httprequest.Http.get_cookie">get_cookie</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_expiration" href="#lib.server.httprequest.Http.get_expiration">get_expiration</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_header" href="#lib.server.httprequest.Http.get_header">get_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_id" href="#lib.server.httprequest.Http.get_id">get_id</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_path" href="#lib.server.httprequest.Http.get_path">get_path</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_status" href="#lib.server.httprequest.Http.get_status">get_status</a></code></li>
<li><code><a title="lib.server.httprequest.Http.read_content" href="#lib.server.httprequest.Http.read_content">read_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.read_data" href="#lib.server.httprequest.Http.read_data">read_data</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize" href="#lib.server.httprequest.Http.serialize">serialize</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize_body" href="#lib.server.httprequest.Http.serialize_body">serialize_body</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize_header" href="#lib.server.httprequest.Http.serialize_header">serialize_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_content" href="#lib.server.httprequest.Http.set_content">set_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_cookie" href="#lib.server.httprequest.Http.set_cookie">set_cookie</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_header" href="#lib.server.httprequest.Http.set_header">set_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_method" href="#lib.server.httprequest.Http.set_method">set_method</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_path" href="#lib.server.httprequest.Http.set_path">set_path</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_status" href="#lib.server.httprequest.Http.set_status">set_status</a></code></li>
<li><code><a title="lib.server.httprequest.Http.unserialize" href="#lib.server.httprequest.Http.unserialize">unserialize</a></code></li>
<li><code><a title="lib.server.httprequest.Http.unserialize_headers" href="#lib.server.httprequest.Http.unserialize_headers">unserialize_headers</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.httprequest.HttpResponse"><code class="flex name class">
<span>class <span class="ident">HttpResponse</span></span>
<span>(</span><span>streamio, remoteaddr=b'', port=0, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Http response send to web browser client </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpResponse(Http):
        &#34;&#34;&#34; Http response send to web browser client &#34;&#34;&#34;
        def __init__(self, streamio, remoteaddr= b&#34;&#34;, port = 0, name = &#34;&#34;):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                Http.__init__(self, request=False, remoteaddr=remoteaddr, port=port, name=name)
                self.chunk_size = 0
                self.streamio = streamio

        async def send(self, content=None, status=b&#34;200&#34;, headers=None):
                &#34;&#34;&#34; Send response to client web browser &#34;&#34;&#34;
                if headers is None:
                        headers = {}
                self.set_content(content)
                self.set_status(status)
                if headers is not None:
                        for name, value in headers.items():
                                self.set_header(name, value)
                return await self.serialize(self.streamio)

        async def send_error(self, status, content=None):
                &#34;&#34;&#34; Send error to the client web browser &#34;&#34;&#34;
                return await self.send(status=status, content=content)

        async def send_not_found(self, err=None):
                &#34;&#34;&#34; Send page not found &#34;&#34;&#34;
                if err is None:
                        content = b&#34;&#34;
                elif type(err) == type(b&#34;&#34;) or type(err) == type(&#34;&#34;):
                        content = tools.strings.tobytes(err)
                else:
                        content = tools.strings.tobytes(tools.logger.exception(err))
                return await self.send_error(status=b&#34;404&#34;, content=content)

        async def send_ok(self, content=None):
                &#34;&#34;&#34; Send ok to the client web browser &#34;&#34;&#34;
                return await self.send_error(status=b&#34;200&#34;, content=content)

        async def send_file(self, filename, mime_type=None, headers=None, base64=False):
                &#34;&#34;&#34; Send a file to the client web browser &#34;&#34;&#34;
                return await self.send(content=ContentFile(filename, mime_type, base64), status=b&#34;200&#34;, headers=headers)

        async def send_buffer(self, filename, buffer, mime_type=None, headers=None):
                &#34;&#34;&#34; Send a file to the client web browser &#34;&#34;&#34;
                return await self.send(content=ContentBuffer(filename, buffer, mime_type), status=b&#34;200&#34;, headers=headers)

        async def send_page(self, page):
                &#34;&#34;&#34; Send a template page to the client web browser &#34;&#34;&#34;
                self.set_content(None)
                self.set_status(b&#34;200&#34;)
                await self.serialize(self.streamio, page)

        async def receive(self, streamio=None):
                &#34;&#34;&#34; Receive request from client &#34;&#34;&#34;
                if streamio is None:
                        streamio = self.streamio
                await self.unserialize(streamio)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.httprequest.Http" href="#lib.server.httprequest.Http">Http</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.HttpResponse.receive"><code class="name flex">
<span>async def <span class="ident">receive</span></span>(<span>self, streamio=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Receive request from client</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def receive(self, streamio=None):
        &#34;&#34;&#34; Receive request from client &#34;&#34;&#34;
        if streamio is None:
                streamio = self.streamio
        await self.unserialize(streamio)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.HttpResponse.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, content=None, status=b'200', headers=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send response to client web browser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, content=None, status=b&#34;200&#34;, headers=None):
        &#34;&#34;&#34; Send response to client web browser &#34;&#34;&#34;
        if headers is None:
                headers = {}
        self.set_content(content)
        self.set_status(status)
        if headers is not None:
                for name, value in headers.items():
                        self.set_header(name, value)
        return await self.serialize(self.streamio)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.HttpResponse.send_buffer"><code class="name flex">
<span>async def <span class="ident">send_buffer</span></span>(<span>self, filename, buffer, mime_type=None, headers=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a file to the client web browser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_buffer(self, filename, buffer, mime_type=None, headers=None):
        &#34;&#34;&#34; Send a file to the client web browser &#34;&#34;&#34;
        return await self.send(content=ContentBuffer(filename, buffer, mime_type), status=b&#34;200&#34;, headers=headers)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.HttpResponse.send_error"><code class="name flex">
<span>async def <span class="ident">send_error</span></span>(<span>self, status, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send error to the client web browser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_error(self, status, content=None):
        &#34;&#34;&#34; Send error to the client web browser &#34;&#34;&#34;
        return await self.send(status=status, content=content)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.HttpResponse.send_file"><code class="name flex">
<span>async def <span class="ident">send_file</span></span>(<span>self, filename, mime_type=None, headers=None, base64=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a file to the client web browser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_file(self, filename, mime_type=None, headers=None, base64=False):
        &#34;&#34;&#34; Send a file to the client web browser &#34;&#34;&#34;
        return await self.send(content=ContentFile(filename, mime_type, base64), status=b&#34;200&#34;, headers=headers)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.HttpResponse.send_not_found"><code class="name flex">
<span>async def <span class="ident">send_not_found</span></span>(<span>self, err=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send page not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_not_found(self, err=None):
        &#34;&#34;&#34; Send page not found &#34;&#34;&#34;
        if err is None:
                content = b&#34;&#34;
        elif type(err) == type(b&#34;&#34;) or type(err) == type(&#34;&#34;):
                content = tools.strings.tobytes(err)
        else:
                content = tools.strings.tobytes(tools.logger.exception(err))
        return await self.send_error(status=b&#34;404&#34;, content=content)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.HttpResponse.send_ok"><code class="name flex">
<span>async def <span class="ident">send_ok</span></span>(<span>self, content=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send ok to the client web browser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_ok(self, content=None):
        &#34;&#34;&#34; Send ok to the client web browser &#34;&#34;&#34;
        return await self.send_error(status=b&#34;200&#34;, content=content)</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.HttpResponse.send_page"><code class="name flex">
<span>async def <span class="ident">send_page</span></span>(<span>self, page)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a template page to the client web browser</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_page(self, page):
        &#34;&#34;&#34; Send a template page to the client web browser &#34;&#34;&#34;
        self.set_content(None)
        self.set_status(b&#34;200&#34;)
        await self.serialize(self.streamio, page)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.httprequest.Http" href="#lib.server.httprequest.Http">Http</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.httprequest.Http.add_part" href="#lib.server.httprequest.Http.add_part">add_part</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_content" href="#lib.server.httprequest.Http.get_content">get_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_content_filename" href="#lib.server.httprequest.Http.get_content_filename">get_content_filename</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_cookie" href="#lib.server.httprequest.Http.get_cookie">get_cookie</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_expiration" href="#lib.server.httprequest.Http.get_expiration">get_expiration</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_header" href="#lib.server.httprequest.Http.get_header">get_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_id" href="#lib.server.httprequest.Http.get_id">get_id</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_path" href="#lib.server.httprequest.Http.get_path">get_path</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_status" href="#lib.server.httprequest.Http.get_status">get_status</a></code></li>
<li><code><a title="lib.server.httprequest.Http.read_content" href="#lib.server.httprequest.Http.read_content">read_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.read_data" href="#lib.server.httprequest.Http.read_data">read_data</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize" href="#lib.server.httprequest.Http.serialize">serialize</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize_body" href="#lib.server.httprequest.Http.serialize_body">serialize_body</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize_header" href="#lib.server.httprequest.Http.serialize_header">serialize_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_content" href="#lib.server.httprequest.Http.set_content">set_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_cookie" href="#lib.server.httprequest.Http.set_cookie">set_cookie</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_header" href="#lib.server.httprequest.Http.set_header">set_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_method" href="#lib.server.httprequest.Http.set_method">set_method</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_path" href="#lib.server.httprequest.Http.set_path">set_path</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_status" href="#lib.server.httprequest.Http.set_status">set_status</a></code></li>
<li><code><a title="lib.server.httprequest.Http.unserialize" href="#lib.server.httprequest.Http.unserialize">unserialize</a></code></li>
<li><code><a title="lib.server.httprequest.Http.unserialize_headers" href="#lib.server.httprequest.Http.unserialize_headers">unserialize_headers</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.httprequest.PartBin"><code class="flex name class">
<span>class <span class="ident">PartBin</span></span>
<span>(</span><span>name, filename, binary, content_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that contains a binary data, used in multipart request or response </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartBin(PartFile):
        &#34;&#34;&#34; Class that contains a binary data, used in multipart request or response &#34;&#34;&#34;
        def __init__(self, name, filename, binary, content_type):
                PartFile.__init__(self, name, filename, content_type)
                self.binary = binary

        async def serialize(self, identifier, streamio):
                &#34;&#34;&#34; Serialize multi part binary data &#34;&#34;&#34;
                result = await self.serialize_header(identifier, streamio)
                result += await streamio.write(b&#34;\r\n%s\r\n&#34;%self.binary)
                result +=  await streamio.write(b&#34;--%s&#34;%identifier)
                return result

        async def get_size(self, identifier):
                &#34;&#34;&#34; Get the size of multi part binary data &#34;&#34;&#34;
                headerSize = await self.serialize_header(identifier, server.stream.Bytesio())
                fileSize = len(self.binary)
                return headerSize + fileSize + 4 + len(identifier) + 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.server.httprequest.PartFile" href="#lib.server.httprequest.PartFile">PartFile</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.PartBin.get_size"><code class="name flex">
<span>async def <span class="ident">get_size</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the size of multi part binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_size(self, identifier):
        &#34;&#34;&#34; Get the size of multi part binary data &#34;&#34;&#34;
        headerSize = await self.serialize_header(identifier, server.stream.Bytesio())
        fileSize = len(self.binary)
        return headerSize + fileSize + 4 + len(identifier) + 2</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.PartBin.serialize"><code class="name flex">
<span>async def <span class="ident">serialize</span></span>(<span>self, identifier, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize multi part binary data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize(self, identifier, streamio):
        &#34;&#34;&#34; Serialize multi part binary data &#34;&#34;&#34;
        result = await self.serialize_header(identifier, streamio)
        result += await streamio.write(b&#34;\r\n%s\r\n&#34;%self.binary)
        result +=  await streamio.write(b&#34;--%s&#34;%identifier)
        return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.server.httprequest.PartFile" href="#lib.server.httprequest.PartFile">PartFile</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.server.httprequest.PartFile.serialize_header" href="#lib.server.httprequest.PartFile.serialize_header">serialize_header</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.server.httprequest.PartFile"><code class="flex name class">
<span>class <span class="ident">PartFile</span></span>
<span>(</span><span>name, filename, content_type)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that contains a file, used in multipart request or response </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartFile:
        &#34;&#34;&#34; Class that contains a file, used in multipart request or response &#34;&#34;&#34;
        def __init__(self, name, filename, content_type):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.name = name
                self.filename = filename
                self.content_type = content_type

        async def serialize_header(self, identifier, streamio):
                &#34;&#34;&#34; Serialize multi part header of file &#34;&#34;&#34;
                result = await streamio.write(b&#39;Content-Disposition: form-data; name=&#34;%s&#34;; filename=&#34;%s&#34;\r\n&#39;%(self.name, self.filename))
                result += await streamio.write(b&#39;Content-Type: %s\r\n&#39;%self.content_type)
                return result

        async def serialize(self, identifier, streamio):
                &#34;&#34;&#34; Serialize multi part file &#34;&#34;&#34;
                result = await self.serialize_header(identifier, streamio)
                with open(tools.strings.tostrings(self.filename),&#34;rb&#34;) as file:
                        part = file.read()
                result += await streamio.write(b&#34;\r\n%s\r\n&#34;%part)
                result +=  await streamio.write(b&#34;--%s&#34;%identifier)
                return result

        async def get_size(self, identifier):
                &#34;&#34;&#34; Get the size of multi part file &#34;&#34;&#34;
                header_size = await self.serialize_header(identifier, server.stream.Bytesio())
                file_size = tools.filesystem.filesize((tools.strings.tostrings(self.filename)))
                return header_size + file_size + 4 + len(identifier) + 2</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lib.server.httprequest.PartBin" href="#lib.server.httprequest.PartBin">PartBin</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.PartFile.get_size"><code class="name flex">
<span>async def <span class="ident">get_size</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the size of multi part file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_size(self, identifier):
        &#34;&#34;&#34; Get the size of multi part file &#34;&#34;&#34;
        header_size = await self.serialize_header(identifier, server.stream.Bytesio())
        file_size = tools.filesystem.filesize((tools.strings.tostrings(self.filename)))
        return header_size + file_size + 4 + len(identifier) + 2</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.PartFile.serialize"><code class="name flex">
<span>async def <span class="ident">serialize</span></span>(<span>self, identifier, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize multi part file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize(self, identifier, streamio):
        &#34;&#34;&#34; Serialize multi part file &#34;&#34;&#34;
        result = await self.serialize_header(identifier, streamio)
        with open(tools.strings.tostrings(self.filename),&#34;rb&#34;) as file:
                part = file.read()
        result += await streamio.write(b&#34;\r\n%s\r\n&#34;%part)
        result +=  await streamio.write(b&#34;--%s&#34;%identifier)
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.PartFile.serialize_header"><code class="name flex">
<span>async def <span class="ident">serialize_header</span></span>(<span>self, identifier, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize multi part header of file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize_header(self, identifier, streamio):
        &#34;&#34;&#34; Serialize multi part header of file &#34;&#34;&#34;
        result = await streamio.write(b&#39;Content-Disposition: form-data; name=&#34;%s&#34;; filename=&#34;%s&#34;\r\n&#39;%(self.name, self.filename))
        result += await streamio.write(b&#39;Content-Type: %s\r\n&#39;%self.content_type)
        return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.httprequest.PartText"><code class="flex name class">
<span>class <span class="ident">PartText</span></span>
<span>(</span><span>name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Class that contains a text, used in multipart request or response </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartText:
        &#34;&#34;&#34; Class that contains a text, used in multipart request or response &#34;&#34;&#34;
        def __init__(self, name, value):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.name  = name
                self.value = value

        async def serialize(self, identifier, streamio):
                &#34;&#34;&#34; Serialize multipart text part &#34;&#34;&#34;
                result = await streamio.write(b&#39;Content-Disposition: form-data; name=&#34;%s&#34;\r\n&#39;%(self.name))
                result += await streamio.write(b&#39;Content-Type: text/plain \r\n&#39;)
                result += await streamio.write(b&#34;\r\n%s\r\n&#34;%self.value)
                result += await streamio.write(b&#34;--%s&#34;%identifier)
                return result

        async def get_size(self, identifier):
                &#34;&#34;&#34; Get the size of this part &#34;&#34;&#34;
                result = await self.serialize(identifier, server.stream.Bytesio())
                return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httprequest.PartText.get_size"><code class="name flex">
<span>async def <span class="ident">get_size</span></span>(<span>self, identifier)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the size of this part</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_size(self, identifier):
        &#34;&#34;&#34; Get the size of this part &#34;&#34;&#34;
        result = await self.serialize(identifier, server.stream.Bytesio())
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.httprequest.PartText.serialize"><code class="name flex">
<span>async def <span class="ident">serialize</span></span>(<span>self, identifier, streamio)</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize multipart text part</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def serialize(self, identifier, streamio):
        &#34;&#34;&#34; Serialize multipart text part &#34;&#34;&#34;
        result = await streamio.write(b&#39;Content-Disposition: form-data; name=&#34;%s&#34;\r\n&#39;%(self.name))
        result += await streamio.write(b&#39;Content-Type: text/plain \r\n&#39;)
        result += await streamio.write(b&#34;\r\n%s\r\n&#34;%self.value)
        result += await streamio.write(b&#34;--%s&#34;%identifier)
        return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.server" href="index.html">lib.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.server.httprequest.ContentBuffer" href="#lib.server.httprequest.ContentBuffer">ContentBuffer</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httprequest.ContentBuffer.serialize" href="#lib.server.httprequest.ContentBuffer.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httprequest.ContentFile" href="#lib.server.httprequest.ContentFile">ContentFile</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httprequest.ContentFile.serialize" href="#lib.server.httprequest.ContentFile.serialize">serialize</a></code></li>
<li><code><a title="lib.server.httprequest.ContentFile.serialize_file" href="#lib.server.httprequest.ContentFile.serialize_file">serialize_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httprequest.ContentText" href="#lib.server.httprequest.ContentText">ContentText</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httprequest.ContentText.serialize" href="#lib.server.httprequest.ContentText.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httprequest.Http" href="#lib.server.httprequest.Http">Http</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httprequest.Http.add_part" href="#lib.server.httprequest.Http.add_part">add_part</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_content" href="#lib.server.httprequest.Http.get_content">get_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_content_filename" href="#lib.server.httprequest.Http.get_content_filename">get_content_filename</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_cookie" href="#lib.server.httprequest.Http.get_cookie">get_cookie</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_expiration" href="#lib.server.httprequest.Http.get_expiration">get_expiration</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_header" href="#lib.server.httprequest.Http.get_header">get_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_id" href="#lib.server.httprequest.Http.get_id">get_id</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_path" href="#lib.server.httprequest.Http.get_path">get_path</a></code></li>
<li><code><a title="lib.server.httprequest.Http.get_status" href="#lib.server.httprequest.Http.get_status">get_status</a></code></li>
<li><code><a title="lib.server.httprequest.Http.read_content" href="#lib.server.httprequest.Http.read_content">read_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.read_data" href="#lib.server.httprequest.Http.read_data">read_data</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize" href="#lib.server.httprequest.Http.serialize">serialize</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize_body" href="#lib.server.httprequest.Http.serialize_body">serialize_body</a></code></li>
<li><code><a title="lib.server.httprequest.Http.serialize_header" href="#lib.server.httprequest.Http.serialize_header">serialize_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_content" href="#lib.server.httprequest.Http.set_content">set_content</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_cookie" href="#lib.server.httprequest.Http.set_cookie">set_cookie</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_header" href="#lib.server.httprequest.Http.set_header">set_header</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_method" href="#lib.server.httprequest.Http.set_method">set_method</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_path" href="#lib.server.httprequest.Http.set_path">set_path</a></code></li>
<li><code><a title="lib.server.httprequest.Http.set_status" href="#lib.server.httprequest.Http.set_status">set_status</a></code></li>
<li><code><a title="lib.server.httprequest.Http.unserialize" href="#lib.server.httprequest.Http.unserialize">unserialize</a></code></li>
<li><code><a title="lib.server.httprequest.Http.unserialize_headers" href="#lib.server.httprequest.Http.unserialize_headers">unserialize_headers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httprequest.HttpRequest" href="#lib.server.httprequest.HttpRequest">HttpRequest</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httprequest.HttpRequest.receive" href="#lib.server.httprequest.HttpRequest.receive">receive</a></code></li>
<li><code><a title="lib.server.httprequest.HttpRequest.send" href="#lib.server.httprequest.HttpRequest.send">send</a></code></li>
<li><code><a title="lib.server.httprequest.HttpRequest.to_html" href="#lib.server.httprequest.HttpRequest.to_html">to_html</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httprequest.HttpResponse" href="#lib.server.httprequest.HttpResponse">HttpResponse</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.server.httprequest.HttpResponse.receive" href="#lib.server.httprequest.HttpResponse.receive">receive</a></code></li>
<li><code><a title="lib.server.httprequest.HttpResponse.send" href="#lib.server.httprequest.HttpResponse.send">send</a></code></li>
<li><code><a title="lib.server.httprequest.HttpResponse.send_buffer" href="#lib.server.httprequest.HttpResponse.send_buffer">send_buffer</a></code></li>
<li><code><a title="lib.server.httprequest.HttpResponse.send_error" href="#lib.server.httprequest.HttpResponse.send_error">send_error</a></code></li>
<li><code><a title="lib.server.httprequest.HttpResponse.send_file" href="#lib.server.httprequest.HttpResponse.send_file">send_file</a></code></li>
<li><code><a title="lib.server.httprequest.HttpResponse.send_not_found" href="#lib.server.httprequest.HttpResponse.send_not_found">send_not_found</a></code></li>
<li><code><a title="lib.server.httprequest.HttpResponse.send_ok" href="#lib.server.httprequest.HttpResponse.send_ok">send_ok</a></code></li>
<li><code><a title="lib.server.httprequest.HttpResponse.send_page" href="#lib.server.httprequest.HttpResponse.send_page">send_page</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httprequest.PartBin" href="#lib.server.httprequest.PartBin">PartBin</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httprequest.PartBin.get_size" href="#lib.server.httprequest.PartBin.get_size">get_size</a></code></li>
<li><code><a title="lib.server.httprequest.PartBin.serialize" href="#lib.server.httprequest.PartBin.serialize">serialize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httprequest.PartFile" href="#lib.server.httprequest.PartFile">PartFile</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httprequest.PartFile.get_size" href="#lib.server.httprequest.PartFile.get_size">get_size</a></code></li>
<li><code><a title="lib.server.httprequest.PartFile.serialize" href="#lib.server.httprequest.PartFile.serialize">serialize</a></code></li>
<li><code><a title="lib.server.httprequest.PartFile.serialize_header" href="#lib.server.httprequest.PartFile.serialize_header">serialize_header</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httprequest.PartText" href="#lib.server.httprequest.PartText">PartText</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httprequest.PartText.get_size" href="#lib.server.httprequest.PartText.get_size">get_size</a></code></li>
<li><code><a title="lib.server.httprequest.PartText.serialize" href="#lib.server.httprequest.PartText.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>