<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lib.server.httpserver API documentation</title>
<meta name="description" content="This class is used to manage an http server.
This class contains few lines of code, this is to save memory.
The core of the server is in the other â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.server.httpserver</code></h1>
</header>
<section id="section-intro">
<p>This class is used to manage an http server.
This class contains few lines of code, this is to save memory.
The core of the server is in the other class HttpServerCore, which is loaded into memory only when connecting an HTTP client.
It takes a little while the first time you connect, but limits memory consumption if not in use.
If you have enough memory (SPIRAM or other), just start the server with the preload option at True.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
# historically based on :
# https://github.com/jczic/MicroWebSrv/blob/master/microWebSocket.py
# but I have modified a lot, there must still be some original functions.
&#34;&#34;&#34; This class is used to manage an http server.
This class contains few lines of code, this is to save memory.
The core of the server is in the other class HttpServerCore, which is loaded into memory only when connecting an HTTP client.
It takes a little while the first time you connect, but limits memory consumption if not in use.
If you have enough memory (SPIRAM or other), just start the server with the preload option at True. &#34;&#34;&#34;
import re
from tools import useful

class HttpServer:
        &#34;&#34;&#34; Http main class &#34;&#34;&#34;
        routes = {}
        wildroutes = []
        menus = []
        wwwDir = None

        def __init__(self, port=80, loader=None, preload=False, name=&#34;&#34;):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.server = None
                self.loader = loader
                self.port = port
                self.name = name
                if preload:
                        self.preload()
                else:
                        useful.syslog(&#34;Http waiting on %d&#34;%self.port)

        def preload(self):
                &#34;&#34;&#34; Method used to preload page template.
                You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
                loaded = False

                if self.loader:
                        from htmltemplate import WWW_DIR
                        useful.syslog(&#34;Html load pages&#34;)
                        self.loader()
                        self.loader = None
                        HttpServer.wwwDir = WWW_DIR
                        loaded = True

                if self.server is None:
                        useful.syslog(&#34;Http start server&#34;)
                        from server.httpservercore import HttpServerCore
                        self.server = HttpServerCore(self.port, self.name)
                        loaded = True

                if loaded:
                        useful.syslog(&#34;Http ready on %d&#34;%self.port)

        @staticmethod
        def addRoute(url, **kwargs):
                &#34;&#34;&#34; Add a route to select an html page.
                For the server to know the pages, it must imperatively use this decorator &#34;&#34;&#34;
                def addRoute(function):
                        if useful.tobytes(url[-1]) == ord(b&#34;*&#34;):
                                HttpServer.wildroutes.append([useful.tobytes(url),(function, kwargs)])
                        else:
                                kwargs[&#34;index&#34;] = len(HttpServer.menus)
                                HttpServer.routes[useful.tobytes(url)] = (function, kwargs)
                        if kwargs.get(&#34;available&#34;, True):
                                if &#34;item&#34; in kwargs and &#34;menu&#34; in kwargs:
                                        HttpServer.menus.append([kwargs[&#34;menu&#34;], kwargs[&#34;item&#34;],len(HttpServer.menus), useful.tobytes(url)])
                                        HttpServer.menus.sort()
                        return function
                return addRoute

        @staticmethod
        def removeRoute(url=None):
                &#34;&#34;&#34; Remove a route of html page &#34;&#34;&#34;
                if url is None:
                        HttpServer.routes = {}
                        HttpServer.menus = []
                else:
                        route = HttpServer.routes.get(url, None)
                        if route:
                                del HttpServer.routes[url]
                                title = route[1].get(&#34;title&#34;, None)
                                if title:
                                        i = 0
                                        for item in HttpServer.menus:
                                                index, route, titl = item
                                                if titl == title:
                                                        del HttpServer.menus[i]
                                                        break
                                                i += 1

        @staticmethod
        def getMenus():
                &#34;&#34;&#34; Used to get the informations of menu &#34;&#34;&#34;
                return HttpServer.menus

        @staticmethod
        def searchRoute(request):
                &#34;&#34;&#34; Search route according to the request &#34;&#34;&#34;
                function, args = None, None

                if request.method == b&#34;PUT&#34;:
                        directory, file = useful.split(useful.tostrings(request.path))
                        found = HttpServer.routes.get(useful.tobytes(directory),None)
                        if found:
                                function, args = found
                        return function, args
                else:
                        found = HttpServer.routes.get(request.path,None)
                        if found is None:
                                for route, func in HttpServer.wildroutes:
                                        if re.match(useful.tostrings(route), useful.tostrings(request.path)):
                                                found = func
                                                break
                                if found is None:
                                        staticRe = re.compile(&#34;^/(&#34;+useful.tostrings(HttpServer.wwwDir)+&#34;/.+|.+)&#34;)
                                        if staticRe.match(useful.tostrings(request.path)):
                                                function, args = HttpServer.staticPages, {}
                                else:
                                        function, args = found
                        else:
                                function, args = found
                return function, args

        @staticmethod
        async def staticPages(request, response, args):
                &#34;&#34;&#34; Treat the case of static pages &#34;&#34;&#34;
                path = useful.tobytes(HttpServer.wwwDir) + request.path
                path = path.replace(b&#34;//&#34;,b&#34;/&#34;)

                if b&#34;..&#34; in path:
                        await response.sendError(status=b&#34;403&#34;,content=b&#34;Forbidden&#34;)
                else:
                        await response.sendFile(path, headers=request.headers)

        async def onConnection(self, reader, writer):
                &#34;&#34;&#34; Http server connection detected &#34;&#34;&#34;
                try:
                        # Preload the server
                        self.preload()

                        # Call on connection method
                        await self.server.onConnection(reader, writer)
                except Exception as err:
                        useful.syslog(err)

def start(loop=None, port=80, loader=None, preload=False, name=&#34;&#34;):
        &#34;&#34;&#34; Start http server.
        loop : asyncio loop object
        port : tcp/ip port of the server
        preload : True = preload the server at the start, False = load the server at the first connection &#34;&#34;&#34;
        import uasyncio
        server = HttpServer(port=port, loader=loader, preload=preload, name=name)

        if loop is None:
                loop = uasyncio.get_event_loop()
                run_forever = True
        else:
                run_forever = False

        asyncServer = uasyncio.start_server(server.onConnection, &#34;0.0.0.0&#34;,port,backlog=5)

        loop.create_task(asyncServer)
        if run_forever:
                loop.run_forever()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lib.server.httpserver.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>loop=None, port=80, loader=None, preload=False, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Start http server.
loop : asyncio loop object
port : tcp/ip port of the server
preload : True = preload the server at the start, False = load the server at the first connection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(loop=None, port=80, loader=None, preload=False, name=&#34;&#34;):
        &#34;&#34;&#34; Start http server.
        loop : asyncio loop object
        port : tcp/ip port of the server
        preload : True = preload the server at the start, False = load the server at the first connection &#34;&#34;&#34;
        import uasyncio
        server = HttpServer(port=port, loader=loader, preload=preload, name=name)

        if loop is None:
                loop = uasyncio.get_event_loop()
                run_forever = True
        else:
                run_forever = False

        asyncServer = uasyncio.start_server(server.onConnection, &#34;0.0.0.0&#34;,port,backlog=5)

        loop.create_task(asyncServer)
        if run_forever:
                loop.run_forever()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.server.httpserver.HttpServer"><code class="flex name class">
<span>class <span class="ident">HttpServer</span></span>
<span>(</span><span>port=80, loader=None, preload=False, name='')</span>
</code></dt>
<dd>
<div class="desc"><p>Http main class </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpServer:
        &#34;&#34;&#34; Http main class &#34;&#34;&#34;
        routes = {}
        wildroutes = []
        menus = []
        wwwDir = None

        def __init__(self, port=80, loader=None, preload=False, name=&#34;&#34;):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.server = None
                self.loader = loader
                self.port = port
                self.name = name
                if preload:
                        self.preload()
                else:
                        useful.syslog(&#34;Http waiting on %d&#34;%self.port)

        def preload(self):
                &#34;&#34;&#34; Method used to preload page template.
                You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
                loaded = False

                if self.loader:
                        from htmltemplate import WWW_DIR
                        useful.syslog(&#34;Html load pages&#34;)
                        self.loader()
                        self.loader = None
                        HttpServer.wwwDir = WWW_DIR
                        loaded = True

                if self.server is None:
                        useful.syslog(&#34;Http start server&#34;)
                        from server.httpservercore import HttpServerCore
                        self.server = HttpServerCore(self.port, self.name)
                        loaded = True

                if loaded:
                        useful.syslog(&#34;Http ready on %d&#34;%self.port)

        @staticmethod
        def addRoute(url, **kwargs):
                &#34;&#34;&#34; Add a route to select an html page.
                For the server to know the pages, it must imperatively use this decorator &#34;&#34;&#34;
                def addRoute(function):
                        if useful.tobytes(url[-1]) == ord(b&#34;*&#34;):
                                HttpServer.wildroutes.append([useful.tobytes(url),(function, kwargs)])
                        else:
                                kwargs[&#34;index&#34;] = len(HttpServer.menus)
                                HttpServer.routes[useful.tobytes(url)] = (function, kwargs)
                        if kwargs.get(&#34;available&#34;, True):
                                if &#34;item&#34; in kwargs and &#34;menu&#34; in kwargs:
                                        HttpServer.menus.append([kwargs[&#34;menu&#34;], kwargs[&#34;item&#34;],len(HttpServer.menus), useful.tobytes(url)])
                                        HttpServer.menus.sort()
                        return function
                return addRoute

        @staticmethod
        def removeRoute(url=None):
                &#34;&#34;&#34; Remove a route of html page &#34;&#34;&#34;
                if url is None:
                        HttpServer.routes = {}
                        HttpServer.menus = []
                else:
                        route = HttpServer.routes.get(url, None)
                        if route:
                                del HttpServer.routes[url]
                                title = route[1].get(&#34;title&#34;, None)
                                if title:
                                        i = 0
                                        for item in HttpServer.menus:
                                                index, route, titl = item
                                                if titl == title:
                                                        del HttpServer.menus[i]
                                                        break
                                                i += 1

        @staticmethod
        def getMenus():
                &#34;&#34;&#34; Used to get the informations of menu &#34;&#34;&#34;
                return HttpServer.menus

        @staticmethod
        def searchRoute(request):
                &#34;&#34;&#34; Search route according to the request &#34;&#34;&#34;
                function, args = None, None

                if request.method == b&#34;PUT&#34;:
                        directory, file = useful.split(useful.tostrings(request.path))
                        found = HttpServer.routes.get(useful.tobytes(directory),None)
                        if found:
                                function, args = found
                        return function, args
                else:
                        found = HttpServer.routes.get(request.path,None)
                        if found is None:
                                for route, func in HttpServer.wildroutes:
                                        if re.match(useful.tostrings(route), useful.tostrings(request.path)):
                                                found = func
                                                break
                                if found is None:
                                        staticRe = re.compile(&#34;^/(&#34;+useful.tostrings(HttpServer.wwwDir)+&#34;/.+|.+)&#34;)
                                        if staticRe.match(useful.tostrings(request.path)):
                                                function, args = HttpServer.staticPages, {}
                                else:
                                        function, args = found
                        else:
                                function, args = found
                return function, args

        @staticmethod
        async def staticPages(request, response, args):
                &#34;&#34;&#34; Treat the case of static pages &#34;&#34;&#34;
                path = useful.tobytes(HttpServer.wwwDir) + request.path
                path = path.replace(b&#34;//&#34;,b&#34;/&#34;)

                if b&#34;..&#34; in path:
                        await response.sendError(status=b&#34;403&#34;,content=b&#34;Forbidden&#34;)
                else:
                        await response.sendFile(path, headers=request.headers)

        async def onConnection(self, reader, writer):
                &#34;&#34;&#34; Http server connection detected &#34;&#34;&#34;
                try:
                        # Preload the server
                        self.preload()

                        # Call on connection method
                        await self.server.onConnection(reader, writer)
                except Exception as err:
                        useful.syslog(err)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.server.httpserver.HttpServer.menus"><code class="name">var <span class="ident">menus</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.routes"><code class="name">var <span class="ident">routes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.wildroutes"><code class="name">var <span class="ident">wildroutes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.wwwDir"><code class="name">var <span class="ident">wwwDir</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.server.httpserver.HttpServer.addRoute"><code class="name flex">
<span>def <span class="ident">addRoute</span></span>(<span>url, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a route to select an html page.
For the server to know the pages, it must imperatively use this decorator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def addRoute(url, **kwargs):
        &#34;&#34;&#34; Add a route to select an html page.
        For the server to know the pages, it must imperatively use this decorator &#34;&#34;&#34;
        def addRoute(function):
                if useful.tobytes(url[-1]) == ord(b&#34;*&#34;):
                        HttpServer.wildroutes.append([useful.tobytes(url),(function, kwargs)])
                else:
                        kwargs[&#34;index&#34;] = len(HttpServer.menus)
                        HttpServer.routes[useful.tobytes(url)] = (function, kwargs)
                if kwargs.get(&#34;available&#34;, True):
                        if &#34;item&#34; in kwargs and &#34;menu&#34; in kwargs:
                                HttpServer.menus.append([kwargs[&#34;menu&#34;], kwargs[&#34;item&#34;],len(HttpServer.menus), useful.tobytes(url)])
                                HttpServer.menus.sort()
                return function
        return addRoute</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.getMenus"><code class="name flex">
<span>def <span class="ident">getMenus</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to get the informations of menu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def getMenus():
        &#34;&#34;&#34; Used to get the informations of menu &#34;&#34;&#34;
        return HttpServer.menus</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.removeRoute"><code class="name flex">
<span>def <span class="ident">removeRoute</span></span>(<span>url=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a route of html page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def removeRoute(url=None):
        &#34;&#34;&#34; Remove a route of html page &#34;&#34;&#34;
        if url is None:
                HttpServer.routes = {}
                HttpServer.menus = []
        else:
                route = HttpServer.routes.get(url, None)
                if route:
                        del HttpServer.routes[url]
                        title = route[1].get(&#34;title&#34;, None)
                        if title:
                                i = 0
                                for item in HttpServer.menus:
                                        index, route, titl = item
                                        if titl == title:
                                                del HttpServer.menus[i]
                                                break
                                        i += 1</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.searchRoute"><code class="name flex">
<span>def <span class="ident">searchRoute</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"><p>Search route according to the request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def searchRoute(request):
        &#34;&#34;&#34; Search route according to the request &#34;&#34;&#34;
        function, args = None, None

        if request.method == b&#34;PUT&#34;:
                directory, file = useful.split(useful.tostrings(request.path))
                found = HttpServer.routes.get(useful.tobytes(directory),None)
                if found:
                        function, args = found
                return function, args
        else:
                found = HttpServer.routes.get(request.path,None)
                if found is None:
                        for route, func in HttpServer.wildroutes:
                                if re.match(useful.tostrings(route), useful.tostrings(request.path)):
                                        found = func
                                        break
                        if found is None:
                                staticRe = re.compile(&#34;^/(&#34;+useful.tostrings(HttpServer.wwwDir)+&#34;/.+|.+)&#34;)
                                if staticRe.match(useful.tostrings(request.path)):
                                        function, args = HttpServer.staticPages, {}
                        else:
                                function, args = found
                else:
                        function, args = found
        return function, args</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.staticPages"><code class="name flex">
<span>async def <span class="ident">staticPages</span></span>(<span>request, response, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Treat the case of static pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def staticPages(request, response, args):
        &#34;&#34;&#34; Treat the case of static pages &#34;&#34;&#34;
        path = useful.tobytes(HttpServer.wwwDir) + request.path
        path = path.replace(b&#34;//&#34;,b&#34;/&#34;)

        if b&#34;..&#34; in path:
                await response.sendError(status=b&#34;403&#34;,content=b&#34;Forbidden&#34;)
        else:
                await response.sendFile(path, headers=request.headers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httpserver.HttpServer.onConnection"><code class="name flex">
<span>async def <span class="ident">onConnection</span></span>(<span>self, reader, writer)</span>
</code></dt>
<dd>
<div class="desc"><p>Http server connection detected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def onConnection(self, reader, writer):
        &#34;&#34;&#34; Http server connection detected &#34;&#34;&#34;
        try:
                # Preload the server
                self.preload()

                # Call on connection method
                await self.server.onConnection(reader, writer)
        except Exception as err:
                useful.syslog(err)</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.preload"><code class="name flex">
<span>def <span class="ident">preload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method used to preload page template.
You must define the content of a callback, which only import the python module with your pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preload(self):
        &#34;&#34;&#34; Method used to preload page template.
        You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
        loaded = False

        if self.loader:
                from htmltemplate import WWW_DIR
                useful.syslog(&#34;Html load pages&#34;)
                self.loader()
                self.loader = None
                HttpServer.wwwDir = WWW_DIR
                loaded = True

        if self.server is None:
                useful.syslog(&#34;Http start server&#34;)
                from server.httpservercore import HttpServerCore
                self.server = HttpServerCore(self.port, self.name)
                loaded = True

        if loaded:
                useful.syslog(&#34;Http ready on %d&#34;%self.port)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.server" href="index.html">lib.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lib.server.httpserver.start" href="#lib.server.httpserver.start">start</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.server.httpserver.HttpServer" href="#lib.server.httpserver.HttpServer">HttpServer</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.server.httpserver.HttpServer.addRoute" href="#lib.server.httpserver.HttpServer.addRoute">addRoute</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.getMenus" href="#lib.server.httpserver.HttpServer.getMenus">getMenus</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.menus" href="#lib.server.httpserver.HttpServer.menus">menus</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.onConnection" href="#lib.server.httpserver.HttpServer.onConnection">onConnection</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.preload" href="#lib.server.httpserver.HttpServer.preload">preload</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.removeRoute" href="#lib.server.httpserver.HttpServer.removeRoute">removeRoute</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.routes" href="#lib.server.httpserver.HttpServer.routes">routes</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.searchRoute" href="#lib.server.httpserver.HttpServer.searchRoute">searchRoute</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.staticPages" href="#lib.server.httpserver.HttpServer.staticPages">staticPages</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.wildroutes" href="#lib.server.httpserver.HttpServer.wildroutes">wildroutes</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.wwwDir" href="#lib.server.httpserver.HttpServer.wwwDir">wwwDir</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>