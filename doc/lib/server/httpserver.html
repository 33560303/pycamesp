<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lib.server.httpserver API documentation</title>
<meta name="description" content="This class is used to manage an http server.
This class contains few lines of code, this is to save memory.
The core of the server is in the other â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.server.httpserver</code></h1>
</header>
<section id="section-intro">
<p>This class is used to manage an http server.
This class contains few lines of code, this is to save memory.
The core of the server is in the other class HttpServerCore, which is loaded into memory only when connecting an HTTP client.
It takes a little while the first time you connect, but limits memory consumption if not in use.
If you have enough memory (SPIRAM or other), just start the server with the preload option at True.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under Pycameresp License
# Copyright (c) 2023 Remi BERTHOLET
# historically based on :
# https://github.com/jczic/MicroWebSrv/blob/master/microWebSocket.py
# but I have modified a lot, there must still be some original functions.
# pylint:disable=consider-using-f-string
&#34;&#34;&#34; This class is used to manage an http server.
This class contains few lines of code, this is to save memory.
The core of the server is in the other class HttpServerCore, which is loaded into memory only when connecting an HTTP client.
It takes a little while the first time you connect, but limits memory consumption if not in use.
If you have enough memory (SPIRAM or other), just start the server with the preload option at True. &#34;&#34;&#34;
import re
import server.server
import tools.logger
import tools.filesystem
import tools.strings
import tools.tasking

class HttpServerInstance(tools.tasking.ServerInstance):
        &#34;&#34;&#34; Instance of server Http &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                tools.tasking.ServerInstance.__init__(self, **kwargs)
                self.server = None
                self.kwargs = kwargs

        def preload(self):
                &#34;&#34;&#34; Method used to preload page template.
                You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
                started = False
                if HttpServer.preload():
                        started = True

                if self.server is None:
                        tools.logger.syslog(&#34;Http &#39;%s&#39; started&#34;%self.kwargs.get(&#34;name&#34;,&#34;&#34;))
                        from server.httpservercore import HttpServerCore
                        self.server = HttpServerCore(**self.kwargs)
                        started = True

                if started:
                        tools.logger.syslog(&#34;Http &#39;%s&#39; ready on %d&#34;%(self.kwargs.get(&#34;name&#34;,&#34;&#34;), self.kwargs.get(&#34;port&#34;,0)))

        async def on_connection(self, reader, writer):
                &#34;&#34;&#34; Http server connection detected &#34;&#34;&#34;
                try:
                        # Preload the server
                        self.preload()

                        # Call on connection method
                        await self.server.on_connection(reader, writer)
                except Exception as err:
                        tools.logger.syslog(err)

class HttpServer:
        &#34;&#34;&#34; Http main class &#34;&#34;&#34;
        routes       = {}
        wildroutes   = []
        menus        = []
        www_dir      = None
        pages = []
        loaded       = [False]
        config = None

        @staticmethod
        def call_preload(loader):
                &#34;&#34;&#34; Call preload html page callback &#34;&#34;&#34;
                if loader is not None:
                        if tools.filesystem.ismicropython():
                                ModuleNotFound = ImportError
                        else:
                                ModuleNotFound = ModuleNotFoundError
                        try:
                                loader()
                        except ModuleNotFound as err:
                                tools.logger.syslog(&#34;Preload html page : %s&#34;%str(err))
                        except Exception as err:
                                tools.logger.syslog(err)

        @staticmethod
        def preload():
                &#34;&#34;&#34; Method used to preload page template.
                You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
                result = False
                if HttpServer.loaded[0] is False:
                        from htmltemplate import WWW_DIR
                        tools.logger.syslog(&#34;Html load pages&#34;)
                        if len(HttpServer.pages) &gt; 0:
                                for loader in HttpServer.pages:
                                        HttpServer.call_preload(loader)
                        HttpServer.www_dir = WWW_DIR
                        result = True
                        HttpServer.loaded[0] = True
                return result

        @staticmethod
        def add_pages():
                &#34;&#34;&#34; Add an html page loader which will be called when connecting to the http server &#34;&#34;&#34;
                def add_pages(function):
                        HttpServer.pages.append(function)
                        return function
                return add_pages

        @staticmethod
        def add_route(url, **kwargs):
                &#34;&#34;&#34; Add a route to select an html page.
                For the server to know the pages, it must imperatively use this decorator &#34;&#34;&#34;
                def add_route(function):
                        if tools.strings.tobytes(url[-1]) == ord(b&#34;*&#34;):
                                HttpServer.wildroutes.append([tools.strings.tobytes(url),(function, kwargs)])
                        else:
                                kwargs[&#34;index&#34;] = len(HttpServer.menus)
                                HttpServer.routes[tools.strings.tobytes(url)] = (function, kwargs)
                        if kwargs.get(&#34;available&#34;, True):
                                if &#34;item&#34; in kwargs and &#34;menu&#34; in kwargs:
                                        HttpServer.menus.append([kwargs[&#34;menu&#34;], kwargs[&#34;item&#34;],len(HttpServer.menus), tools.strings.tobytes(url)])
                                        HttpServer.menus.sort()
                        return function
                return add_route

        @staticmethod
        def remove_route(url=None):
                &#34;&#34;&#34; Remove a route of html page &#34;&#34;&#34;
                if url is None:
                        HttpServer.routes = {}
                        HttpServer.menus = []
                else:
                        route = HttpServer.routes.get(url, None)
                        if route:
                                del HttpServer.routes[url]
                                title = route[1].get(&#34;title&#34;, None)
                                if title:
                                        i = 0
                                        for item in HttpServer.menus:
                                                index, route, titl = item
                                                if titl == title:
                                                        del HttpServer.menus[i]
                                                        break
                                                i += 1

        @staticmethod
        def get_menus():
                &#34;&#34;&#34; Used to get the informations of menu &#34;&#34;&#34;
                return HttpServer.menus

        @staticmethod
        def search_route(request):
                &#34;&#34;&#34; Search route according to the request &#34;&#34;&#34;
                function, args = None, None

                if request.method == b&#34;PUT&#34;:
                        directory, file = tools.filesystem.split(tools.strings.tostrings(request.path))
                        found = HttpServer.routes.get(tools.strings.tobytes(directory),None)
                        if found:
                                function, args = found
                        return function, args
                else:
                        found = HttpServer.routes.get(request.path,None)
                        if found is None:
                                for route, func in HttpServer.wildroutes:
                                        if re.match(tools.strings.tostrings(route), tools.strings.tostrings(request.path)):
                                                found = func
                                                break
                                if found is None:
                                        staticRe = re.compile(&#34;^/(&#34;+tools.strings.tostrings(HttpServer.www_dir)+&#34;/.+|.+)&#34;)
                                        if staticRe.match(tools.strings.tostrings(request.path)):
                                                function, args = HttpServer.static_pages, {}
                                else:
                                        function, args = found
                        else:
                                function, args = found
                return function, args

        @staticmethod
        async def static_pages(request, response, args):
                &#34;&#34;&#34; Treat the case of static pages &#34;&#34;&#34;
                path = tools.strings.tobytes(HttpServer.www_dir) + request.path
                path = path.replace(b&#34;//&#34;,b&#34;/&#34;)
                if b&#34;..&#34; in path:
                        await response.send_error(status=b&#34;403&#34;,content=b&#34;Forbidden&#34;)
                else:
                        await response.send_file(path, headers=request.headers)

        @staticmethod
        def init():
                &#34;&#34;&#34; Initialize http server &#34;&#34;&#34;
                if HttpServer.config is None:
                        HttpServer.config = server.server.ServerConfig()
                        HttpServer.config.load_create()
                else:
                        HttpServer.config.refresh()

        @staticmethod
        def start(**kwargs):
                &#34;&#34;&#34; Start http server instance on selected port &#34;&#34;&#34;
                HttpServer.init()
                # If http activated
                if HttpServer.config.http:
                        kwargs[&#34;port&#34;] = kwargs.get(&#34;http_port&#34;,80)
                        kwargs[&#34;name&#34;] = kwargs.get(&#34;name&#34;,&#34;Http&#34;)
                        kwargs[&#34;backlog&#34;] = kwargs.get(&#34;backlog&#34;,5)
                        tools.tasking.Tasks.create_server(HttpServerInstance(**kwargs))
                else:
                        tools.logger.syslog(&#34;Http server disabled in config&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.server.httpserver.HttpServer"><code class="flex name class">
<span>class <span class="ident">HttpServer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Http main class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpServer:
        &#34;&#34;&#34; Http main class &#34;&#34;&#34;
        routes       = {}
        wildroutes   = []
        menus        = []
        www_dir      = None
        pages = []
        loaded       = [False]
        config = None

        @staticmethod
        def call_preload(loader):
                &#34;&#34;&#34; Call preload html page callback &#34;&#34;&#34;
                if loader is not None:
                        if tools.filesystem.ismicropython():
                                ModuleNotFound = ImportError
                        else:
                                ModuleNotFound = ModuleNotFoundError
                        try:
                                loader()
                        except ModuleNotFound as err:
                                tools.logger.syslog(&#34;Preload html page : %s&#34;%str(err))
                        except Exception as err:
                                tools.logger.syslog(err)

        @staticmethod
        def preload():
                &#34;&#34;&#34; Method used to preload page template.
                You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
                result = False
                if HttpServer.loaded[0] is False:
                        from htmltemplate import WWW_DIR
                        tools.logger.syslog(&#34;Html load pages&#34;)
                        if len(HttpServer.pages) &gt; 0:
                                for loader in HttpServer.pages:
                                        HttpServer.call_preload(loader)
                        HttpServer.www_dir = WWW_DIR
                        result = True
                        HttpServer.loaded[0] = True
                return result

        @staticmethod
        def add_pages():
                &#34;&#34;&#34; Add an html page loader which will be called when connecting to the http server &#34;&#34;&#34;
                def add_pages(function):
                        HttpServer.pages.append(function)
                        return function
                return add_pages

        @staticmethod
        def add_route(url, **kwargs):
                &#34;&#34;&#34; Add a route to select an html page.
                For the server to know the pages, it must imperatively use this decorator &#34;&#34;&#34;
                def add_route(function):
                        if tools.strings.tobytes(url[-1]) == ord(b&#34;*&#34;):
                                HttpServer.wildroutes.append([tools.strings.tobytes(url),(function, kwargs)])
                        else:
                                kwargs[&#34;index&#34;] = len(HttpServer.menus)
                                HttpServer.routes[tools.strings.tobytes(url)] = (function, kwargs)
                        if kwargs.get(&#34;available&#34;, True):
                                if &#34;item&#34; in kwargs and &#34;menu&#34; in kwargs:
                                        HttpServer.menus.append([kwargs[&#34;menu&#34;], kwargs[&#34;item&#34;],len(HttpServer.menus), tools.strings.tobytes(url)])
                                        HttpServer.menus.sort()
                        return function
                return add_route

        @staticmethod
        def remove_route(url=None):
                &#34;&#34;&#34; Remove a route of html page &#34;&#34;&#34;
                if url is None:
                        HttpServer.routes = {}
                        HttpServer.menus = []
                else:
                        route = HttpServer.routes.get(url, None)
                        if route:
                                del HttpServer.routes[url]
                                title = route[1].get(&#34;title&#34;, None)
                                if title:
                                        i = 0
                                        for item in HttpServer.menus:
                                                index, route, titl = item
                                                if titl == title:
                                                        del HttpServer.menus[i]
                                                        break
                                                i += 1

        @staticmethod
        def get_menus():
                &#34;&#34;&#34; Used to get the informations of menu &#34;&#34;&#34;
                return HttpServer.menus

        @staticmethod
        def search_route(request):
                &#34;&#34;&#34; Search route according to the request &#34;&#34;&#34;
                function, args = None, None

                if request.method == b&#34;PUT&#34;:
                        directory, file = tools.filesystem.split(tools.strings.tostrings(request.path))
                        found = HttpServer.routes.get(tools.strings.tobytes(directory),None)
                        if found:
                                function, args = found
                        return function, args
                else:
                        found = HttpServer.routes.get(request.path,None)
                        if found is None:
                                for route, func in HttpServer.wildroutes:
                                        if re.match(tools.strings.tostrings(route), tools.strings.tostrings(request.path)):
                                                found = func
                                                break
                                if found is None:
                                        staticRe = re.compile(&#34;^/(&#34;+tools.strings.tostrings(HttpServer.www_dir)+&#34;/.+|.+)&#34;)
                                        if staticRe.match(tools.strings.tostrings(request.path)):
                                                function, args = HttpServer.static_pages, {}
                                else:
                                        function, args = found
                        else:
                                function, args = found
                return function, args

        @staticmethod
        async def static_pages(request, response, args):
                &#34;&#34;&#34; Treat the case of static pages &#34;&#34;&#34;
                path = tools.strings.tobytes(HttpServer.www_dir) + request.path
                path = path.replace(b&#34;//&#34;,b&#34;/&#34;)
                if b&#34;..&#34; in path:
                        await response.send_error(status=b&#34;403&#34;,content=b&#34;Forbidden&#34;)
                else:
                        await response.send_file(path, headers=request.headers)

        @staticmethod
        def init():
                &#34;&#34;&#34; Initialize http server &#34;&#34;&#34;
                if HttpServer.config is None:
                        HttpServer.config = server.server.ServerConfig()
                        HttpServer.config.load_create()
                else:
                        HttpServer.config.refresh()

        @staticmethod
        def start(**kwargs):
                &#34;&#34;&#34; Start http server instance on selected port &#34;&#34;&#34;
                HttpServer.init()
                # If http activated
                if HttpServer.config.http:
                        kwargs[&#34;port&#34;] = kwargs.get(&#34;http_port&#34;,80)
                        kwargs[&#34;name&#34;] = kwargs.get(&#34;name&#34;,&#34;Http&#34;)
                        kwargs[&#34;backlog&#34;] = kwargs.get(&#34;backlog&#34;,5)
                        tools.tasking.Tasks.create_server(HttpServerInstance(**kwargs))
                else:
                        tools.logger.syslog(&#34;Http server disabled in config&#34;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.server.httpserver.HttpServer.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.loaded"><code class="name">var <span class="ident">loaded</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.menus"><code class="name">var <span class="ident">menus</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.pages"><code class="name">var <span class="ident">pages</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.routes"><code class="name">var <span class="ident">routes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.wildroutes"><code class="name">var <span class="ident">wildroutes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.server.httpserver.HttpServer.www_dir"><code class="name">var <span class="ident">www_dir</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.server.httpserver.HttpServer.add_pages"><code class="name flex">
<span>def <span class="ident">add_pages</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an html page loader which will be called when connecting to the http server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_pages():
        &#34;&#34;&#34; Add an html page loader which will be called when connecting to the http server &#34;&#34;&#34;
        def add_pages(function):
                HttpServer.pages.append(function)
                return function
        return add_pages</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.add_route"><code class="name flex">
<span>def <span class="ident">add_route</span></span>(<span>url, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a route to select an html page.
For the server to know the pages, it must imperatively use this decorator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def add_route(url, **kwargs):
        &#34;&#34;&#34; Add a route to select an html page.
        For the server to know the pages, it must imperatively use this decorator &#34;&#34;&#34;
        def add_route(function):
                if tools.strings.tobytes(url[-1]) == ord(b&#34;*&#34;):
                        HttpServer.wildroutes.append([tools.strings.tobytes(url),(function, kwargs)])
                else:
                        kwargs[&#34;index&#34;] = len(HttpServer.menus)
                        HttpServer.routes[tools.strings.tobytes(url)] = (function, kwargs)
                if kwargs.get(&#34;available&#34;, True):
                        if &#34;item&#34; in kwargs and &#34;menu&#34; in kwargs:
                                HttpServer.menus.append([kwargs[&#34;menu&#34;], kwargs[&#34;item&#34;],len(HttpServer.menus), tools.strings.tobytes(url)])
                                HttpServer.menus.sort()
                return function
        return add_route</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.call_preload"><code class="name flex">
<span>def <span class="ident">call_preload</span></span>(<span>loader)</span>
</code></dt>
<dd>
<div class="desc"><p>Call preload html page callback</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def call_preload(loader):
        &#34;&#34;&#34; Call preload html page callback &#34;&#34;&#34;
        if loader is not None:
                if tools.filesystem.ismicropython():
                        ModuleNotFound = ImportError
                else:
                        ModuleNotFound = ModuleNotFoundError
                try:
                        loader()
                except ModuleNotFound as err:
                        tools.logger.syslog(&#34;Preload html page : %s&#34;%str(err))
                except Exception as err:
                        tools.logger.syslog(err)</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.get_menus"><code class="name flex">
<span>def <span class="ident">get_menus</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Used to get the informations of menu</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_menus():
        &#34;&#34;&#34; Used to get the informations of menu &#34;&#34;&#34;
        return HttpServer.menus</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize http server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def init():
        &#34;&#34;&#34; Initialize http server &#34;&#34;&#34;
        if HttpServer.config is None:
                HttpServer.config = server.server.ServerConfig()
                HttpServer.config.load_create()
        else:
                HttpServer.config.refresh()</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.preload"><code class="name flex">
<span>def <span class="ident">preload</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Method used to preload page template.
You must define the content of a callback, which only import the python module with your pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def preload():
        &#34;&#34;&#34; Method used to preload page template.
        You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
        result = False
        if HttpServer.loaded[0] is False:
                from htmltemplate import WWW_DIR
                tools.logger.syslog(&#34;Html load pages&#34;)
                if len(HttpServer.pages) &gt; 0:
                        for loader in HttpServer.pages:
                                HttpServer.call_preload(loader)
                HttpServer.www_dir = WWW_DIR
                result = True
                HttpServer.loaded[0] = True
        return result</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.remove_route"><code class="name flex">
<span>def <span class="ident">remove_route</span></span>(<span>url=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a route of html page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_route(url=None):
        &#34;&#34;&#34; Remove a route of html page &#34;&#34;&#34;
        if url is None:
                HttpServer.routes = {}
                HttpServer.menus = []
        else:
                route = HttpServer.routes.get(url, None)
                if route:
                        del HttpServer.routes[url]
                        title = route[1].get(&#34;title&#34;, None)
                        if title:
                                i = 0
                                for item in HttpServer.menus:
                                        index, route, titl = item
                                        if titl == title:
                                                del HttpServer.menus[i]
                                                break
                                        i += 1</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.search_route"><code class="name flex">
<span>def <span class="ident">search_route</span></span>(<span>request)</span>
</code></dt>
<dd>
<div class="desc"><p>Search route according to the request</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def search_route(request):
        &#34;&#34;&#34; Search route according to the request &#34;&#34;&#34;
        function, args = None, None

        if request.method == b&#34;PUT&#34;:
                directory, file = tools.filesystem.split(tools.strings.tostrings(request.path))
                found = HttpServer.routes.get(tools.strings.tobytes(directory),None)
                if found:
                        function, args = found
                return function, args
        else:
                found = HttpServer.routes.get(request.path,None)
                if found is None:
                        for route, func in HttpServer.wildroutes:
                                if re.match(tools.strings.tostrings(route), tools.strings.tostrings(request.path)):
                                        found = func
                                        break
                        if found is None:
                                staticRe = re.compile(&#34;^/(&#34;+tools.strings.tostrings(HttpServer.www_dir)+&#34;/.+|.+)&#34;)
                                if staticRe.match(tools.strings.tostrings(request.path)):
                                        function, args = HttpServer.static_pages, {}
                        else:
                                function, args = found
                else:
                        function, args = found
        return function, args</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Start http server instance on selected port</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def start(**kwargs):
        &#34;&#34;&#34; Start http server instance on selected port &#34;&#34;&#34;
        HttpServer.init()
        # If http activated
        if HttpServer.config.http:
                kwargs[&#34;port&#34;] = kwargs.get(&#34;http_port&#34;,80)
                kwargs[&#34;name&#34;] = kwargs.get(&#34;name&#34;,&#34;Http&#34;)
                kwargs[&#34;backlog&#34;] = kwargs.get(&#34;backlog&#34;,5)
                tools.tasking.Tasks.create_server(HttpServerInstance(**kwargs))
        else:
                tools.logger.syslog(&#34;Http server disabled in config&#34;)</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServer.static_pages"><code class="name flex">
<span>async def <span class="ident">static_pages</span></span>(<span>request, response, args)</span>
</code></dt>
<dd>
<div class="desc"><p>Treat the case of static pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
async def static_pages(request, response, args):
        &#34;&#34;&#34; Treat the case of static pages &#34;&#34;&#34;
        path = tools.strings.tobytes(HttpServer.www_dir) + request.path
        path = path.replace(b&#34;//&#34;,b&#34;/&#34;)
        if b&#34;..&#34; in path:
                await response.send_error(status=b&#34;403&#34;,content=b&#34;Forbidden&#34;)
        else:
                await response.send_file(path, headers=request.headers)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.server.httpserver.HttpServerInstance"><code class="flex name class">
<span>class <span class="ident">HttpServerInstance</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Instance of server Http </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpServerInstance(tools.tasking.ServerInstance):
        &#34;&#34;&#34; Instance of server Http &#34;&#34;&#34;
        def __init__(self, **kwargs):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                tools.tasking.ServerInstance.__init__(self, **kwargs)
                self.server = None
                self.kwargs = kwargs

        def preload(self):
                &#34;&#34;&#34; Method used to preload page template.
                You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
                started = False
                if HttpServer.preload():
                        started = True

                if self.server is None:
                        tools.logger.syslog(&#34;Http &#39;%s&#39; started&#34;%self.kwargs.get(&#34;name&#34;,&#34;&#34;))
                        from server.httpservercore import HttpServerCore
                        self.server = HttpServerCore(**self.kwargs)
                        started = True

                if started:
                        tools.logger.syslog(&#34;Http &#39;%s&#39; ready on %d&#34;%(self.kwargs.get(&#34;name&#34;,&#34;&#34;), self.kwargs.get(&#34;port&#34;,0)))

        async def on_connection(self, reader, writer):
                &#34;&#34;&#34; Http server connection detected &#34;&#34;&#34;
                try:
                        # Preload the server
                        self.preload()

                        # Call on connection method
                        await self.server.on_connection(reader, writer)
                except Exception as err:
                        tools.logger.syslog(err)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tools.tasking.ServerInstance</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.server.httpserver.HttpServerInstance.on_connection"><code class="name flex">
<span>async def <span class="ident">on_connection</span></span>(<span>self, reader, writer)</span>
</code></dt>
<dd>
<div class="desc"><p>Http server connection detected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def on_connection(self, reader, writer):
        &#34;&#34;&#34; Http server connection detected &#34;&#34;&#34;
        try:
                # Preload the server
                self.preload()

                # Call on connection method
                await self.server.on_connection(reader, writer)
        except Exception as err:
                tools.logger.syslog(err)</code></pre>
</details>
</dd>
<dt id="lib.server.httpserver.HttpServerInstance.preload"><code class="name flex">
<span>def <span class="ident">preload</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method used to preload page template.
You must define the content of a callback, which only import the python module with your pages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preload(self):
        &#34;&#34;&#34; Method used to preload page template.
        You must define the content of a callback, which only import the python module with your pages &#34;&#34;&#34;
        started = False
        if HttpServer.preload():
                started = True

        if self.server is None:
                tools.logger.syslog(&#34;Http &#39;%s&#39; started&#34;%self.kwargs.get(&#34;name&#34;,&#34;&#34;))
                from server.httpservercore import HttpServerCore
                self.server = HttpServerCore(**self.kwargs)
                started = True

        if started:
                tools.logger.syslog(&#34;Http &#39;%s&#39; ready on %d&#34;%(self.kwargs.get(&#34;name&#34;,&#34;&#34;), self.kwargs.get(&#34;port&#34;,0)))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.server" href="index.html">lib.server</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.server.httpserver.HttpServer" href="#lib.server.httpserver.HttpServer">HttpServer</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.server.httpserver.HttpServer.add_pages" href="#lib.server.httpserver.HttpServer.add_pages">add_pages</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.add_route" href="#lib.server.httpserver.HttpServer.add_route">add_route</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.call_preload" href="#lib.server.httpserver.HttpServer.call_preload">call_preload</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.config" href="#lib.server.httpserver.HttpServer.config">config</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.get_menus" href="#lib.server.httpserver.HttpServer.get_menus">get_menus</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.init" href="#lib.server.httpserver.HttpServer.init">init</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.loaded" href="#lib.server.httpserver.HttpServer.loaded">loaded</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.menus" href="#lib.server.httpserver.HttpServer.menus">menus</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.pages" href="#lib.server.httpserver.HttpServer.pages">pages</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.preload" href="#lib.server.httpserver.HttpServer.preload">preload</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.remove_route" href="#lib.server.httpserver.HttpServer.remove_route">remove_route</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.routes" href="#lib.server.httpserver.HttpServer.routes">routes</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.search_route" href="#lib.server.httpserver.HttpServer.search_route">search_route</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.start" href="#lib.server.httpserver.HttpServer.start">start</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.static_pages" href="#lib.server.httpserver.HttpServer.static_pages">static_pages</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.wildroutes" href="#lib.server.httpserver.HttpServer.wildroutes">wildroutes</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServer.www_dir" href="#lib.server.httpserver.HttpServer.www_dir">www_dir</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.server.httpserver.HttpServerInstance" href="#lib.server.httpserver.HttpServerInstance">HttpServerInstance</a></code></h4>
<ul class="">
<li><code><a title="lib.server.httpserver.HttpServerInstance.on_connection" href="#lib.server.httpserver.HttpServerInstance.on_connection">on_connection</a></code></li>
<li><code><a title="lib.server.httpserver.HttpServerInstance.preload" href="#lib.server.httpserver.HttpServerInstance.preload">preload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>