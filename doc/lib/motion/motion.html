<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lib.motion.motion API documentation</title>
<meta name="description" content="Motion detection only work with ESP32CAM (Requires specially modified ESP32CAM firmware to handle motion detection.)" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.motion.motion</code></h1>
</header>
<section id="section-intro">
<p>Motion detection only work with ESP32CAM (Requires specially modified ESP32CAM firmware to handle motion detection.)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
&#34;&#34;&#34; Motion detection only work with ESP32CAM (Requires specially modified ESP32CAM firmware to handle motion detection.) &#34;&#34;&#34;
from gc import collect
import sys
import time
import uasyncio
import video
from server.notifier import Notifier
from server.server   import Server
from server.presence import Presence
from motion.historic import Historic
from video.video     import Camera
from tools import logger,jsonconfig,lang,linearfunction,tasking,strings,filesystem

class MotionConfig(jsonconfig.JsonConfig):
        &#34;&#34;&#34; Configuration class of motion detection &#34;&#34;&#34;
        def __init__(self):
                jsonconfig.JsonConfig.__init__(self)
                # Indicates if the motion is activated
                self.activated = False

                # Suspend the motion detection when presence detected
                self.suspend_on_presence = True

                # Minimum difference contigous threshold to detect movement
                self.differences_detection = 4

                # Sensitivity in percent (100% = max sensitivity, 0% = min sensitivity)
                self.sensitivity=80

                # Max images in motion historic
                self.max_motion_images=10

                # Glitch threshold of image ignored (sometime the camera bug)
                self.threshold_glitch=2

                # Threshold of minimum image to detect motion
                self.threshold_motion=3

                # Number of images before camera stabilization
                self.stabilization_camera=8

                # Turn on the led flash when the light goes down
                self.light_compensation = True

                # Notify motion detection or problem to save on sd card
                self.notify = True

                # Notify motion state change
                self.notify_state = True

                # Permanent detection without notification.
                # To keep all motion detection in the presence of occupants
                self.permanent_detection = False

                # Empty mask is equal disable masking
                self.mask = b&#34;&#34;

class ImageMotion:
        &#34;&#34;&#34; Class managing a motion detection image &#34;&#34;&#34;
        baseIndex = [0]
        motionBaseId = [0]
        created = [0]
        def __init__(self, motion, config):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.motion = motion
                self.baseIndex[0] += 1
                self.created[0] += 1
                self.index    = self.baseIndex[0]
                self.filename = None
                self.motion_id = None
                self.date     = strings.date_to_string()
                self.filename = strings.date_to_filename()
                path = strings.date_to_path()
                if path[-1] in [0x30,0x31,0x32,0x33,0x34]:
                        path = path[:-1] + b&#34;0&#34;
                else:
                        path = path[:-1] + b&#34;5&#34;
                self.path     = path
                self.motion_detected = False
                self.config = config
                self.comparison = None

        def deinit(self):
                &#34;&#34;&#34; Destructor &#34;&#34;&#34;
                self.created[0] -= 1
                if self.created[0] &gt;= 32:
                        print(&#34;Destroy %d&#34;%self.created[0])
                if self.motion:
                        self.motion.deinit()

        def set_motion_id(self, motion_id = None):
                &#34;&#34;&#34; Set the unique image identifier &#34;&#34;&#34;
                if motion_id is None:
                        self.motionBaseId[0] += 1
                        self.motion_id = self.motionBaseId[0]
                else:
                        if self.motion_id is None:
                                self.motion_id = motion_id
                        else:
                                print(&#34;Motion id already set&#34;)

        def get_motion_id(self):
                &#34;&#34;&#34; Get the unique image identifier &#34;&#34;&#34;
                return self.motion_id

        def get_filename(self):
                &#34;&#34;&#34; Get the storage filename &#34;&#34;&#34;
                return &#34;%s Id=%d D=%d&#34;%(self.filename, self.index, self.get_diff_count())

        def get_message(self):
                &#34;&#34;&#34; Get the message of motion &#34;&#34;&#34;
                return &#34;%s %s D=%d&#34;%(strings.tostrings(lang.motion_detected), self.date[-8:], self.get_diff_count())

        def get_informations(self):
                &#34;&#34;&#34; Return the informations of motion &#34;&#34;&#34;
                if self.comparison is not None:
                        result    = self.comparison.copy()
                else:
                        result = {}
                result[&#34;image&#34;]    = self.get_filename() + &#34;.jpg&#34;
                result[&#34;path&#34;]     = self.path
                result[&#34;index&#34;]    = self.index
                result[&#34;date&#34;]     = self.date
                result[&#34;motion_id&#34;] = self.motion_id
                return result

        async def save(self):
                &#34;&#34;&#34; Save the image on sd card &#34;&#34;&#34;
                return await Historic.add_motion(strings.tostrings(self.path), self.get_filename(), self.motion.get_image(), self.get_informations())

        def compare(self, previous):
                &#34;&#34;&#34; Compare two motion images to get differences &#34;&#34;&#34;
                res = self.motion.compare(previous.motion)
                self.comparison = res
                return res

        def get_motion_detected(self):
                &#34;&#34;&#34; Get the motion detection status &#34;&#34;&#34;
                return self.motion_detected

        def set_motion_detected(self):
                &#34;&#34;&#34; Set the motion detection status &#34;&#34;&#34;
                self.motion_detected = True

        def get(self):
                &#34;&#34;&#34; Get the image captured &#34;&#34;&#34;
                return self.motion.get_image()

        def get_comparison(self):
                &#34;&#34;&#34; Return the comparison result &#34;&#34;&#34;
                return self.comparison

        def get_diff_count(self):
                &#34;&#34;&#34; Get the difference contigous &#34;&#34;&#34;
                if self.comparison:
                        return self.comparison[&#34;diff&#34;][&#34;count&#34;]
                return 0

        def get_diff_histo(self):
                &#34;&#34;&#34; Get the histogram difference &#34;&#34;&#34;
                if self.comparison:
                        return self.comparison[&#34;diff&#34;][&#34;diffhisto&#34;]
                return 0

        def get_differences(self):
                &#34;&#34;&#34; Get the differences &#34;&#34;&#34;
                if self.comparison:
                        return self.comparison[&#34;diff&#34;][&#34;diffs&#34;]
                return &#34;&#34;

        def reset_differences(self):
                &#34;&#34;&#34; Reset the differences, used during the camera stabilization image &#34;&#34;&#34;
                self.comparison = None

        def get_size(self):
                &#34;&#34;&#34; Return the size of image buffer &#34;&#34;&#34;
                return self.motion.get_size()

        def refresh_config(self):
                &#34;&#34;&#34; Refresh the motion detection configuration &#34;&#34;&#34;
                if self.motion is not None:
                        mask = strings.tobytes(self.config.mask)
                        if not b&#34;/&#34; in mask:
                                mask = b&#34;&#34;
                        errorLight = linearfunction.get_fx(self.config.sensitivity, linearfunction.get_linear(100,8,0,64))
                        self.motion.configure(\
                                {
                                        &#34;mask&#34;:mask,
                                        &#34;errorLights&#34;:[[0,1],[128,errorLight],[192, errorLight],[256,errorLight]],
                                        &#34;errorHistos&#34;:[[0,0],[32,32],[128,128],[256,256]]
                                })

class SnapConfig:
        &#34;&#34;&#34; Store last motion information &#34;&#34;&#34;
        info = None

        @staticmethod
        def get(width=None, height=None):
                &#34;&#34;&#34; Get the last motion information &#34;&#34;&#34;
                if width is not None and height is not None:
                        SnapConfig.info = SnapConfig(width, height)
                elif SnapConfig.info is None:
                        SnapConfig.info = SnapConfig()
                return SnapConfig.info

        def __init__(self, width=800, height=600):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.width  = width
                self.height = height
                if (((self.width/8) % 8) == 0):
                        self.square_x = 64
                else:
                        self.square_x = 40

                if (((self.height/8) % 8) == 0):
                        self.square_y = 64
                else:
                        self.square_y = 40
                self.diff_x = self.width  // self.square_x
                self.diff_y = self.height // self.square_y
                self.max = self.diff_x * self.diff_y

class Motion:
        &#34;&#34;&#34; Class to manage the motion capture &#34;&#34;&#34;
        def __init__(self, config= None, pir_detection=False):
                self.images = []
                self.index  = 0
                self.config = config
                self.pir_detection = pir_detection
                self.image_background = None
                self.must_refresh_config = True
                self.quality = 15
                self.previous_quality = 0
                self.flash_level = 0

        def __del__(self):
                &#34;&#34;&#34; Destructor &#34;&#34;&#34;
                self.cleanup()

        def cleanup(self):
                &#34;&#34;&#34; Clean up all images &#34;&#34;&#34;
                for image in self.images:
                        if id(image) != id(self.image_background):
                                image.deinit()
                self.images = []
                if self.image_background:
                        self.image_background.deinit()
                self.image_background = None

        def open(self):
                &#34;&#34;&#34; Open camera &#34;&#34;&#34;
                if video.Camera.open():
                        return True
                else:
                        return False

        def resume(self):
                &#34;&#34;&#34; Resume the camera, restore the camera configuration after an interruption &#34;&#34;&#34;
                video.Camera.framesize(b&#34;%dx%d&#34;%(SnapConfig.get().width, SnapConfig.get().height))
                video.Camera.pixformat(b&#34;JPEG&#34;)
                video.Camera.quality(self.quality)
                video.Camera.brightness(0)
                video.Camera.contrast(0)
                video.Camera.saturation(0)
                video.Camera.hmirror(0)
                video.Camera.vflip(0)
                video.Camera.flash(self.flash_level)

                detected, change_polling = self.detect(False)
                if detected is False:
                        self.cleanup()

        def manage_flash(self, motion):
                &#34;&#34;&#34; Manage the flash level is low light &#34;&#34;&#34;
                # Light can be compensed with flash led
                if self.config.light_compensation:
                        # If it has enough light
                        if motion.get_light() &gt;= 50:
                                # If flash led working
                                if self.flash_level &gt; 8:
                                        # Reduce light of flash led
                                        self.flash_level -= 2
                                        video.Camera.flash(self.flash_level)
                        # If it has not enough light
                        elif motion.get_light() &lt;= 40:
                                # If flash to low
                                if self.flash_level &lt;= 192:
                                        # Increase the light of flash led
                                        self.flash_level += 2
                                        video.Camera.flash(self.flash_level)
                        # If low level for flash
                        if self.flash_level &lt; 8:
                                # Show motion started indicator
                                self.flash_level = 8
                                video.Camera.flash(self.flash_level)
                else:
                        self.stop_light()

        async def capture(self):
                &#34;&#34;&#34; Capture motion image &#34;&#34;&#34;
                result = None
                # If enough image taken
                if len(self.images) &gt;= self.config.max_motion_images:
                        # Get older image
                        image = self.images.pop()

                        # If motion detected on image, on battery the first five images are sent
                        if image.get_motion_detected() or (self.pir_detection and image.index &lt;= 3):
                                # Notification of motion
                                result = (image.get_message(), image)

                                # Save image to sdcard
                                if await image.save() is False:
                                        if self.config.notify:
                                                await Notifier.notify(lang.failed_to_save)
                        else:
                                # Destroy image
                                self.deinit_image(image)

                motion = video.Camera.motion()
                self.manage_flash(motion)
                image = ImageMotion(motion, self.config)
                if self.must_refresh_config:
                        image.refresh_config()
                        self.must_refresh_config = False
                self.images.insert(0, image)
                self.index += 1
                return result

        def stop_light(self):
                &#34;&#34;&#34; Stop the light &#34;&#34;&#34;
                # If flash led working and compensation disabled
                if self.flash_level &gt; 0:
                        # Stop flash led
                        self.flash_level = 0
                        video.Camera.flash(self.flash_level)

        def refresh_config(self):
                &#34;&#34;&#34; Force the refresh of motion configuration &#34;&#34;&#34;
                self.must_refresh_config = True

        def is_stabilized(self):
                &#34;&#34;&#34; Indicates if the camera is stabilized &#34;&#34;&#34;
                # If the PIR detection force the stabilization
                if self.pir_detection is True:
                        stabilized = True
                # If the camera not stabilized
                elif len(self.images) &lt; self.config.stabilization_camera and len(self.images) &lt; self.config.max_motion_images:
                        stabilized = False
                else:
                        stabilized = True
                return stabilized

        def is_detected(self, comparison):
                &#34;&#34;&#34; Indicates if motion detected &#34;&#34;&#34;
                if comparison:
                        # If image seem not equal to previous
                        if comparison[&#34;diff&#34;][&#34;count&#34;] &gt;= self.config.differences_detection:
                                return True
                return False

        def adjust_quality(self, current):
                &#34;&#34;&#34; Adjust the image quality according to the size of image (the max possible is 64K) &#34;&#34;&#34;
                if len(self.images) &gt;= self.config.max_motion_images:
                        changed = False
                        size = current.get_size()
                        if size &gt; 62*1024:
                                if self.quality &lt; 63:
                                        self.quality += 1
                                        changed = True
                                        video.Camera.quality(self.quality, False)
                        else:
                                if self.quality &gt;= 1:
                                        if size &lt; 50*1024:
                                                self.quality -= 1
                                                changed = True
                                                video.Camera.quality(self.quality, False)
                        if changed is False:
                                if self.previous_quality != self.quality:
                                        self.previous_quality = self.quality

        def compare(self, display=True):
                &#34;&#34;&#34; Compare all images captured and search differences &#34;&#34;&#34;
                differences = {}
                if len(self.images) &gt;= 2:
                        current = self.images[0]

                        self.adjust_quality(current)

                        # Compute the motion identifier
                        for previous in self.images[1:]:
                                # # If image not already compared
                                comparison = current.compare(previous)

                                # If camera not stabilized
                                if self.is_stabilized() is False:
                                        # Reject the differences
                                        current.reset_differences()
                                        break

                                # If image seem equal to previous
                                if not self.is_detected(comparison):
                                        # Reuse the motion identifier
                                        current.set_motion_id(previous.motion_id)
                                        break
                        else:
                                # Create new motion id
                                current.set_motion_id()

                                # Compare the image with the background if existing and extract modification
                                if self.image_background is not None:
                                        comparison = current.compare(self.image_background)

                        # Compute the list of differences
                        diffs = b&#34;&#34;
                        index = 0
                        for image in self.images:
                                differences.setdefault(image.get_motion_id(), []).append(image.get_motion_id())
                                if image.get_motion_id() is not None:
                                        if image.index % 10 == 0:
                                                trace = b&#34;_&#34;
                                        else:
                                                trace = b&#34; &#34;
                                        if image.index &gt; index:
                                                index = image.index
                                        diffs += b&#34;%d:%d%s%s&#34;%(image.get_motion_id(), image.get_diff_count(), (0x41 + ((256-image.get_diff_histo())//10)).to_bytes(1, &#39;big&#39;), trace)
                        if display:
                                line = b&#34;\r%s %s (%d) &#34;%(strings.date_to_bytes()[12:], bytes(diffs), index)
                                if filesystem.ismicropython():
                                        sys.stdout.write(line)
                                else:
                                        sys.stdout.write(line.decode(&#34;utf8&#34;))
                return differences

        def deinit_image(self, image):
                &#34;&#34;&#34; Release image allocated &#34;&#34;&#34;
                if image:
                        if not image in self.images:
                                if image != self.image_background:
                                        image.deinit()

        def detect(self, display=True):
                &#34;&#34;&#34; Detect motion &#34;&#34;&#34;
                detected = False
                change_polling = False

                # Compute the list of differences
                differences = self.compare(display)

                # Too many differences found
                if len(list(differences.keys())) &gt;= self.config.threshold_motion:
                        detected = True
                        change_polling = True
                # If no differences
                elif len(list(differences.keys())) == 1:
                        image = self.image_background
                        self.image_background = self.images[0]
                        self.deinit_image(image)
                        detected = False
                # If not enough differences
                elif len(list(differences.keys())) &lt;= self.config.threshold_glitch:
                        detected = True
                        change_polling = True
                        # Check if it is a glitch
                        for diff in differences.values():
                                if len(diff) &lt;= 1:
                                        # Glitch ignored
                                        detected = False
                                        break
                # Not detected
                else:
                        detected = False

                if detected:
                        # Mark all motion images
                        for image in self.images:
                                # If image seem not equal to previous
                                if self.is_detected(image.get_comparison()):
                                        image.set_motion_detected()
                return detected, change_polling

class Detection:
        &#34;&#34;&#34; Asynchronous motion detection object &#34;&#34;&#34;
        def __init__(self, pir_detection):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.pir_detection = pir_detection
                self.load_config()
                self.motion = None

                self.battery_level = -2
                if self.pir_detection is True:
                        self.polling_frequency = 3
                else:
                        self.polling_frequency = 100
                self.detection = None
                self.activated = None
                self.refresh_config_counter = 0
                self.cadencer = NotificationCadencer()

        def load_config(self):
                &#34;&#34;&#34; Load motion configuration &#34;&#34;&#34;
                # Open motion configuration
                self.motion_config      = MotionConfig()
                if self.motion_config.load() is False:
                        self.motion_config.save()

        def refresh_config(self):
                &#34;&#34;&#34; Refresh the configuration : it can be changed by web page &#34;&#34;&#34;
                if self.refresh_config_counter % 11 == 0:
                        # If configuration changed
                        if self.motion_config.is_changed():
                                self.motion_config.load()
                                logger.syslog(&#34;Change motion config %s&#34;%self.motion_config.to_string(), display=False)
                                if self.motion:
                                        self.motion.refresh_config()
                self.refresh_config_counter += 1

        async def run(self):
                &#34;&#34;&#34; Main asynchronous task &#34;&#34;&#34;
                await tasking.task_monitoring(self.detect)

        async def detect(self):
                &#34;&#34;&#34; Detect motion &#34;&#34;&#34;
                result = False
                # Wait the server resume
                await Server.wait_resume()

                # Release previously alocated image
                self.release_image()

                # If the motion detection activated
                activated = await self.is_activated()
                if activated or self.is_pemanent():
                        # Capture motion
                        result = await self.capture(activated)
                else:
                        if self.motion:
                                self.motion.stop_light()
                        await uasyncio.sleep(10)
                self.cadencer.refresh()

                # Refresh configuration when it changed
                self.refresh_config()

                return result

        async def is_activated(self):
                &#34;&#34;&#34; Indicates if the motion detection is activated according to configuration or presence &#34;&#34;&#34;
                result = False

                # If motion activated
                if self.motion_config.activated:
                        # If motion must be suspended on presence
                        if self.motion_config.suspend_on_presence:
                                # If home is empty
                                if Presence.is_detected() is False:
                                        result = True
                        else:
                                result = True

                # If state of motion changed
                if self.activated != result:
                        # Force garbage collection
                        collect()

                        # If notification enabled
                        if self.motion_config.notify_state:
                                if result:
                                        await Notifier.notify(lang.motion_detection_on)
                                else:
                                        await Notifier.notify(lang.motion_detection_off)
                        self.activated = result

                # If camera activated and motion activated
                if Camera.is_activated() and result:
                        result = True
                else:
                        result = False

                # If motion disabled
                if result is False and self.is_pemanent() is False:
                        # Wait moment before next loop
                        await uasyncio.sleep_ms(500)
                return result

        def is_pemanent(self):
                &#34;&#34;&#34; Indicates if pemanent detection activated &#34;&#34;&#34;
                result = False
                # If motion activated
                if self.motion_config.activated:
                        # If detection permanent without notification activated
                        if self.motion_config.permanent_detection:
                                result = True
                return result

        async def init_motion(self):
                &#34;&#34;&#34; Initialize motion detection &#34;&#34;&#34;
                firstInit = False

                # If motion not initialized
                if self.motion is None:
                        self.motion = Motion(self.motion_config, self.pir_detection)
                        if self.motion.open() is False:
                                self.motion = None
                                raise Exception(&#34;Cannot open camera&#34;)
                        else:
                                firstInit = True

                # If the camera configuration changed
                if video.Camera.is_modified() or firstInit:
                        # Restore motion configuration
                        self.motion.resume()
                        video.Camera.clear_modified()

        def release_image(self):
                &#34;&#34;&#34; Release motion image allocated &#34;&#34;&#34;
                # If detection
                if self.detection:
                        message, image = self.detection
                        # Release image buffer
                        self.motion.deinit_image(image)

                # Force garbage collection each 20 images
                if self.motion:
                        if self.motion.index %30 == 0:
                                collect()

        async def capture(self, activated):
                &#34;&#34;&#34; Capture motion &#34;&#34;&#34;
                result = False

                # If camera not stabilized speed start
                if self.motion and self.motion.is_stabilized() is True:
                        frequency = self.polling_frequency*500 if Server.is_slow() else self.polling_frequency
                        await uasyncio.sleep_ms(frequency)

                try:
                        # Waits for the camera&#39;s availability
                        reserved = await video.Camera.reserve(self, timeout=60)

                        # If reserved
                        if reserved:
                                # Initialize motion detection
                                await self.init_motion()

                                # Capture motion image
                                self.detection = await self.motion.capture()

                                # If motion detected and detection activated
                                if self.detection is not None and activated is True:
                                        # Notify motion with push over
                                        message, image = self.detection
                                        if self.motion_config.notify:
                                                if self.cadencer.can_notify():
                                                        await Notifier.notify(message, image.get())
                                                else:
                                                        logger.syslog(message + &#34; ignored&#34;)
                                # Detect motion
                                detected, change_polling = self.motion.detect()

                                # If motion found
                                if change_polling is True:
                                        # Speed up the polling frequency
                                        self.polling_frequency = 10
                                        Historic.set_motion_state(True)
                                else:
                                        # Slow down the polling frequency
                                        self.polling_frequency = 50
                                        Historic.set_motion_state(False)
                                result = True
                        else:
                                if self.motion_config.notify_state:
                                        await Notifier.notify(lang.motion_detection_suspended)
                                result = True

                finally:
                        if reserved:
                                await video.Camera.unreserve(self)
                return result

class MovingCounters:
        &#34;&#34;&#34; Manages an event counter with a history &#34;&#34;&#34;
        def __init__(self, proof, step):
                &#34;&#34;&#34; Constructor, proof=indicates the depth of the history, step=duration in seconds of each history step &#34;&#34;&#34;
                self.total = 0
                self.step = step
                self.counters = []
                for i in range(proof):
                        self.counters.insert(0,[0,0])

        def refresh(self, increase=0):
                &#34;&#34;&#34; Refresh counter history, increase=1 forces the counter to increment else the counter history updated &#34;&#34;&#34;
                t = int(time.time())

                if self.counters[-1][0] + self.step &lt; t:
                        self.total   -= self.counters[0][1]
                        self.counters = self.counters[1:]
                        self.counters.append([t,0])

                self.counters[-1][1] += increase
                self.total += increase

        def get_total(self):
                &#34;&#34;&#34; Returns the total value of the counted values. &#34;&#34;&#34;
                return self.total

class NotificationCadencer(MovingCounters):
        &#34;&#34;&#34; Cadencer for motion detection notifications
        Parameters:
                batch (int):size of a notification batch before changing the wait time
                duration (int):duration in seconds to add when a batch has ended
                max_duration (int):max waiting value&#34;&#34;&#34;
        def __init__(self, batch=5, duration=15, max_duration=60):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MovingCounters.__init__(self, 20, 60)
                self.last = 0
                self.max_duration = max_duration
                self.duration = duration
                self.batch = batch

        def can_notify(self):
                &#34;&#34;&#34; Indicates whether a notification can be sent or not &#34;&#34;&#34;
                self.refresh(0)

                total = self.get_total() // self.batch

                if total &gt;= 1:
                        duration = (1&lt;&lt;(total-1))*self.duration
                        if duration &gt; self.max_duration:
                                duration = self.max_duration
                else:
                        duration = 0

                t = int(time.time())
                if self.last + duration &lt;= t:
                        self.refresh(1)
                        self.last = t
                        result = True
                else:
                        result = False
                return result

async def detect_motion(pir_detection):
        &#34;&#34;&#34; Asynchronous motion detection main routine &#34;&#34;&#34;
        detection = Detection(pir_detection)
        await detection.run()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lib.motion.motion.detect_motion"><code class="name flex">
<span>async def <span class="ident">detect_motion</span></span>(<span>pir_detection)</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronous motion detection main routine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def detect_motion(pir_detection):
        &#34;&#34;&#34; Asynchronous motion detection main routine &#34;&#34;&#34;
        detection = Detection(pir_detection)
        await detection.run()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.motion.motion.Detection"><code class="flex name class">
<span>class <span class="ident">Detection</span></span>
<span>(</span><span>pir_detection)</span>
</code></dt>
<dd>
<div class="desc"><p>Asynchronous motion detection object </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Detection:
        &#34;&#34;&#34; Asynchronous motion detection object &#34;&#34;&#34;
        def __init__(self, pir_detection):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.pir_detection = pir_detection
                self.load_config()
                self.motion = None

                self.battery_level = -2
                if self.pir_detection is True:
                        self.polling_frequency = 3
                else:
                        self.polling_frequency = 100
                self.detection = None
                self.activated = None
                self.refresh_config_counter = 0
                self.cadencer = NotificationCadencer()

        def load_config(self):
                &#34;&#34;&#34; Load motion configuration &#34;&#34;&#34;
                # Open motion configuration
                self.motion_config      = MotionConfig()
                if self.motion_config.load() is False:
                        self.motion_config.save()

        def refresh_config(self):
                &#34;&#34;&#34; Refresh the configuration : it can be changed by web page &#34;&#34;&#34;
                if self.refresh_config_counter % 11 == 0:
                        # If configuration changed
                        if self.motion_config.is_changed():
                                self.motion_config.load()
                                logger.syslog(&#34;Change motion config %s&#34;%self.motion_config.to_string(), display=False)
                                if self.motion:
                                        self.motion.refresh_config()
                self.refresh_config_counter += 1

        async def run(self):
                &#34;&#34;&#34; Main asynchronous task &#34;&#34;&#34;
                await tasking.task_monitoring(self.detect)

        async def detect(self):
                &#34;&#34;&#34; Detect motion &#34;&#34;&#34;
                result = False
                # Wait the server resume
                await Server.wait_resume()

                # Release previously alocated image
                self.release_image()

                # If the motion detection activated
                activated = await self.is_activated()
                if activated or self.is_pemanent():
                        # Capture motion
                        result = await self.capture(activated)
                else:
                        if self.motion:
                                self.motion.stop_light()
                        await uasyncio.sleep(10)
                self.cadencer.refresh()

                # Refresh configuration when it changed
                self.refresh_config()

                return result

        async def is_activated(self):
                &#34;&#34;&#34; Indicates if the motion detection is activated according to configuration or presence &#34;&#34;&#34;
                result = False

                # If motion activated
                if self.motion_config.activated:
                        # If motion must be suspended on presence
                        if self.motion_config.suspend_on_presence:
                                # If home is empty
                                if Presence.is_detected() is False:
                                        result = True
                        else:
                                result = True

                # If state of motion changed
                if self.activated != result:
                        # Force garbage collection
                        collect()

                        # If notification enabled
                        if self.motion_config.notify_state:
                                if result:
                                        await Notifier.notify(lang.motion_detection_on)
                                else:
                                        await Notifier.notify(lang.motion_detection_off)
                        self.activated = result

                # If camera activated and motion activated
                if Camera.is_activated() and result:
                        result = True
                else:
                        result = False

                # If motion disabled
                if result is False and self.is_pemanent() is False:
                        # Wait moment before next loop
                        await uasyncio.sleep_ms(500)
                return result

        def is_pemanent(self):
                &#34;&#34;&#34; Indicates if pemanent detection activated &#34;&#34;&#34;
                result = False
                # If motion activated
                if self.motion_config.activated:
                        # If detection permanent without notification activated
                        if self.motion_config.permanent_detection:
                                result = True
                return result

        async def init_motion(self):
                &#34;&#34;&#34; Initialize motion detection &#34;&#34;&#34;
                firstInit = False

                # If motion not initialized
                if self.motion is None:
                        self.motion = Motion(self.motion_config, self.pir_detection)
                        if self.motion.open() is False:
                                self.motion = None
                                raise Exception(&#34;Cannot open camera&#34;)
                        else:
                                firstInit = True

                # If the camera configuration changed
                if video.Camera.is_modified() or firstInit:
                        # Restore motion configuration
                        self.motion.resume()
                        video.Camera.clear_modified()

        def release_image(self):
                &#34;&#34;&#34; Release motion image allocated &#34;&#34;&#34;
                # If detection
                if self.detection:
                        message, image = self.detection
                        # Release image buffer
                        self.motion.deinit_image(image)

                # Force garbage collection each 20 images
                if self.motion:
                        if self.motion.index %30 == 0:
                                collect()

        async def capture(self, activated):
                &#34;&#34;&#34; Capture motion &#34;&#34;&#34;
                result = False

                # If camera not stabilized speed start
                if self.motion and self.motion.is_stabilized() is True:
                        frequency = self.polling_frequency*500 if Server.is_slow() else self.polling_frequency
                        await uasyncio.sleep_ms(frequency)

                try:
                        # Waits for the camera&#39;s availability
                        reserved = await video.Camera.reserve(self, timeout=60)

                        # If reserved
                        if reserved:
                                # Initialize motion detection
                                await self.init_motion()

                                # Capture motion image
                                self.detection = await self.motion.capture()

                                # If motion detected and detection activated
                                if self.detection is not None and activated is True:
                                        # Notify motion with push over
                                        message, image = self.detection
                                        if self.motion_config.notify:
                                                if self.cadencer.can_notify():
                                                        await Notifier.notify(message, image.get())
                                                else:
                                                        logger.syslog(message + &#34; ignored&#34;)
                                # Detect motion
                                detected, change_polling = self.motion.detect()

                                # If motion found
                                if change_polling is True:
                                        # Speed up the polling frequency
                                        self.polling_frequency = 10
                                        Historic.set_motion_state(True)
                                else:
                                        # Slow down the polling frequency
                                        self.polling_frequency = 50
                                        Historic.set_motion_state(False)
                                result = True
                        else:
                                if self.motion_config.notify_state:
                                        await Notifier.notify(lang.motion_detection_suspended)
                                result = True

                finally:
                        if reserved:
                                await video.Camera.unreserve(self)
                return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.motion.motion.Detection.capture"><code class="name flex">
<span>async def <span class="ident">capture</span></span>(<span>self, activated)</span>
</code></dt>
<dd>
<div class="desc"><p>Capture motion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def capture(self, activated):
        &#34;&#34;&#34; Capture motion &#34;&#34;&#34;
        result = False

        # If camera not stabilized speed start
        if self.motion and self.motion.is_stabilized() is True:
                frequency = self.polling_frequency*500 if Server.is_slow() else self.polling_frequency
                await uasyncio.sleep_ms(frequency)

        try:
                # Waits for the camera&#39;s availability
                reserved = await video.Camera.reserve(self, timeout=60)

                # If reserved
                if reserved:
                        # Initialize motion detection
                        await self.init_motion()

                        # Capture motion image
                        self.detection = await self.motion.capture()

                        # If motion detected and detection activated
                        if self.detection is not None and activated is True:
                                # Notify motion with push over
                                message, image = self.detection
                                if self.motion_config.notify:
                                        if self.cadencer.can_notify():
                                                await Notifier.notify(message, image.get())
                                        else:
                                                logger.syslog(message + &#34; ignored&#34;)
                        # Detect motion
                        detected, change_polling = self.motion.detect()

                        # If motion found
                        if change_polling is True:
                                # Speed up the polling frequency
                                self.polling_frequency = 10
                                Historic.set_motion_state(True)
                        else:
                                # Slow down the polling frequency
                                self.polling_frequency = 50
                                Historic.set_motion_state(False)
                        result = True
                else:
                        if self.motion_config.notify_state:
                                await Notifier.notify(lang.motion_detection_suspended)
                        result = True

        finally:
                if reserved:
                        await video.Camera.unreserve(self)
        return result</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Detection.detect"><code class="name flex">
<span>async def <span class="ident">detect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Detect motion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def detect(self):
        &#34;&#34;&#34; Detect motion &#34;&#34;&#34;
        result = False
        # Wait the server resume
        await Server.wait_resume()

        # Release previously alocated image
        self.release_image()

        # If the motion detection activated
        activated = await self.is_activated()
        if activated or self.is_pemanent():
                # Capture motion
                result = await self.capture(activated)
        else:
                if self.motion:
                        self.motion.stop_light()
                await uasyncio.sleep(10)
        self.cadencer.refresh()

        # Refresh configuration when it changed
        self.refresh_config()

        return result</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Detection.init_motion"><code class="name flex">
<span>async def <span class="ident">init_motion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize motion detection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def init_motion(self):
        &#34;&#34;&#34; Initialize motion detection &#34;&#34;&#34;
        firstInit = False

        # If motion not initialized
        if self.motion is None:
                self.motion = Motion(self.motion_config, self.pir_detection)
                if self.motion.open() is False:
                        self.motion = None
                        raise Exception(&#34;Cannot open camera&#34;)
                else:
                        firstInit = True

        # If the camera configuration changed
        if video.Camera.is_modified() or firstInit:
                # Restore motion configuration
                self.motion.resume()
                video.Camera.clear_modified()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Detection.is_activated"><code class="name flex">
<span>async def <span class="ident">is_activated</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the motion detection is activated according to configuration or presence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_activated(self):
        &#34;&#34;&#34; Indicates if the motion detection is activated according to configuration or presence &#34;&#34;&#34;
        result = False

        # If motion activated
        if self.motion_config.activated:
                # If motion must be suspended on presence
                if self.motion_config.suspend_on_presence:
                        # If home is empty
                        if Presence.is_detected() is False:
                                result = True
                else:
                        result = True

        # If state of motion changed
        if self.activated != result:
                # Force garbage collection
                collect()

                # If notification enabled
                if self.motion_config.notify_state:
                        if result:
                                await Notifier.notify(lang.motion_detection_on)
                        else:
                                await Notifier.notify(lang.motion_detection_off)
                self.activated = result

        # If camera activated and motion activated
        if Camera.is_activated() and result:
                result = True
        else:
                result = False

        # If motion disabled
        if result is False and self.is_pemanent() is False:
                # Wait moment before next loop
                await uasyncio.sleep_ms(500)
        return result</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Detection.is_pemanent"><code class="name flex">
<span>def <span class="ident">is_pemanent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if pemanent detection activated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_pemanent(self):
        &#34;&#34;&#34; Indicates if pemanent detection activated &#34;&#34;&#34;
        result = False
        # If motion activated
        if self.motion_config.activated:
                # If detection permanent without notification activated
                if self.motion_config.permanent_detection:
                        result = True
        return result</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Detection.load_config"><code class="name flex">
<span>def <span class="ident">load_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load motion configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_config(self):
        &#34;&#34;&#34; Load motion configuration &#34;&#34;&#34;
        # Open motion configuration
        self.motion_config      = MotionConfig()
        if self.motion_config.load() is False:
                self.motion_config.save()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Detection.refresh_config"><code class="name flex">
<span>def <span class="ident">refresh_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the configuration : it can be changed by web page</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_config(self):
        &#34;&#34;&#34; Refresh the configuration : it can be changed by web page &#34;&#34;&#34;
        if self.refresh_config_counter % 11 == 0:
                # If configuration changed
                if self.motion_config.is_changed():
                        self.motion_config.load()
                        logger.syslog(&#34;Change motion config %s&#34;%self.motion_config.to_string(), display=False)
                        if self.motion:
                                self.motion.refresh_config()
        self.refresh_config_counter += 1</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Detection.release_image"><code class="name flex">
<span>def <span class="ident">release_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Release motion image allocated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release_image(self):
        &#34;&#34;&#34; Release motion image allocated &#34;&#34;&#34;
        # If detection
        if self.detection:
                message, image = self.detection
                # Release image buffer
                self.motion.deinit_image(image)

        # Force garbage collection each 20 images
        if self.motion:
                if self.motion.index %30 == 0:
                        collect()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Detection.run"><code class="name flex">
<span>async def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Main asynchronous task</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def run(self):
        &#34;&#34;&#34; Main asynchronous task &#34;&#34;&#34;
        await tasking.task_monitoring(self.detect)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.motion.motion.ImageMotion"><code class="flex name class">
<span>class <span class="ident">ImageMotion</span></span>
<span>(</span><span>motion, config)</span>
</code></dt>
<dd>
<div class="desc"><p>Class managing a motion detection image </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ImageMotion:
        &#34;&#34;&#34; Class managing a motion detection image &#34;&#34;&#34;
        baseIndex = [0]
        motionBaseId = [0]
        created = [0]
        def __init__(self, motion, config):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.motion = motion
                self.baseIndex[0] += 1
                self.created[0] += 1
                self.index    = self.baseIndex[0]
                self.filename = None
                self.motion_id = None
                self.date     = strings.date_to_string()
                self.filename = strings.date_to_filename()
                path = strings.date_to_path()
                if path[-1] in [0x30,0x31,0x32,0x33,0x34]:
                        path = path[:-1] + b&#34;0&#34;
                else:
                        path = path[:-1] + b&#34;5&#34;
                self.path     = path
                self.motion_detected = False
                self.config = config
                self.comparison = None

        def deinit(self):
                &#34;&#34;&#34; Destructor &#34;&#34;&#34;
                self.created[0] -= 1
                if self.created[0] &gt;= 32:
                        print(&#34;Destroy %d&#34;%self.created[0])
                if self.motion:
                        self.motion.deinit()

        def set_motion_id(self, motion_id = None):
                &#34;&#34;&#34; Set the unique image identifier &#34;&#34;&#34;
                if motion_id is None:
                        self.motionBaseId[0] += 1
                        self.motion_id = self.motionBaseId[0]
                else:
                        if self.motion_id is None:
                                self.motion_id = motion_id
                        else:
                                print(&#34;Motion id already set&#34;)

        def get_motion_id(self):
                &#34;&#34;&#34; Get the unique image identifier &#34;&#34;&#34;
                return self.motion_id

        def get_filename(self):
                &#34;&#34;&#34; Get the storage filename &#34;&#34;&#34;
                return &#34;%s Id=%d D=%d&#34;%(self.filename, self.index, self.get_diff_count())

        def get_message(self):
                &#34;&#34;&#34; Get the message of motion &#34;&#34;&#34;
                return &#34;%s %s D=%d&#34;%(strings.tostrings(lang.motion_detected), self.date[-8:], self.get_diff_count())

        def get_informations(self):
                &#34;&#34;&#34; Return the informations of motion &#34;&#34;&#34;
                if self.comparison is not None:
                        result    = self.comparison.copy()
                else:
                        result = {}
                result[&#34;image&#34;]    = self.get_filename() + &#34;.jpg&#34;
                result[&#34;path&#34;]     = self.path
                result[&#34;index&#34;]    = self.index
                result[&#34;date&#34;]     = self.date
                result[&#34;motion_id&#34;] = self.motion_id
                return result

        async def save(self):
                &#34;&#34;&#34; Save the image on sd card &#34;&#34;&#34;
                return await Historic.add_motion(strings.tostrings(self.path), self.get_filename(), self.motion.get_image(), self.get_informations())

        def compare(self, previous):
                &#34;&#34;&#34; Compare two motion images to get differences &#34;&#34;&#34;
                res = self.motion.compare(previous.motion)
                self.comparison = res
                return res

        def get_motion_detected(self):
                &#34;&#34;&#34; Get the motion detection status &#34;&#34;&#34;
                return self.motion_detected

        def set_motion_detected(self):
                &#34;&#34;&#34; Set the motion detection status &#34;&#34;&#34;
                self.motion_detected = True

        def get(self):
                &#34;&#34;&#34; Get the image captured &#34;&#34;&#34;
                return self.motion.get_image()

        def get_comparison(self):
                &#34;&#34;&#34; Return the comparison result &#34;&#34;&#34;
                return self.comparison

        def get_diff_count(self):
                &#34;&#34;&#34; Get the difference contigous &#34;&#34;&#34;
                if self.comparison:
                        return self.comparison[&#34;diff&#34;][&#34;count&#34;]
                return 0

        def get_diff_histo(self):
                &#34;&#34;&#34; Get the histogram difference &#34;&#34;&#34;
                if self.comparison:
                        return self.comparison[&#34;diff&#34;][&#34;diffhisto&#34;]
                return 0

        def get_differences(self):
                &#34;&#34;&#34; Get the differences &#34;&#34;&#34;
                if self.comparison:
                        return self.comparison[&#34;diff&#34;][&#34;diffs&#34;]
                return &#34;&#34;

        def reset_differences(self):
                &#34;&#34;&#34; Reset the differences, used during the camera stabilization image &#34;&#34;&#34;
                self.comparison = None

        def get_size(self):
                &#34;&#34;&#34; Return the size of image buffer &#34;&#34;&#34;
                return self.motion.get_size()

        def refresh_config(self):
                &#34;&#34;&#34; Refresh the motion detection configuration &#34;&#34;&#34;
                if self.motion is not None:
                        mask = strings.tobytes(self.config.mask)
                        if not b&#34;/&#34; in mask:
                                mask = b&#34;&#34;
                        errorLight = linearfunction.get_fx(self.config.sensitivity, linearfunction.get_linear(100,8,0,64))
                        self.motion.configure(\
                                {
                                        &#34;mask&#34;:mask,
                                        &#34;errorLights&#34;:[[0,1],[128,errorLight],[192, errorLight],[256,errorLight]],
                                        &#34;errorHistos&#34;:[[0,0],[32,32],[128,128],[256,256]]
                                })</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.motion.motion.ImageMotion.baseIndex"><code class="name">var <span class="ident">baseIndex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.motion.motion.ImageMotion.created"><code class="name">var <span class="ident">created</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.motion.motion.ImageMotion.motionBaseId"><code class="name">var <span class="ident">motionBaseId</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lib.motion.motion.ImageMotion.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, previous)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare two motion images to get differences</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare(self, previous):
        &#34;&#34;&#34; Compare two motion images to get differences &#34;&#34;&#34;
        res = self.motion.compare(previous.motion)
        self.comparison = res
        return res</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.deinit"><code class="name flex">
<span>def <span class="ident">deinit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Destructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deinit(self):
        &#34;&#34;&#34; Destructor &#34;&#34;&#34;
        self.created[0] -= 1
        if self.created[0] &gt;= 32:
                print(&#34;Destroy %d&#34;%self.created[0])
        if self.motion:
                self.motion.deinit()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the image captured</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self):
        &#34;&#34;&#34; Get the image captured &#34;&#34;&#34;
        return self.motion.get_image()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_comparison"><code class="name flex">
<span>def <span class="ident">get_comparison</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the comparison result</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_comparison(self):
        &#34;&#34;&#34; Return the comparison result &#34;&#34;&#34;
        return self.comparison</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_diff_count"><code class="name flex">
<span>def <span class="ident">get_diff_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the difference contigous</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_diff_count(self):
        &#34;&#34;&#34; Get the difference contigous &#34;&#34;&#34;
        if self.comparison:
                return self.comparison[&#34;diff&#34;][&#34;count&#34;]
        return 0</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_diff_histo"><code class="name flex">
<span>def <span class="ident">get_diff_histo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the histogram difference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_diff_histo(self):
        &#34;&#34;&#34; Get the histogram difference &#34;&#34;&#34;
        if self.comparison:
                return self.comparison[&#34;diff&#34;][&#34;diffhisto&#34;]
        return 0</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_differences"><code class="name flex">
<span>def <span class="ident">get_differences</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the differences</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_differences(self):
        &#34;&#34;&#34; Get the differences &#34;&#34;&#34;
        if self.comparison:
                return self.comparison[&#34;diff&#34;][&#34;diffs&#34;]
        return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_filename"><code class="name flex">
<span>def <span class="ident">get_filename</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the storage filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_filename(self):
        &#34;&#34;&#34; Get the storage filename &#34;&#34;&#34;
        return &#34;%s Id=%d D=%d&#34;%(self.filename, self.index, self.get_diff_count())</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_informations"><code class="name flex">
<span>def <span class="ident">get_informations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the informations of motion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_informations(self):
        &#34;&#34;&#34; Return the informations of motion &#34;&#34;&#34;
        if self.comparison is not None:
                result    = self.comparison.copy()
        else:
                result = {}
        result[&#34;image&#34;]    = self.get_filename() + &#34;.jpg&#34;
        result[&#34;path&#34;]     = self.path
        result[&#34;index&#34;]    = self.index
        result[&#34;date&#34;]     = self.date
        result[&#34;motion_id&#34;] = self.motion_id
        return result</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_message"><code class="name flex">
<span>def <span class="ident">get_message</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the message of motion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_message(self):
        &#34;&#34;&#34; Get the message of motion &#34;&#34;&#34;
        return &#34;%s %s D=%d&#34;%(strings.tostrings(lang.motion_detected), self.date[-8:], self.get_diff_count())</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_motion_detected"><code class="name flex">
<span>def <span class="ident">get_motion_detected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the motion detection status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_motion_detected(self):
        &#34;&#34;&#34; Get the motion detection status &#34;&#34;&#34;
        return self.motion_detected</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_motion_id"><code class="name flex">
<span>def <span class="ident">get_motion_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the unique image identifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_motion_id(self):
        &#34;&#34;&#34; Get the unique image identifier &#34;&#34;&#34;
        return self.motion_id</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the size of image buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self):
        &#34;&#34;&#34; Return the size of image buffer &#34;&#34;&#34;
        return self.motion.get_size()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.refresh_config"><code class="name flex">
<span>def <span class="ident">refresh_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the motion detection configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_config(self):
        &#34;&#34;&#34; Refresh the motion detection configuration &#34;&#34;&#34;
        if self.motion is not None:
                mask = strings.tobytes(self.config.mask)
                if not b&#34;/&#34; in mask:
                        mask = b&#34;&#34;
                errorLight = linearfunction.get_fx(self.config.sensitivity, linearfunction.get_linear(100,8,0,64))
                self.motion.configure(\
                        {
                                &#34;mask&#34;:mask,
                                &#34;errorLights&#34;:[[0,1],[128,errorLight],[192, errorLight],[256,errorLight]],
                                &#34;errorHistos&#34;:[[0,0],[32,32],[128,128],[256,256]]
                        })</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.reset_differences"><code class="name flex">
<span>def <span class="ident">reset_differences</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the differences, used during the camera stabilization image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_differences(self):
        &#34;&#34;&#34; Reset the differences, used during the camera stabilization image &#34;&#34;&#34;
        self.comparison = None</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.save"><code class="name flex">
<span>async def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the image on sd card</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def save(self):
        &#34;&#34;&#34; Save the image on sd card &#34;&#34;&#34;
        return await Historic.add_motion(strings.tostrings(self.path), self.get_filename(), self.motion.get_image(), self.get_informations())</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.set_motion_detected"><code class="name flex">
<span>def <span class="ident">set_motion_detected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the motion detection status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motion_detected(self):
        &#34;&#34;&#34; Set the motion detection status &#34;&#34;&#34;
        self.motion_detected = True</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.ImageMotion.set_motion_id"><code class="name flex">
<span>def <span class="ident">set_motion_id</span></span>(<span>self, motion_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the unique image identifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_motion_id(self, motion_id = None):
        &#34;&#34;&#34; Set the unique image identifier &#34;&#34;&#34;
        if motion_id is None:
                self.motionBaseId[0] += 1
                self.motion_id = self.motionBaseId[0]
        else:
                if self.motion_id is None:
                        self.motion_id = motion_id
                else:
                        print(&#34;Motion id already set&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.motion.motion.Motion"><code class="flex name class">
<span>class <span class="ident">Motion</span></span>
<span>(</span><span>config=None, pir_detection=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to manage the motion capture</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Motion:
        &#34;&#34;&#34; Class to manage the motion capture &#34;&#34;&#34;
        def __init__(self, config= None, pir_detection=False):
                self.images = []
                self.index  = 0
                self.config = config
                self.pir_detection = pir_detection
                self.image_background = None
                self.must_refresh_config = True
                self.quality = 15
                self.previous_quality = 0
                self.flash_level = 0

        def __del__(self):
                &#34;&#34;&#34; Destructor &#34;&#34;&#34;
                self.cleanup()

        def cleanup(self):
                &#34;&#34;&#34; Clean up all images &#34;&#34;&#34;
                for image in self.images:
                        if id(image) != id(self.image_background):
                                image.deinit()
                self.images = []
                if self.image_background:
                        self.image_background.deinit()
                self.image_background = None

        def open(self):
                &#34;&#34;&#34; Open camera &#34;&#34;&#34;
                if video.Camera.open():
                        return True
                else:
                        return False

        def resume(self):
                &#34;&#34;&#34; Resume the camera, restore the camera configuration after an interruption &#34;&#34;&#34;
                video.Camera.framesize(b&#34;%dx%d&#34;%(SnapConfig.get().width, SnapConfig.get().height))
                video.Camera.pixformat(b&#34;JPEG&#34;)
                video.Camera.quality(self.quality)
                video.Camera.brightness(0)
                video.Camera.contrast(0)
                video.Camera.saturation(0)
                video.Camera.hmirror(0)
                video.Camera.vflip(0)
                video.Camera.flash(self.flash_level)

                detected, change_polling = self.detect(False)
                if detected is False:
                        self.cleanup()

        def manage_flash(self, motion):
                &#34;&#34;&#34; Manage the flash level is low light &#34;&#34;&#34;
                # Light can be compensed with flash led
                if self.config.light_compensation:
                        # If it has enough light
                        if motion.get_light() &gt;= 50:
                                # If flash led working
                                if self.flash_level &gt; 8:
                                        # Reduce light of flash led
                                        self.flash_level -= 2
                                        video.Camera.flash(self.flash_level)
                        # If it has not enough light
                        elif motion.get_light() &lt;= 40:
                                # If flash to low
                                if self.flash_level &lt;= 192:
                                        # Increase the light of flash led
                                        self.flash_level += 2
                                        video.Camera.flash(self.flash_level)
                        # If low level for flash
                        if self.flash_level &lt; 8:
                                # Show motion started indicator
                                self.flash_level = 8
                                video.Camera.flash(self.flash_level)
                else:
                        self.stop_light()

        async def capture(self):
                &#34;&#34;&#34; Capture motion image &#34;&#34;&#34;
                result = None
                # If enough image taken
                if len(self.images) &gt;= self.config.max_motion_images:
                        # Get older image
                        image = self.images.pop()

                        # If motion detected on image, on battery the first five images are sent
                        if image.get_motion_detected() or (self.pir_detection and image.index &lt;= 3):
                                # Notification of motion
                                result = (image.get_message(), image)

                                # Save image to sdcard
                                if await image.save() is False:
                                        if self.config.notify:
                                                await Notifier.notify(lang.failed_to_save)
                        else:
                                # Destroy image
                                self.deinit_image(image)

                motion = video.Camera.motion()
                self.manage_flash(motion)
                image = ImageMotion(motion, self.config)
                if self.must_refresh_config:
                        image.refresh_config()
                        self.must_refresh_config = False
                self.images.insert(0, image)
                self.index += 1
                return result

        def stop_light(self):
                &#34;&#34;&#34; Stop the light &#34;&#34;&#34;
                # If flash led working and compensation disabled
                if self.flash_level &gt; 0:
                        # Stop flash led
                        self.flash_level = 0
                        video.Camera.flash(self.flash_level)

        def refresh_config(self):
                &#34;&#34;&#34; Force the refresh of motion configuration &#34;&#34;&#34;
                self.must_refresh_config = True

        def is_stabilized(self):
                &#34;&#34;&#34; Indicates if the camera is stabilized &#34;&#34;&#34;
                # If the PIR detection force the stabilization
                if self.pir_detection is True:
                        stabilized = True
                # If the camera not stabilized
                elif len(self.images) &lt; self.config.stabilization_camera and len(self.images) &lt; self.config.max_motion_images:
                        stabilized = False
                else:
                        stabilized = True
                return stabilized

        def is_detected(self, comparison):
                &#34;&#34;&#34; Indicates if motion detected &#34;&#34;&#34;
                if comparison:
                        # If image seem not equal to previous
                        if comparison[&#34;diff&#34;][&#34;count&#34;] &gt;= self.config.differences_detection:
                                return True
                return False

        def adjust_quality(self, current):
                &#34;&#34;&#34; Adjust the image quality according to the size of image (the max possible is 64K) &#34;&#34;&#34;
                if len(self.images) &gt;= self.config.max_motion_images:
                        changed = False
                        size = current.get_size()
                        if size &gt; 62*1024:
                                if self.quality &lt; 63:
                                        self.quality += 1
                                        changed = True
                                        video.Camera.quality(self.quality, False)
                        else:
                                if self.quality &gt;= 1:
                                        if size &lt; 50*1024:
                                                self.quality -= 1
                                                changed = True
                                                video.Camera.quality(self.quality, False)
                        if changed is False:
                                if self.previous_quality != self.quality:
                                        self.previous_quality = self.quality

        def compare(self, display=True):
                &#34;&#34;&#34; Compare all images captured and search differences &#34;&#34;&#34;
                differences = {}
                if len(self.images) &gt;= 2:
                        current = self.images[0]

                        self.adjust_quality(current)

                        # Compute the motion identifier
                        for previous in self.images[1:]:
                                # # If image not already compared
                                comparison = current.compare(previous)

                                # If camera not stabilized
                                if self.is_stabilized() is False:
                                        # Reject the differences
                                        current.reset_differences()
                                        break

                                # If image seem equal to previous
                                if not self.is_detected(comparison):
                                        # Reuse the motion identifier
                                        current.set_motion_id(previous.motion_id)
                                        break
                        else:
                                # Create new motion id
                                current.set_motion_id()

                                # Compare the image with the background if existing and extract modification
                                if self.image_background is not None:
                                        comparison = current.compare(self.image_background)

                        # Compute the list of differences
                        diffs = b&#34;&#34;
                        index = 0
                        for image in self.images:
                                differences.setdefault(image.get_motion_id(), []).append(image.get_motion_id())
                                if image.get_motion_id() is not None:
                                        if image.index % 10 == 0:
                                                trace = b&#34;_&#34;
                                        else:
                                                trace = b&#34; &#34;
                                        if image.index &gt; index:
                                                index = image.index
                                        diffs += b&#34;%d:%d%s%s&#34;%(image.get_motion_id(), image.get_diff_count(), (0x41 + ((256-image.get_diff_histo())//10)).to_bytes(1, &#39;big&#39;), trace)
                        if display:
                                line = b&#34;\r%s %s (%d) &#34;%(strings.date_to_bytes()[12:], bytes(diffs), index)
                                if filesystem.ismicropython():
                                        sys.stdout.write(line)
                                else:
                                        sys.stdout.write(line.decode(&#34;utf8&#34;))
                return differences

        def deinit_image(self, image):
                &#34;&#34;&#34; Release image allocated &#34;&#34;&#34;
                if image:
                        if not image in self.images:
                                if image != self.image_background:
                                        image.deinit()

        def detect(self, display=True):
                &#34;&#34;&#34; Detect motion &#34;&#34;&#34;
                detected = False
                change_polling = False

                # Compute the list of differences
                differences = self.compare(display)

                # Too many differences found
                if len(list(differences.keys())) &gt;= self.config.threshold_motion:
                        detected = True
                        change_polling = True
                # If no differences
                elif len(list(differences.keys())) == 1:
                        image = self.image_background
                        self.image_background = self.images[0]
                        self.deinit_image(image)
                        detected = False
                # If not enough differences
                elif len(list(differences.keys())) &lt;= self.config.threshold_glitch:
                        detected = True
                        change_polling = True
                        # Check if it is a glitch
                        for diff in differences.values():
                                if len(diff) &lt;= 1:
                                        # Glitch ignored
                                        detected = False
                                        break
                # Not detected
                else:
                        detected = False

                if detected:
                        # Mark all motion images
                        for image in self.images:
                                # If image seem not equal to previous
                                if self.is_detected(image.get_comparison()):
                                        image.set_motion_detected()
                return detected, change_polling</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.motion.motion.Motion.adjust_quality"><code class="name flex">
<span>def <span class="ident">adjust_quality</span></span>(<span>self, current)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the image quality according to the size of image (the max possible is 64K)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_quality(self, current):
        &#34;&#34;&#34; Adjust the image quality according to the size of image (the max possible is 64K) &#34;&#34;&#34;
        if len(self.images) &gt;= self.config.max_motion_images:
                changed = False
                size = current.get_size()
                if size &gt; 62*1024:
                        if self.quality &lt; 63:
                                self.quality += 1
                                changed = True
                                video.Camera.quality(self.quality, False)
                else:
                        if self.quality &gt;= 1:
                                if size &lt; 50*1024:
                                        self.quality -= 1
                                        changed = True
                                        video.Camera.quality(self.quality, False)
                if changed is False:
                        if self.previous_quality != self.quality:
                                self.previous_quality = self.quality</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.capture"><code class="name flex">
<span>async def <span class="ident">capture</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Capture motion image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def capture(self):
        &#34;&#34;&#34; Capture motion image &#34;&#34;&#34;
        result = None
        # If enough image taken
        if len(self.images) &gt;= self.config.max_motion_images:
                # Get older image
                image = self.images.pop()

                # If motion detected on image, on battery the first five images are sent
                if image.get_motion_detected() or (self.pir_detection and image.index &lt;= 3):
                        # Notification of motion
                        result = (image.get_message(), image)

                        # Save image to sdcard
                        if await image.save() is False:
                                if self.config.notify:
                                        await Notifier.notify(lang.failed_to_save)
                else:
                        # Destroy image
                        self.deinit_image(image)

        motion = video.Camera.motion()
        self.manage_flash(motion)
        image = ImageMotion(motion, self.config)
        if self.must_refresh_config:
                image.refresh_config()
                self.must_refresh_config = False
        self.images.insert(0, image)
        self.index += 1
        return result</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean up all images</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self):
        &#34;&#34;&#34; Clean up all images &#34;&#34;&#34;
        for image in self.images:
                if id(image) != id(self.image_background):
                        image.deinit()
        self.images = []
        if self.image_background:
                self.image_background.deinit()
        self.image_background = None</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.compare"><code class="name flex">
<span>def <span class="ident">compare</span></span>(<span>self, display=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare all images captured and search differences</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare(self, display=True):
        &#34;&#34;&#34; Compare all images captured and search differences &#34;&#34;&#34;
        differences = {}
        if len(self.images) &gt;= 2:
                current = self.images[0]

                self.adjust_quality(current)

                # Compute the motion identifier
                for previous in self.images[1:]:
                        # # If image not already compared
                        comparison = current.compare(previous)

                        # If camera not stabilized
                        if self.is_stabilized() is False:
                                # Reject the differences
                                current.reset_differences()
                                break

                        # If image seem equal to previous
                        if not self.is_detected(comparison):
                                # Reuse the motion identifier
                                current.set_motion_id(previous.motion_id)
                                break
                else:
                        # Create new motion id
                        current.set_motion_id()

                        # Compare the image with the background if existing and extract modification
                        if self.image_background is not None:
                                comparison = current.compare(self.image_background)

                # Compute the list of differences
                diffs = b&#34;&#34;
                index = 0
                for image in self.images:
                        differences.setdefault(image.get_motion_id(), []).append(image.get_motion_id())
                        if image.get_motion_id() is not None:
                                if image.index % 10 == 0:
                                        trace = b&#34;_&#34;
                                else:
                                        trace = b&#34; &#34;
                                if image.index &gt; index:
                                        index = image.index
                                diffs += b&#34;%d:%d%s%s&#34;%(image.get_motion_id(), image.get_diff_count(), (0x41 + ((256-image.get_diff_histo())//10)).to_bytes(1, &#39;big&#39;), trace)
                if display:
                        line = b&#34;\r%s %s (%d) &#34;%(strings.date_to_bytes()[12:], bytes(diffs), index)
                        if filesystem.ismicropython():
                                sys.stdout.write(line)
                        else:
                                sys.stdout.write(line.decode(&#34;utf8&#34;))
        return differences</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.deinit_image"><code class="name flex">
<span>def <span class="ident">deinit_image</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Release image allocated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deinit_image(self, image):
        &#34;&#34;&#34; Release image allocated &#34;&#34;&#34;
        if image:
                if not image in self.images:
                        if image != self.image_background:
                                image.deinit()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.detect"><code class="name flex">
<span>def <span class="ident">detect</span></span>(<span>self, display=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Detect motion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect(self, display=True):
        &#34;&#34;&#34; Detect motion &#34;&#34;&#34;
        detected = False
        change_polling = False

        # Compute the list of differences
        differences = self.compare(display)

        # Too many differences found
        if len(list(differences.keys())) &gt;= self.config.threshold_motion:
                detected = True
                change_polling = True
        # If no differences
        elif len(list(differences.keys())) == 1:
                image = self.image_background
                self.image_background = self.images[0]
                self.deinit_image(image)
                detected = False
        # If not enough differences
        elif len(list(differences.keys())) &lt;= self.config.threshold_glitch:
                detected = True
                change_polling = True
                # Check if it is a glitch
                for diff in differences.values():
                        if len(diff) &lt;= 1:
                                # Glitch ignored
                                detected = False
                                break
        # Not detected
        else:
                detected = False

        if detected:
                # Mark all motion images
                for image in self.images:
                        # If image seem not equal to previous
                        if self.is_detected(image.get_comparison()):
                                image.set_motion_detected()
        return detected, change_polling</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.is_detected"><code class="name flex">
<span>def <span class="ident">is_detected</span></span>(<span>self, comparison)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if motion detected</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_detected(self, comparison):
        &#34;&#34;&#34; Indicates if motion detected &#34;&#34;&#34;
        if comparison:
                # If image seem not equal to previous
                if comparison[&#34;diff&#34;][&#34;count&#34;] &gt;= self.config.differences_detection:
                        return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.is_stabilized"><code class="name flex">
<span>def <span class="ident">is_stabilized</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the camera is stabilized</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_stabilized(self):
        &#34;&#34;&#34; Indicates if the camera is stabilized &#34;&#34;&#34;
        # If the PIR detection force the stabilization
        if self.pir_detection is True:
                stabilized = True
        # If the camera not stabilized
        elif len(self.images) &lt; self.config.stabilization_camera and len(self.images) &lt; self.config.max_motion_images:
                stabilized = False
        else:
                stabilized = True
        return stabilized</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.manage_flash"><code class="name flex">
<span>def <span class="ident">manage_flash</span></span>(<span>self, motion)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the flash level is low light</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def manage_flash(self, motion):
        &#34;&#34;&#34; Manage the flash level is low light &#34;&#34;&#34;
        # Light can be compensed with flash led
        if self.config.light_compensation:
                # If it has enough light
                if motion.get_light() &gt;= 50:
                        # If flash led working
                        if self.flash_level &gt; 8:
                                # Reduce light of flash led
                                self.flash_level -= 2
                                video.Camera.flash(self.flash_level)
                # If it has not enough light
                elif motion.get_light() &lt;= 40:
                        # If flash to low
                        if self.flash_level &lt;= 192:
                                # Increase the light of flash led
                                self.flash_level += 2
                                video.Camera.flash(self.flash_level)
                # If low level for flash
                if self.flash_level &lt; 8:
                        # Show motion started indicator
                        self.flash_level = 8
                        video.Camera.flash(self.flash_level)
        else:
                self.stop_light()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Open camera</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self):
        &#34;&#34;&#34; Open camera &#34;&#34;&#34;
        if video.Camera.open():
                return True
        else:
                return False</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.refresh_config"><code class="name flex">
<span>def <span class="ident">refresh_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Force the refresh of motion configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_config(self):
        &#34;&#34;&#34; Force the refresh of motion configuration &#34;&#34;&#34;
        self.must_refresh_config = True</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.resume"><code class="name flex">
<span>def <span class="ident">resume</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resume the camera, restore the camera configuration after an interruption</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resume(self):
        &#34;&#34;&#34; Resume the camera, restore the camera configuration after an interruption &#34;&#34;&#34;
        video.Camera.framesize(b&#34;%dx%d&#34;%(SnapConfig.get().width, SnapConfig.get().height))
        video.Camera.pixformat(b&#34;JPEG&#34;)
        video.Camera.quality(self.quality)
        video.Camera.brightness(0)
        video.Camera.contrast(0)
        video.Camera.saturation(0)
        video.Camera.hmirror(0)
        video.Camera.vflip(0)
        video.Camera.flash(self.flash_level)

        detected, change_polling = self.detect(False)
        if detected is False:
                self.cleanup()</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.Motion.stop_light"><code class="name flex">
<span>def <span class="ident">stop_light</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the light</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_light(self):
        &#34;&#34;&#34; Stop the light &#34;&#34;&#34;
        # If flash led working and compensation disabled
        if self.flash_level &gt; 0:
                # Stop flash led
                self.flash_level = 0
                video.Camera.flash(self.flash_level)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.motion.motion.MotionConfig"><code class="flex name class">
<span>class <span class="ident">MotionConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Configuration class of motion detection </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MotionConfig(jsonconfig.JsonConfig):
        &#34;&#34;&#34; Configuration class of motion detection &#34;&#34;&#34;
        def __init__(self):
                jsonconfig.JsonConfig.__init__(self)
                # Indicates if the motion is activated
                self.activated = False

                # Suspend the motion detection when presence detected
                self.suspend_on_presence = True

                # Minimum difference contigous threshold to detect movement
                self.differences_detection = 4

                # Sensitivity in percent (100% = max sensitivity, 0% = min sensitivity)
                self.sensitivity=80

                # Max images in motion historic
                self.max_motion_images=10

                # Glitch threshold of image ignored (sometime the camera bug)
                self.threshold_glitch=2

                # Threshold of minimum image to detect motion
                self.threshold_motion=3

                # Number of images before camera stabilization
                self.stabilization_camera=8

                # Turn on the led flash when the light goes down
                self.light_compensation = True

                # Notify motion detection or problem to save on sd card
                self.notify = True

                # Notify motion state change
                self.notify_state = True

                # Permanent detection without notification.
                # To keep all motion detection in the presence of occupants
                self.permanent_detection = False

                # Empty mask is equal disable masking
                self.mask = b&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tools.jsonconfig.JsonConfig</li>
</ul>
</dd>
<dt id="lib.motion.motion.MovingCounters"><code class="flex name class">
<span>class <span class="ident">MovingCounters</span></span>
<span>(</span><span>proof, step)</span>
</code></dt>
<dd>
<div class="desc"><p>Manages an event counter with a history </p>
<p>Constructor, proof=indicates the depth of the history, step=duration in seconds of each history step</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MovingCounters:
        &#34;&#34;&#34; Manages an event counter with a history &#34;&#34;&#34;
        def __init__(self, proof, step):
                &#34;&#34;&#34; Constructor, proof=indicates the depth of the history, step=duration in seconds of each history step &#34;&#34;&#34;
                self.total = 0
                self.step = step
                self.counters = []
                for i in range(proof):
                        self.counters.insert(0,[0,0])

        def refresh(self, increase=0):
                &#34;&#34;&#34; Refresh counter history, increase=1 forces the counter to increment else the counter history updated &#34;&#34;&#34;
                t = int(time.time())

                if self.counters[-1][0] + self.step &lt; t:
                        self.total   -= self.counters[0][1]
                        self.counters = self.counters[1:]
                        self.counters.append([t,0])

                self.counters[-1][1] += increase
                self.total += increase

        def get_total(self):
                &#34;&#34;&#34; Returns the total value of the counted values. &#34;&#34;&#34;
                return self.total</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lib.motion.motion.NotificationCadencer" href="#lib.motion.motion.NotificationCadencer">NotificationCadencer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.motion.motion.MovingCounters.get_total"><code class="name flex">
<span>def <span class="ident">get_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the total value of the counted values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_total(self):
        &#34;&#34;&#34; Returns the total value of the counted values. &#34;&#34;&#34;
        return self.total</code></pre>
</details>
</dd>
<dt id="lib.motion.motion.MovingCounters.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, increase=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh counter history, increase=1 forces the counter to increment else the counter history updated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self, increase=0):
        &#34;&#34;&#34; Refresh counter history, increase=1 forces the counter to increment else the counter history updated &#34;&#34;&#34;
        t = int(time.time())

        if self.counters[-1][0] + self.step &lt; t:
                self.total   -= self.counters[0][1]
                self.counters = self.counters[1:]
                self.counters.append([t,0])

        self.counters[-1][1] += increase
        self.total += increase</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.motion.motion.NotificationCadencer"><code class="flex name class">
<span>class <span class="ident">NotificationCadencer</span></span>
<span>(</span><span>batch=5, duration=15, max_duration=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Cadencer for motion detection notifications</p>
<h2 id="parameters">Parameters</h2>
<p>batch (int):size of a notification batch before changing the wait time
duration (int):duration in seconds to add when a batch has ended
max_duration (int):max waiting value</p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotificationCadencer(MovingCounters):
        &#34;&#34;&#34; Cadencer for motion detection notifications
        Parameters:
                batch (int):size of a notification batch before changing the wait time
                duration (int):duration in seconds to add when a batch has ended
                max_duration (int):max waiting value&#34;&#34;&#34;
        def __init__(self, batch=5, duration=15, max_duration=60):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                MovingCounters.__init__(self, 20, 60)
                self.last = 0
                self.max_duration = max_duration
                self.duration = duration
                self.batch = batch

        def can_notify(self):
                &#34;&#34;&#34; Indicates whether a notification can be sent or not &#34;&#34;&#34;
                self.refresh(0)

                total = self.get_total() // self.batch

                if total &gt;= 1:
                        duration = (1&lt;&lt;(total-1))*self.duration
                        if duration &gt; self.max_duration:
                                duration = self.max_duration
                else:
                        duration = 0

                t = int(time.time())
                if self.last + duration &lt;= t:
                        self.refresh(1)
                        self.last = t
                        result = True
                else:
                        result = False
                return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lib.motion.motion.MovingCounters" href="#lib.motion.motion.MovingCounters">MovingCounters</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lib.motion.motion.NotificationCadencer.can_notify"><code class="name flex">
<span>def <span class="ident">can_notify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates whether a notification can be sent or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_notify(self):
        &#34;&#34;&#34; Indicates whether a notification can be sent or not &#34;&#34;&#34;
        self.refresh(0)

        total = self.get_total() // self.batch

        if total &gt;= 1:
                duration = (1&lt;&lt;(total-1))*self.duration
                if duration &gt; self.max_duration:
                        duration = self.max_duration
        else:
                duration = 0

        t = int(time.time())
        if self.last + duration &lt;= t:
                self.refresh(1)
                self.last = t
                result = True
        else:
                result = False
        return result</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lib.motion.motion.MovingCounters" href="#lib.motion.motion.MovingCounters">MovingCounters</a></b></code>:
<ul class="hlist">
<li><code><a title="lib.motion.motion.MovingCounters.get_total" href="#lib.motion.motion.MovingCounters.get_total">get_total</a></code></li>
<li><code><a title="lib.motion.motion.MovingCounters.refresh" href="#lib.motion.motion.MovingCounters.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lib.motion.motion.SnapConfig"><code class="flex name class">
<span>class <span class="ident">SnapConfig</span></span>
<span>(</span><span>width=800, height=600)</span>
</code></dt>
<dd>
<div class="desc"><p>Store last motion information </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SnapConfig:
        &#34;&#34;&#34; Store last motion information &#34;&#34;&#34;
        info = None

        @staticmethod
        def get(width=None, height=None):
                &#34;&#34;&#34; Get the last motion information &#34;&#34;&#34;
                if width is not None and height is not None:
                        SnapConfig.info = SnapConfig(width, height)
                elif SnapConfig.info is None:
                        SnapConfig.info = SnapConfig()
                return SnapConfig.info

        def __init__(self, width=800, height=600):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.width  = width
                self.height = height
                if (((self.width/8) % 8) == 0):
                        self.square_x = 64
                else:
                        self.square_x = 40

                if (((self.height/8) % 8) == 0):
                        self.square_y = 64
                else:
                        self.square_y = 40
                self.diff_x = self.width  // self.square_x
                self.diff_y = self.height // self.square_y
                self.max = self.diff_x * self.diff_y</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.motion.motion.SnapConfig.info"><code class="name">var <span class="ident">info</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.motion.motion.SnapConfig.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>width=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the last motion information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get(width=None, height=None):
        &#34;&#34;&#34; Get the last motion information &#34;&#34;&#34;
        if width is not None and height is not None:
                SnapConfig.info = SnapConfig(width, height)
        elif SnapConfig.info is None:
                SnapConfig.info = SnapConfig()
        return SnapConfig.info</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.motion" href="index.html">lib.motion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lib.motion.motion.detect_motion" href="#lib.motion.motion.detect_motion">detect_motion</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.motion.motion.Detection" href="#lib.motion.motion.Detection">Detection</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.motion.motion.Detection.capture" href="#lib.motion.motion.Detection.capture">capture</a></code></li>
<li><code><a title="lib.motion.motion.Detection.detect" href="#lib.motion.motion.Detection.detect">detect</a></code></li>
<li><code><a title="lib.motion.motion.Detection.init_motion" href="#lib.motion.motion.Detection.init_motion">init_motion</a></code></li>
<li><code><a title="lib.motion.motion.Detection.is_activated" href="#lib.motion.motion.Detection.is_activated">is_activated</a></code></li>
<li><code><a title="lib.motion.motion.Detection.is_pemanent" href="#lib.motion.motion.Detection.is_pemanent">is_pemanent</a></code></li>
<li><code><a title="lib.motion.motion.Detection.load_config" href="#lib.motion.motion.Detection.load_config">load_config</a></code></li>
<li><code><a title="lib.motion.motion.Detection.refresh_config" href="#lib.motion.motion.Detection.refresh_config">refresh_config</a></code></li>
<li><code><a title="lib.motion.motion.Detection.release_image" href="#lib.motion.motion.Detection.release_image">release_image</a></code></li>
<li><code><a title="lib.motion.motion.Detection.run" href="#lib.motion.motion.Detection.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.motion.motion.ImageMotion" href="#lib.motion.motion.ImageMotion">ImageMotion</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.motion.motion.ImageMotion.baseIndex" href="#lib.motion.motion.ImageMotion.baseIndex">baseIndex</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.compare" href="#lib.motion.motion.ImageMotion.compare">compare</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.created" href="#lib.motion.motion.ImageMotion.created">created</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.deinit" href="#lib.motion.motion.ImageMotion.deinit">deinit</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get" href="#lib.motion.motion.ImageMotion.get">get</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_comparison" href="#lib.motion.motion.ImageMotion.get_comparison">get_comparison</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_diff_count" href="#lib.motion.motion.ImageMotion.get_diff_count">get_diff_count</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_diff_histo" href="#lib.motion.motion.ImageMotion.get_diff_histo">get_diff_histo</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_differences" href="#lib.motion.motion.ImageMotion.get_differences">get_differences</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_filename" href="#lib.motion.motion.ImageMotion.get_filename">get_filename</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_informations" href="#lib.motion.motion.ImageMotion.get_informations">get_informations</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_message" href="#lib.motion.motion.ImageMotion.get_message">get_message</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_motion_detected" href="#lib.motion.motion.ImageMotion.get_motion_detected">get_motion_detected</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_motion_id" href="#lib.motion.motion.ImageMotion.get_motion_id">get_motion_id</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.get_size" href="#lib.motion.motion.ImageMotion.get_size">get_size</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.motionBaseId" href="#lib.motion.motion.ImageMotion.motionBaseId">motionBaseId</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.refresh_config" href="#lib.motion.motion.ImageMotion.refresh_config">refresh_config</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.reset_differences" href="#lib.motion.motion.ImageMotion.reset_differences">reset_differences</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.save" href="#lib.motion.motion.ImageMotion.save">save</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.set_motion_detected" href="#lib.motion.motion.ImageMotion.set_motion_detected">set_motion_detected</a></code></li>
<li><code><a title="lib.motion.motion.ImageMotion.set_motion_id" href="#lib.motion.motion.ImageMotion.set_motion_id">set_motion_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.motion.motion.Motion" href="#lib.motion.motion.Motion">Motion</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.motion.motion.Motion.adjust_quality" href="#lib.motion.motion.Motion.adjust_quality">adjust_quality</a></code></li>
<li><code><a title="lib.motion.motion.Motion.capture" href="#lib.motion.motion.Motion.capture">capture</a></code></li>
<li><code><a title="lib.motion.motion.Motion.cleanup" href="#lib.motion.motion.Motion.cleanup">cleanup</a></code></li>
<li><code><a title="lib.motion.motion.Motion.compare" href="#lib.motion.motion.Motion.compare">compare</a></code></li>
<li><code><a title="lib.motion.motion.Motion.deinit_image" href="#lib.motion.motion.Motion.deinit_image">deinit_image</a></code></li>
<li><code><a title="lib.motion.motion.Motion.detect" href="#lib.motion.motion.Motion.detect">detect</a></code></li>
<li><code><a title="lib.motion.motion.Motion.is_detected" href="#lib.motion.motion.Motion.is_detected">is_detected</a></code></li>
<li><code><a title="lib.motion.motion.Motion.is_stabilized" href="#lib.motion.motion.Motion.is_stabilized">is_stabilized</a></code></li>
<li><code><a title="lib.motion.motion.Motion.manage_flash" href="#lib.motion.motion.Motion.manage_flash">manage_flash</a></code></li>
<li><code><a title="lib.motion.motion.Motion.open" href="#lib.motion.motion.Motion.open">open</a></code></li>
<li><code><a title="lib.motion.motion.Motion.refresh_config" href="#lib.motion.motion.Motion.refresh_config">refresh_config</a></code></li>
<li><code><a title="lib.motion.motion.Motion.resume" href="#lib.motion.motion.Motion.resume">resume</a></code></li>
<li><code><a title="lib.motion.motion.Motion.stop_light" href="#lib.motion.motion.Motion.stop_light">stop_light</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.motion.motion.MotionConfig" href="#lib.motion.motion.MotionConfig">MotionConfig</a></code></h4>
</li>
<li>
<h4><code><a title="lib.motion.motion.MovingCounters" href="#lib.motion.motion.MovingCounters">MovingCounters</a></code></h4>
<ul class="">
<li><code><a title="lib.motion.motion.MovingCounters.get_total" href="#lib.motion.motion.MovingCounters.get_total">get_total</a></code></li>
<li><code><a title="lib.motion.motion.MovingCounters.refresh" href="#lib.motion.motion.MovingCounters.refresh">refresh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.motion.motion.NotificationCadencer" href="#lib.motion.motion.NotificationCadencer">NotificationCadencer</a></code></h4>
<ul class="">
<li><code><a title="lib.motion.motion.NotificationCadencer.can_notify" href="#lib.motion.motion.NotificationCadencer.can_notify">can_notify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.motion.motion.SnapConfig" href="#lib.motion.motion.SnapConfig">SnapConfig</a></code></h4>
<ul class="">
<li><code><a title="lib.motion.motion.SnapConfig.get" href="#lib.motion.motion.SnapConfig.get">get</a></code></li>
<li><code><a title="lib.motion.motion.SnapConfig.info" href="#lib.motion.motion.SnapConfig.info">info</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>