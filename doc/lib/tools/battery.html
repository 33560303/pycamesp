<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lib.tools.battery API documentation</title>
<meta name="description" content="Manage the battery" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.tools.battery</code></h1>
</header>
<section id="section-intro">
<p>Manage the battery</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
&#34;&#34;&#34; Manage the battery &#34;&#34;&#34;
from tools import jsonconfig
from tools import useful
try: import machine
except: pass
try:import esp32
except:pass

class BatteryConfig:
        &#34;&#34;&#34; Battery configuration &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.activated = False
                self.levelGpio  = 12
                self.wakeUpGpio = 13
                self.fullBattery  = 191 # 4.2V mesured with resistor 100k + 47k
                self.emptyBattery = 161 # 3.6V mesured with resistor 100k + 47k

        def save(self, file = None):
                &#34;&#34;&#34; Save configuration &#34;&#34;&#34;
                result = jsonconfig.save(self, file)
                return result

        def update(self, params):
                &#34;&#34;&#34; Update configuration &#34;&#34;&#34;
                result = jsonconfig.update(self, params)
                return result

        def load(self, file = None):
                &#34;&#34;&#34; Load configuration &#34;&#34;&#34;
                result = jsonconfig.load(self, file)
                return result

class Battery:
        config = None
        level = [-2]
        &#34;&#34;&#34; Manage the battery information &#34;&#34;&#34;

        @staticmethod
        def init():
                &#34;&#34;&#34; Init battery class &#34;&#34;&#34;
                # If config not yet read
                if Battery.config == None:
                        Battery.config = BatteryConfig()
                        # If config failed to read
                        if Battery.config.load() == False:
                                # Write default config
                                Battery.config.save()

        @staticmethod
        def getLevel():
                &#34;&#34;&#34; Return the battery level between 0% to 100% (0%=3.6V 100%=4.2V).
                        For the ESP32CAM with Gpio12, the value can be read only before the open of camera and SD card.
                        The voltage always smaller than 1.5V otherwise the card does not boot (JTAG detection I think).
                        This GPIO 12 of the ESP32CAM not have a pull up resistor, it is the only one which allows the ADC measurement.
                        I had to patch the micropython firmware to be able to read the GPIO 12.&#34;&#34;&#34;
                Battery.init()
                # If battery level not yet read at start
                if Battery.level[0] == -2:
                        level = -1
                        try:
                                adc = machine.ADC(machine.Pin(Battery.config.levelGpio))
                                adc.atten(machine.ADC.ATTN_11DB)
                                adc.width(machine.ADC.WIDTH_9BIT)
                                count = 3
                                val = 0
                                for i in range(count):
                                        val += adc.read()
                                level = Battery.calcPercent(val/count, Battery.config)
                                if level &lt; 0.:
                                        level = 0
                                elif level &gt; 100.:
                                        level = 100
                                else:
                                        level = int(level)
                                print(&#34;Battery level %d %% (%d)&#34;%(level, int(val/count)))
                        except:
                                print(&#34;Cannot read battery status&#34;)
                        Battery.level[0] = level
                return Battery.level[0]

        @staticmethod
        def isActivated():
                &#34;&#34;&#34; Indicates if the battery management activated &#34;&#34;&#34;
                Battery.init()
                return Battery.config.activated

        @staticmethod
        def calcPercent(x, config):
                &#34;&#34;&#34; Calc the percentage of battery according to the configuration &#34;&#34;&#34;
                x1 = config.fullBattery
                y1 = 100
                x2 = config.emptyBattery
                y2 = 0

                a = (y1 - y2)/(x1 - x2)
                b = y1 - (a * x1)
                y = a*x + b
                return y

        @staticmethod
        def setPinWakeUp():
                &#34;&#34;&#34; Configure the wake up gpio on high level. For ESP32CAM, the GPIO 13 is used to detect the state of PIR detector. &#34;&#34;&#34;
                Battery.init()
                try:
                        wake1 = machine.Pin(Battery.config.wakeUpGpio, mode = machine.Pin.IN)
                        esp32.wake_on_ext0(pin = wake1, level = esp32.WAKEUP_ANY_HIGH)
                        return True
                except Exception as err:
                        print(&#34;Cannot set wake up&#34;)
                return False

        @staticmethod
        def isPinWakeUp():
                &#34;&#34;&#34; Indicates that the machine wake up on pin modification (Only available at start) &#34;&#34;&#34;
                Battery.init()
                try:
                        pin = machine.Pin(Battery.config.wakeUpGpio, machine.Pin.IN, machine.Pin.PULL_UP)
                        return True if pin.value() == 1 else False
                except:
                        return False

        @staticmethod
        def protect():
                &#34;&#34;&#34; Checks if the battery level is sufficient, and checks the number of brownout reset. 
                        If the battery is too low, we enter indefinite deep sleep to protect the battery &#34;&#34;&#34;
                # Can only be done once at boot before start the camera and sd card
                batteryLevel = Battery.getLevel()

                # If the battery is too low
                if batteryLevel &gt; 5:
                        batteryProtect = False
                # If the battery level can&#39;t be read
                elif batteryLevel &lt; 0:
                        # If the reset is due to insufficient battery
                        if machine.reset_cause() == machine.BROWNOUT_RESET:
                                batteryProtect = True
                        else:
                                batteryProtect = False
                else:
                        batteryProtect = True

                brownoutCounter = 0
                # If the reset can probably due to insufficient battery
                if machine.reset_cause() == machine.BROWNOUT_RESET:
                        try:
                                file = open(&#34;brownout.txt&#34;,&#34;r&#34;)
                                val = file.read()
                                brownoutCounter = int(val) + 1
                        except Exception as err:
                                print(useful.exception(err))

                try:
                        file = open(&#34;brownout.txt&#34;,&#34;w&#34;)
                        file.write(&#34;%d&#34;%brownoutCounter)
                        file.flush()
                        file.close()
                except Exception as err:
                        print(useful.exception(err))

                # If the battery level seems sufficient
                if batteryProtect == False:
                        # if the number of consecutive brownout resets is too high
                        if brownoutCounter &gt; 10:
                                # Battery too low, save the battery status
                                file = open(&#34;battery.txt&#34;,&#34;w&#34;)
                                file.write(&#34;Too many brownout reset with battery level at %d %%&#34;%batteryLevel)
                                file.flush()
                                file.close()
                                batteryProtect = True

                # Case the battery has not enough current and must be protected
                if batteryProtect:
                        print(&#34;#####################################&#34;)
                        print(&#34;# DEEP SLEEP TO PROTECT THE BATTERY #&#34;)
                        print(&#34;#####################################&#34;)
                        machine.deepsleep()
                else:
                        # Set the wake up on PIR detection
                        Battery.setPinWakeUp()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.tools.battery.Battery"><code class="flex name class">
<span>class <span class="ident">Battery</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Battery:
        config = None
        level = [-2]
        &#34;&#34;&#34; Manage the battery information &#34;&#34;&#34;

        @staticmethod
        def init():
                &#34;&#34;&#34; Init battery class &#34;&#34;&#34;
                # If config not yet read
                if Battery.config == None:
                        Battery.config = BatteryConfig()
                        # If config failed to read
                        if Battery.config.load() == False:
                                # Write default config
                                Battery.config.save()

        @staticmethod
        def getLevel():
                &#34;&#34;&#34; Return the battery level between 0% to 100% (0%=3.6V 100%=4.2V).
                        For the ESP32CAM with Gpio12, the value can be read only before the open of camera and SD card.
                        The voltage always smaller than 1.5V otherwise the card does not boot (JTAG detection I think).
                        This GPIO 12 of the ESP32CAM not have a pull up resistor, it is the only one which allows the ADC measurement.
                        I had to patch the micropython firmware to be able to read the GPIO 12.&#34;&#34;&#34;
                Battery.init()
                # If battery level not yet read at start
                if Battery.level[0] == -2:
                        level = -1
                        try:
                                adc = machine.ADC(machine.Pin(Battery.config.levelGpio))
                                adc.atten(machine.ADC.ATTN_11DB)
                                adc.width(machine.ADC.WIDTH_9BIT)
                                count = 3
                                val = 0
                                for i in range(count):
                                        val += adc.read()
                                level = Battery.calcPercent(val/count, Battery.config)
                                if level &lt; 0.:
                                        level = 0
                                elif level &gt; 100.:
                                        level = 100
                                else:
                                        level = int(level)
                                print(&#34;Battery level %d %% (%d)&#34;%(level, int(val/count)))
                        except:
                                print(&#34;Cannot read battery status&#34;)
                        Battery.level[0] = level
                return Battery.level[0]

        @staticmethod
        def isActivated():
                &#34;&#34;&#34; Indicates if the battery management activated &#34;&#34;&#34;
                Battery.init()
                return Battery.config.activated

        @staticmethod
        def calcPercent(x, config):
                &#34;&#34;&#34; Calc the percentage of battery according to the configuration &#34;&#34;&#34;
                x1 = config.fullBattery
                y1 = 100
                x2 = config.emptyBattery
                y2 = 0

                a = (y1 - y2)/(x1 - x2)
                b = y1 - (a * x1)
                y = a*x + b
                return y

        @staticmethod
        def setPinWakeUp():
                &#34;&#34;&#34; Configure the wake up gpio on high level. For ESP32CAM, the GPIO 13 is used to detect the state of PIR detector. &#34;&#34;&#34;
                Battery.init()
                try:
                        wake1 = machine.Pin(Battery.config.wakeUpGpio, mode = machine.Pin.IN)
                        esp32.wake_on_ext0(pin = wake1, level = esp32.WAKEUP_ANY_HIGH)
                        return True
                except Exception as err:
                        print(&#34;Cannot set wake up&#34;)
                return False

        @staticmethod
        def isPinWakeUp():
                &#34;&#34;&#34; Indicates that the machine wake up on pin modification (Only available at start) &#34;&#34;&#34;
                Battery.init()
                try:
                        pin = machine.Pin(Battery.config.wakeUpGpio, machine.Pin.IN, machine.Pin.PULL_UP)
                        return True if pin.value() == 1 else False
                except:
                        return False

        @staticmethod
        def protect():
                &#34;&#34;&#34; Checks if the battery level is sufficient, and checks the number of brownout reset. 
                        If the battery is too low, we enter indefinite deep sleep to protect the battery &#34;&#34;&#34;
                # Can only be done once at boot before start the camera and sd card
                batteryLevel = Battery.getLevel()

                # If the battery is too low
                if batteryLevel &gt; 5:
                        batteryProtect = False
                # If the battery level can&#39;t be read
                elif batteryLevel &lt; 0:
                        # If the reset is due to insufficient battery
                        if machine.reset_cause() == machine.BROWNOUT_RESET:
                                batteryProtect = True
                        else:
                                batteryProtect = False
                else:
                        batteryProtect = True

                brownoutCounter = 0
                # If the reset can probably due to insufficient battery
                if machine.reset_cause() == machine.BROWNOUT_RESET:
                        try:
                                file = open(&#34;brownout.txt&#34;,&#34;r&#34;)
                                val = file.read()
                                brownoutCounter = int(val) + 1
                        except Exception as err:
                                print(useful.exception(err))

                try:
                        file = open(&#34;brownout.txt&#34;,&#34;w&#34;)
                        file.write(&#34;%d&#34;%brownoutCounter)
                        file.flush()
                        file.close()
                except Exception as err:
                        print(useful.exception(err))

                # If the battery level seems sufficient
                if batteryProtect == False:
                        # if the number of consecutive brownout resets is too high
                        if brownoutCounter &gt; 10:
                                # Battery too low, save the battery status
                                file = open(&#34;battery.txt&#34;,&#34;w&#34;)
                                file.write(&#34;Too many brownout reset with battery level at %d %%&#34;%batteryLevel)
                                file.flush()
                                file.close()
                                batteryProtect = True

                # Case the battery has not enough current and must be protected
                if batteryProtect:
                        print(&#34;#####################################&#34;)
                        print(&#34;# DEEP SLEEP TO PROTECT THE BATTERY #&#34;)
                        print(&#34;#####################################&#34;)
                        machine.deepsleep()
                else:
                        # Set the wake up on PIR detection
                        Battery.setPinWakeUp()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.tools.battery.Battery.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.tools.battery.Battery.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"><p>Manage the battery information</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.tools.battery.Battery.calcPercent"><code class="name flex">
<span>def <span class="ident">calcPercent</span></span>(<span>x, config)</span>
</code></dt>
<dd>
<div class="desc"><p>Calc the percentage of battery according to the configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calcPercent(x, config):
        &#34;&#34;&#34; Calc the percentage of battery according to the configuration &#34;&#34;&#34;
        x1 = config.fullBattery
        y1 = 100
        x2 = config.emptyBattery
        y2 = 0

        a = (y1 - y2)/(x1 - x2)
        b = y1 - (a * x1)
        y = a*x + b
        return y</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.getLevel"><code class="name flex">
<span>def <span class="ident">getLevel</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the battery level between 0% to 100% (0%=3.6V 100%=4.2V).
For the ESP32CAM with Gpio12, the value can be read only before the open of camera and SD card.
The voltage always smaller than 1.5V otherwise the card does not boot (JTAG detection I think).
This GPIO 12 of the ESP32CAM not have a pull up resistor, it is the only one which allows the ADC measurement.
I had to patch the micropython firmware to be able to read the GPIO 12.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def getLevel():
        &#34;&#34;&#34; Return the battery level between 0% to 100% (0%=3.6V 100%=4.2V).
                For the ESP32CAM with Gpio12, the value can be read only before the open of camera and SD card.
                The voltage always smaller than 1.5V otherwise the card does not boot (JTAG detection I think).
                This GPIO 12 of the ESP32CAM not have a pull up resistor, it is the only one which allows the ADC measurement.
                I had to patch the micropython firmware to be able to read the GPIO 12.&#34;&#34;&#34;
        Battery.init()
        # If battery level not yet read at start
        if Battery.level[0] == -2:
                level = -1
                try:
                        adc = machine.ADC(machine.Pin(Battery.config.levelGpio))
                        adc.atten(machine.ADC.ATTN_11DB)
                        adc.width(machine.ADC.WIDTH_9BIT)
                        count = 3
                        val = 0
                        for i in range(count):
                                val += adc.read()
                        level = Battery.calcPercent(val/count, Battery.config)
                        if level &lt; 0.:
                                level = 0
                        elif level &gt; 100.:
                                level = 100
                        else:
                                level = int(level)
                        print(&#34;Battery level %d %% (%d)&#34;%(level, int(val/count)))
                except:
                        print(&#34;Cannot read battery status&#34;)
                Battery.level[0] = level
        return Battery.level[0]</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Init battery class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def init():
        &#34;&#34;&#34; Init battery class &#34;&#34;&#34;
        # If config not yet read
        if Battery.config == None:
                Battery.config = BatteryConfig()
                # If config failed to read
                if Battery.config.load() == False:
                        # Write default config
                        Battery.config.save()</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.isActivated"><code class="name flex">
<span>def <span class="ident">isActivated</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the battery management activated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isActivated():
        &#34;&#34;&#34; Indicates if the battery management activated &#34;&#34;&#34;
        Battery.init()
        return Battery.config.activated</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.isPinWakeUp"><code class="name flex">
<span>def <span class="ident">isPinWakeUp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates that the machine wake up on pin modification (Only available at start)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def isPinWakeUp():
        &#34;&#34;&#34; Indicates that the machine wake up on pin modification (Only available at start) &#34;&#34;&#34;
        Battery.init()
        try:
                pin = machine.Pin(Battery.config.wakeUpGpio, machine.Pin.IN, machine.Pin.PULL_UP)
                return True if pin.value() == 1 else False
        except:
                return False</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.protect"><code class="name flex">
<span>def <span class="ident">protect</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the battery level is sufficient, and checks the number of brownout reset.
If the battery is too low, we enter indefinite deep sleep to protect the battery</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def protect():
        &#34;&#34;&#34; Checks if the battery level is sufficient, and checks the number of brownout reset. 
                If the battery is too low, we enter indefinite deep sleep to protect the battery &#34;&#34;&#34;
        # Can only be done once at boot before start the camera and sd card
        batteryLevel = Battery.getLevel()

        # If the battery is too low
        if batteryLevel &gt; 5:
                batteryProtect = False
        # If the battery level can&#39;t be read
        elif batteryLevel &lt; 0:
                # If the reset is due to insufficient battery
                if machine.reset_cause() == machine.BROWNOUT_RESET:
                        batteryProtect = True
                else:
                        batteryProtect = False
        else:
                batteryProtect = True

        brownoutCounter = 0
        # If the reset can probably due to insufficient battery
        if machine.reset_cause() == machine.BROWNOUT_RESET:
                try:
                        file = open(&#34;brownout.txt&#34;,&#34;r&#34;)
                        val = file.read()
                        brownoutCounter = int(val) + 1
                except Exception as err:
                        print(useful.exception(err))

        try:
                file = open(&#34;brownout.txt&#34;,&#34;w&#34;)
                file.write(&#34;%d&#34;%brownoutCounter)
                file.flush()
                file.close()
        except Exception as err:
                print(useful.exception(err))

        # If the battery level seems sufficient
        if batteryProtect == False:
                # if the number of consecutive brownout resets is too high
                if brownoutCounter &gt; 10:
                        # Battery too low, save the battery status
                        file = open(&#34;battery.txt&#34;,&#34;w&#34;)
                        file.write(&#34;Too many brownout reset with battery level at %d %%&#34;%batteryLevel)
                        file.flush()
                        file.close()
                        batteryProtect = True

        # Case the battery has not enough current and must be protected
        if batteryProtect:
                print(&#34;#####################################&#34;)
                print(&#34;# DEEP SLEEP TO PROTECT THE BATTERY #&#34;)
                print(&#34;#####################################&#34;)
                machine.deepsleep()
        else:
                # Set the wake up on PIR detection
                Battery.setPinWakeUp()</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.setPinWakeUp"><code class="name flex">
<span>def <span class="ident">setPinWakeUp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the wake up gpio on high level. For ESP32CAM, the GPIO 13 is used to detect the state of PIR detector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def setPinWakeUp():
        &#34;&#34;&#34; Configure the wake up gpio on high level. For ESP32CAM, the GPIO 13 is used to detect the state of PIR detector. &#34;&#34;&#34;
        Battery.init()
        try:
                wake1 = machine.Pin(Battery.config.wakeUpGpio, mode = machine.Pin.IN)
                esp32.wake_on_ext0(pin = wake1, level = esp32.WAKEUP_ANY_HIGH)
                return True
        except Exception as err:
                print(&#34;Cannot set wake up&#34;)
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.tools.battery.BatteryConfig"><code class="flex name class">
<span>class <span class="ident">BatteryConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Battery configuration </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BatteryConfig:
        &#34;&#34;&#34; Battery configuration &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                self.activated = False
                self.levelGpio  = 12
                self.wakeUpGpio = 13
                self.fullBattery  = 191 # 4.2V mesured with resistor 100k + 47k
                self.emptyBattery = 161 # 3.6V mesured with resistor 100k + 47k

        def save(self, file = None):
                &#34;&#34;&#34; Save configuration &#34;&#34;&#34;
                result = jsonconfig.save(self, file)
                return result

        def update(self, params):
                &#34;&#34;&#34; Update configuration &#34;&#34;&#34;
                result = jsonconfig.update(self, params)
                return result

        def load(self, file = None):
                &#34;&#34;&#34; Load configuration &#34;&#34;&#34;
                result = jsonconfig.load(self, file)
                return result</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="lib.tools.battery.BatteryConfig.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Load configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, file = None):
        &#34;&#34;&#34; Load configuration &#34;&#34;&#34;
        result = jsonconfig.load(self, file)
        return result</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.BatteryConfig.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, file = None):
        &#34;&#34;&#34; Save configuration &#34;&#34;&#34;
        result = jsonconfig.save(self, file)
        return result</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.BatteryConfig.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p>Update configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, params):
        &#34;&#34;&#34; Update configuration &#34;&#34;&#34;
        result = jsonconfig.update(self, params)
        return result</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.tools" href="index.html">lib.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.tools.battery.Battery" href="#lib.tools.battery.Battery">Battery</a></code></h4>
<ul class="two-column">
<li><code><a title="lib.tools.battery.Battery.calcPercent" href="#lib.tools.battery.Battery.calcPercent">calcPercent</a></code></li>
<li><code><a title="lib.tools.battery.Battery.config" href="#lib.tools.battery.Battery.config">config</a></code></li>
<li><code><a title="lib.tools.battery.Battery.getLevel" href="#lib.tools.battery.Battery.getLevel">getLevel</a></code></li>
<li><code><a title="lib.tools.battery.Battery.init" href="#lib.tools.battery.Battery.init">init</a></code></li>
<li><code><a title="lib.tools.battery.Battery.isActivated" href="#lib.tools.battery.Battery.isActivated">isActivated</a></code></li>
<li><code><a title="lib.tools.battery.Battery.isPinWakeUp" href="#lib.tools.battery.Battery.isPinWakeUp">isPinWakeUp</a></code></li>
<li><code><a title="lib.tools.battery.Battery.level" href="#lib.tools.battery.Battery.level">level</a></code></li>
<li><code><a title="lib.tools.battery.Battery.protect" href="#lib.tools.battery.Battery.protect">protect</a></code></li>
<li><code><a title="lib.tools.battery.Battery.setPinWakeUp" href="#lib.tools.battery.Battery.setPinWakeUp">setPinWakeUp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.tools.battery.BatteryConfig" href="#lib.tools.battery.BatteryConfig">BatteryConfig</a></code></h4>
<ul class="">
<li><code><a title="lib.tools.battery.BatteryConfig.load" href="#lib.tools.battery.BatteryConfig.load">load</a></code></li>
<li><code><a title="lib.tools.battery.BatteryConfig.save" href="#lib.tools.battery.BatteryConfig.save">save</a></code></li>
<li><code><a title="lib.tools.battery.BatteryConfig.update" href="#lib.tools.battery.BatteryConfig.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>