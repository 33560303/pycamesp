<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>lib.tools.battery API documentation</title>
<meta name="description" content="Manage the battery" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.tools.battery</code></h1>
</header>
<section id="section-intro">
<p>Manage the battery</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
&#34;&#34;&#34; Manage the battery &#34;&#34;&#34;
import machine
from tools import jsonconfig, useful

class BatteryConfig(jsonconfig.JsonConfig):
        &#34;&#34;&#34; Battery configuration &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                jsonconfig.JsonConfig.__init__(self)

                # Battery monitoring
                self.activated = False # Monitoring status
                self.level_gpio    = 12  # Monitoring GPIO
                self.full_battery  = 188 # 4.2V mesured with resistor 100k + 47k
                self.empty_battery = 158 # 3.6V mesured with resistor 100k + 47k

                # Force deep sleep if to many successive brown out reset detected
                self.brownout_detection = True
                self.brownout_count = 0

class Battery:
        &#34;&#34;&#34; Manage the battery information &#34;&#34;&#34;
        config = None
        level = [-2]
        refresh = [0]

        @staticmethod
        def init():
                &#34;&#34;&#34; Init battery class &#34;&#34;&#34;
                # If config not yet read
                if Battery.config is None:
                        Battery.config = BatteryConfig()
                        # If config failed to read
                        if Battery.config.load() is False:
                                # Write default config
                                Battery.config.save()

        @staticmethod
        def get_level():
                &#34;&#34;&#34; Return the battery level between 0% to 100% (0%=3.6V 100%=4.2V).
                        For the ESP32CAM with Gpio12, the value can be read only before the open of camera and SD card.
                        The voltage always smaller than 1.5V otherwise the card does not boot (JTAG detection I think).
                        This GPIO 12 of the ESP32CAM not have a pull up resistor, it is the only one which allows the ADC measurement.
                        I had to patch the micropython firmware to be able to read the GPIO 12.&#34;&#34;&#34;
                Battery.init()
                # If battery level not yet read at start
                if Battery.level[0] == -2:
                        level = -1
                        try:
                                adc = machine.ADC(machine.Pin(Battery.config.level_gpio))
                                adc.atten(machine.ADC.ATTN_11DB)
                                adc.width(machine.ADC.WIDTH_9BIT)
                                count = 3
                                val = 0
                                for i in range(count):
                                        val += adc.read()
                                # If battery level pin not connected
                                if val &lt; (Battery.config.empty_battery * count) // 2:
                                        level = -1
                                else:
                                        # Compute battery level
                                        level = Battery.calc_percent(val/count, Battery.config)
                                        if level &lt; 0.:
                                                level = 0
                                        elif level &gt; 100.:
                                                level = 100
                                        else:
                                                level = int(level)
                                useful.syslog(&#34;Battery level %d %% (%d)&#34;%(level, int(val/count)))
                        except Exception as err:
                                useful.syslog(err,&#34;Cannot read battery status&#34;)
                        Battery.level[0] = level
                return Battery.level[0]

        @staticmethod
        def is_activated():
                &#34;&#34;&#34; Indicates if the battery management activated &#34;&#34;&#34;
                Battery.init()
                return Battery.config.activated

        @staticmethod
        def calc_percent(x, config):
                &#34;&#34;&#34; Calc the percentage of battery according to the configuration &#34;&#34;&#34;
                x1 = config.full_battery
                y1 = 100
                x2 = config.empty_battery
                y2 = 0

                a = (y1 - y2)/(x1 - x2)
                b = y1 - (a * x1)
                y = a*x + b
                return y

        @staticmethod
        def protect():
                &#34;&#34;&#34; Protect the battery &#34;&#34;&#34;
                Battery.init()
                Battery.keep_reset_cause()
                if Battery.manage_level() or Battery.is_too_many_brownout():
                        useful.syslog(&#34;Sleep infinite&#34;)
                        machine.deepsleep()

        @staticmethod
        def manage_level():
                &#34;&#34;&#34; Checks if the battery level is sufficient.
                        If the battery is too low, we enter indefinite deep sleep to protect the battery &#34;&#34;&#34;
                deepsleep = False
                if Battery.config.activated:
                        # Can only be done once at boot before start the camera and sd card
                        battery_level = Battery.get_level()

                        # If the battery is too low
                        if battery_level &gt; 5 or battery_level &lt; 0:
                                battery_protect = False
                        else:
                                battery_protect = True

                        # Case the battery has not enough current and must be protected
                        if battery_protect:
                                deepsleep = True
                                useful.syslog(&#34;Battery too low %d %%&#34;%battery_level)
                return deepsleep

        @staticmethod
        def keep_reset_cause():
                &#34;&#34;&#34; Keep reset cause &#34;&#34;&#34;
                causes = {
                        machine.PWRON_RESET     : &#34;Power on&#34;,
                        machine.HARD_RESET      : &#34;Hard&#34;,
                        machine.WDT_RESET       : &#34;Watch dog&#34;,
                        machine.DEEPSLEEP_RESET : &#34;Deep sleep&#34;,
                        machine.SOFT_RESET      : &#34;Soft&#34;,
                        machine.BROWNOUT_RESET  : &#34;Brownout&#34;,
                }.setdefault(machine.reset_cause(), &#34;%d&#34;%machine.reset_cause())
                useful.syslog(&#34; &#34;)
                useful.syslog(&#34;%s Start %s&#34;%(&#39;-&#39;*10,&#39;-&#39;*10), display=False)
                useful.syslog(&#34;%s reset&#34;%causes)

        @staticmethod
        def is_too_many_brownout():
                &#34;&#34;&#34; Checks the number of brownout reset &#34;&#34;&#34;
                deepsleep = False

                if Battery.config.is_changed():
                        Battery.config.load()

                if Battery.config.brownout_detection:
                        # If the reset can probably due to insufficient battery
                        if machine.reset_cause() == machine.BROWNOUT_RESET:
                                Battery.config.brownout_count += 1
                        else:
                                Battery.config.brownout_count = 0

                        Battery.config.save()

                        # if the number of consecutive brownout resets is too high
                        if Battery.config.brownout_count &gt; 32:
                                # Battery too low, save the battery status
                                useful.syslog(&#34;Too many successive brownout reset&#34;)
                                deepsleep = True
                return deepsleep

        @staticmethod
        def manage(resetBrownout=False):
                &#34;&#34;&#34; Manage the battery level duration &#34;&#34;&#34;
                if Battery.refresh[0] % 10 == 0:
                        if Battery.config.is_changed():
                                Battery.config.load()
                Battery.refresh[0] += 1

                if resetBrownout:
                        if Battery.config.brownout_detection:
                                if Battery.config.brownout_count &gt; 0:
                                        Battery.config.brownout_count = 0
                                        Battery.config.save()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lib.tools.battery.Battery"><code class="flex name class">
<span>class <span class="ident">Battery</span></span>
</code></dt>
<dd>
<div class="desc"><p>Manage the battery information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Battery:
        &#34;&#34;&#34; Manage the battery information &#34;&#34;&#34;
        config = None
        level = [-2]
        refresh = [0]

        @staticmethod
        def init():
                &#34;&#34;&#34; Init battery class &#34;&#34;&#34;
                # If config not yet read
                if Battery.config is None:
                        Battery.config = BatteryConfig()
                        # If config failed to read
                        if Battery.config.load() is False:
                                # Write default config
                                Battery.config.save()

        @staticmethod
        def get_level():
                &#34;&#34;&#34; Return the battery level between 0% to 100% (0%=3.6V 100%=4.2V).
                        For the ESP32CAM with Gpio12, the value can be read only before the open of camera and SD card.
                        The voltage always smaller than 1.5V otherwise the card does not boot (JTAG detection I think).
                        This GPIO 12 of the ESP32CAM not have a pull up resistor, it is the only one which allows the ADC measurement.
                        I had to patch the micropython firmware to be able to read the GPIO 12.&#34;&#34;&#34;
                Battery.init()
                # If battery level not yet read at start
                if Battery.level[0] == -2:
                        level = -1
                        try:
                                adc = machine.ADC(machine.Pin(Battery.config.level_gpio))
                                adc.atten(machine.ADC.ATTN_11DB)
                                adc.width(machine.ADC.WIDTH_9BIT)
                                count = 3
                                val = 0
                                for i in range(count):
                                        val += adc.read()
                                # If battery level pin not connected
                                if val &lt; (Battery.config.empty_battery * count) // 2:
                                        level = -1
                                else:
                                        # Compute battery level
                                        level = Battery.calc_percent(val/count, Battery.config)
                                        if level &lt; 0.:
                                                level = 0
                                        elif level &gt; 100.:
                                                level = 100
                                        else:
                                                level = int(level)
                                useful.syslog(&#34;Battery level %d %% (%d)&#34;%(level, int(val/count)))
                        except Exception as err:
                                useful.syslog(err,&#34;Cannot read battery status&#34;)
                        Battery.level[0] = level
                return Battery.level[0]

        @staticmethod
        def is_activated():
                &#34;&#34;&#34; Indicates if the battery management activated &#34;&#34;&#34;
                Battery.init()
                return Battery.config.activated

        @staticmethod
        def calc_percent(x, config):
                &#34;&#34;&#34; Calc the percentage of battery according to the configuration &#34;&#34;&#34;
                x1 = config.full_battery
                y1 = 100
                x2 = config.empty_battery
                y2 = 0

                a = (y1 - y2)/(x1 - x2)
                b = y1 - (a * x1)
                y = a*x + b
                return y

        @staticmethod
        def protect():
                &#34;&#34;&#34; Protect the battery &#34;&#34;&#34;
                Battery.init()
                Battery.keep_reset_cause()
                if Battery.manage_level() or Battery.is_too_many_brownout():
                        useful.syslog(&#34;Sleep infinite&#34;)
                        machine.deepsleep()

        @staticmethod
        def manage_level():
                &#34;&#34;&#34; Checks if the battery level is sufficient.
                        If the battery is too low, we enter indefinite deep sleep to protect the battery &#34;&#34;&#34;
                deepsleep = False
                if Battery.config.activated:
                        # Can only be done once at boot before start the camera and sd card
                        battery_level = Battery.get_level()

                        # If the battery is too low
                        if battery_level &gt; 5 or battery_level &lt; 0:
                                battery_protect = False
                        else:
                                battery_protect = True

                        # Case the battery has not enough current and must be protected
                        if battery_protect:
                                deepsleep = True
                                useful.syslog(&#34;Battery too low %d %%&#34;%battery_level)
                return deepsleep

        @staticmethod
        def keep_reset_cause():
                &#34;&#34;&#34; Keep reset cause &#34;&#34;&#34;
                causes = {
                        machine.PWRON_RESET     : &#34;Power on&#34;,
                        machine.HARD_RESET      : &#34;Hard&#34;,
                        machine.WDT_RESET       : &#34;Watch dog&#34;,
                        machine.DEEPSLEEP_RESET : &#34;Deep sleep&#34;,
                        machine.SOFT_RESET      : &#34;Soft&#34;,
                        machine.BROWNOUT_RESET  : &#34;Brownout&#34;,
                }.setdefault(machine.reset_cause(), &#34;%d&#34;%machine.reset_cause())
                useful.syslog(&#34; &#34;)
                useful.syslog(&#34;%s Start %s&#34;%(&#39;-&#39;*10,&#39;-&#39;*10), display=False)
                useful.syslog(&#34;%s reset&#34;%causes)

        @staticmethod
        def is_too_many_brownout():
                &#34;&#34;&#34; Checks the number of brownout reset &#34;&#34;&#34;
                deepsleep = False

                if Battery.config.is_changed():
                        Battery.config.load()

                if Battery.config.brownout_detection:
                        # If the reset can probably due to insufficient battery
                        if machine.reset_cause() == machine.BROWNOUT_RESET:
                                Battery.config.brownout_count += 1
                        else:
                                Battery.config.brownout_count = 0

                        Battery.config.save()

                        # if the number of consecutive brownout resets is too high
                        if Battery.config.brownout_count &gt; 32:
                                # Battery too low, save the battery status
                                useful.syslog(&#34;Too many successive brownout reset&#34;)
                                deepsleep = True
                return deepsleep

        @staticmethod
        def manage(resetBrownout=False):
                &#34;&#34;&#34; Manage the battery level duration &#34;&#34;&#34;
                if Battery.refresh[0] % 10 == 0:
                        if Battery.config.is_changed():
                                Battery.config.load()
                Battery.refresh[0] += 1

                if resetBrownout:
                        if Battery.config.brownout_detection:
                                if Battery.config.brownout_count &gt; 0:
                                        Battery.config.brownout_count = 0
                                        Battery.config.save()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lib.tools.battery.Battery.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.tools.battery.Battery.level"><code class="name">var <span class="ident">level</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="lib.tools.battery.Battery.refresh"><code class="name">var <span class="ident">refresh</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="lib.tools.battery.Battery.calc_percent"><code class="name flex">
<span>def <span class="ident">calc_percent</span></span>(<span>x, config)</span>
</code></dt>
<dd>
<div class="desc"><p>Calc the percentage of battery according to the configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def calc_percent(x, config):
        &#34;&#34;&#34; Calc the percentage of battery according to the configuration &#34;&#34;&#34;
        x1 = config.full_battery
        y1 = 100
        x2 = config.empty_battery
        y2 = 0

        a = (y1 - y2)/(x1 - x2)
        b = y1 - (a * x1)
        y = a*x + b
        return y</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.get_level"><code class="name flex">
<span>def <span class="ident">get_level</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the battery level between 0% to 100% (0%=3.6V 100%=4.2V).
For the ESP32CAM with Gpio12, the value can be read only before the open of camera and SD card.
The voltage always smaller than 1.5V otherwise the card does not boot (JTAG detection I think).
This GPIO 12 of the ESP32CAM not have a pull up resistor, it is the only one which allows the ADC measurement.
I had to patch the micropython firmware to be able to read the GPIO 12.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_level():
        &#34;&#34;&#34; Return the battery level between 0% to 100% (0%=3.6V 100%=4.2V).
                For the ESP32CAM with Gpio12, the value can be read only before the open of camera and SD card.
                The voltage always smaller than 1.5V otherwise the card does not boot (JTAG detection I think).
                This GPIO 12 of the ESP32CAM not have a pull up resistor, it is the only one which allows the ADC measurement.
                I had to patch the micropython firmware to be able to read the GPIO 12.&#34;&#34;&#34;
        Battery.init()
        # If battery level not yet read at start
        if Battery.level[0] == -2:
                level = -1
                try:
                        adc = machine.ADC(machine.Pin(Battery.config.level_gpio))
                        adc.atten(machine.ADC.ATTN_11DB)
                        adc.width(machine.ADC.WIDTH_9BIT)
                        count = 3
                        val = 0
                        for i in range(count):
                                val += adc.read()
                        # If battery level pin not connected
                        if val &lt; (Battery.config.empty_battery * count) // 2:
                                level = -1
                        else:
                                # Compute battery level
                                level = Battery.calc_percent(val/count, Battery.config)
                                if level &lt; 0.:
                                        level = 0
                                elif level &gt; 100.:
                                        level = 100
                                else:
                                        level = int(level)
                        useful.syslog(&#34;Battery level %d %% (%d)&#34;%(level, int(val/count)))
                except Exception as err:
                        useful.syslog(err,&#34;Cannot read battery status&#34;)
                Battery.level[0] = level
        return Battery.level[0]</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Init battery class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def init():
        &#34;&#34;&#34; Init battery class &#34;&#34;&#34;
        # If config not yet read
        if Battery.config is None:
                Battery.config = BatteryConfig()
                # If config failed to read
                if Battery.config.load() is False:
                        # Write default config
                        Battery.config.save()</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.is_activated"><code class="name flex">
<span>def <span class="ident">is_activated</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the battery management activated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_activated():
        &#34;&#34;&#34; Indicates if the battery management activated &#34;&#34;&#34;
        Battery.init()
        return Battery.config.activated</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.is_too_many_brownout"><code class="name flex">
<span>def <span class="ident">is_too_many_brownout</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks the number of brownout reset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_too_many_brownout():
        &#34;&#34;&#34; Checks the number of brownout reset &#34;&#34;&#34;
        deepsleep = False

        if Battery.config.is_changed():
                Battery.config.load()

        if Battery.config.brownout_detection:
                # If the reset can probably due to insufficient battery
                if machine.reset_cause() == machine.BROWNOUT_RESET:
                        Battery.config.brownout_count += 1
                else:
                        Battery.config.brownout_count = 0

                Battery.config.save()

                # if the number of consecutive brownout resets is too high
                if Battery.config.brownout_count &gt; 32:
                        # Battery too low, save the battery status
                        useful.syslog(&#34;Too many successive brownout reset&#34;)
                        deepsleep = True
        return deepsleep</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.keep_reset_cause"><code class="name flex">
<span>def <span class="ident">keep_reset_cause</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Keep reset cause</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def keep_reset_cause():
        &#34;&#34;&#34; Keep reset cause &#34;&#34;&#34;
        causes = {
                machine.PWRON_RESET     : &#34;Power on&#34;,
                machine.HARD_RESET      : &#34;Hard&#34;,
                machine.WDT_RESET       : &#34;Watch dog&#34;,
                machine.DEEPSLEEP_RESET : &#34;Deep sleep&#34;,
                machine.SOFT_RESET      : &#34;Soft&#34;,
                machine.BROWNOUT_RESET  : &#34;Brownout&#34;,
        }.setdefault(machine.reset_cause(), &#34;%d&#34;%machine.reset_cause())
        useful.syslog(&#34; &#34;)
        useful.syslog(&#34;%s Start %s&#34;%(&#39;-&#39;*10,&#39;-&#39;*10), display=False)
        useful.syslog(&#34;%s reset&#34;%causes)</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.manage"><code class="name flex">
<span>def <span class="ident">manage</span></span>(<span>resetBrownout=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Manage the battery level duration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def manage(resetBrownout=False):
        &#34;&#34;&#34; Manage the battery level duration &#34;&#34;&#34;
        if Battery.refresh[0] % 10 == 0:
                if Battery.config.is_changed():
                        Battery.config.load()
        Battery.refresh[0] += 1

        if resetBrownout:
                if Battery.config.brownout_detection:
                        if Battery.config.brownout_count &gt; 0:
                                Battery.config.brownout_count = 0
                                Battery.config.save()</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.manage_level"><code class="name flex">
<span>def <span class="ident">manage_level</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the battery level is sufficient.
If the battery is too low, we enter indefinite deep sleep to protect the battery</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def manage_level():
        &#34;&#34;&#34; Checks if the battery level is sufficient.
                If the battery is too low, we enter indefinite deep sleep to protect the battery &#34;&#34;&#34;
        deepsleep = False
        if Battery.config.activated:
                # Can only be done once at boot before start the camera and sd card
                battery_level = Battery.get_level()

                # If the battery is too low
                if battery_level &gt; 5 or battery_level &lt; 0:
                        battery_protect = False
                else:
                        battery_protect = True

                # Case the battery has not enough current and must be protected
                if battery_protect:
                        deepsleep = True
                        useful.syslog(&#34;Battery too low %d %%&#34;%battery_level)
        return deepsleep</code></pre>
</details>
</dd>
<dt id="lib.tools.battery.Battery.protect"><code class="name flex">
<span>def <span class="ident">protect</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Protect the battery</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def protect():
        &#34;&#34;&#34; Protect the battery &#34;&#34;&#34;
        Battery.init()
        Battery.keep_reset_cause()
        if Battery.manage_level() or Battery.is_too_many_brownout():
                useful.syslog(&#34;Sleep infinite&#34;)
                machine.deepsleep()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lib.tools.battery.BatteryConfig"><code class="flex name class">
<span>class <span class="ident">BatteryConfig</span></span>
</code></dt>
<dd>
<div class="desc"><p>Battery configuration </p>
<p>Constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BatteryConfig(jsonconfig.JsonConfig):
        &#34;&#34;&#34; Battery configuration &#34;&#34;&#34;
        def __init__(self):
                &#34;&#34;&#34; Constructor &#34;&#34;&#34;
                jsonconfig.JsonConfig.__init__(self)

                # Battery monitoring
                self.activated = False # Monitoring status
                self.level_gpio    = 12  # Monitoring GPIO
                self.full_battery  = 188 # 4.2V mesured with resistor 100k + 47k
                self.empty_battery = 158 # 3.6V mesured with resistor 100k + 47k

                # Force deep sleep if to many successive brown out reset detected
                self.brownout_detection = True
                self.brownout_count = 0</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tools.jsonconfig.JsonConfig</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.tools" href="index.html">lib.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lib.tools.battery.Battery" href="#lib.tools.battery.Battery">Battery</a></code></h4>
<ul class="">
<li><code><a title="lib.tools.battery.Battery.calc_percent" href="#lib.tools.battery.Battery.calc_percent">calc_percent</a></code></li>
<li><code><a title="lib.tools.battery.Battery.config" href="#lib.tools.battery.Battery.config">config</a></code></li>
<li><code><a title="lib.tools.battery.Battery.get_level" href="#lib.tools.battery.Battery.get_level">get_level</a></code></li>
<li><code><a title="lib.tools.battery.Battery.init" href="#lib.tools.battery.Battery.init">init</a></code></li>
<li><code><a title="lib.tools.battery.Battery.is_activated" href="#lib.tools.battery.Battery.is_activated">is_activated</a></code></li>
<li><code><a title="lib.tools.battery.Battery.is_too_many_brownout" href="#lib.tools.battery.Battery.is_too_many_brownout">is_too_many_brownout</a></code></li>
<li><code><a title="lib.tools.battery.Battery.keep_reset_cause" href="#lib.tools.battery.Battery.keep_reset_cause">keep_reset_cause</a></code></li>
<li><code><a title="lib.tools.battery.Battery.level" href="#lib.tools.battery.Battery.level">level</a></code></li>
<li><code><a title="lib.tools.battery.Battery.manage" href="#lib.tools.battery.Battery.manage">manage</a></code></li>
<li><code><a title="lib.tools.battery.Battery.manage_level" href="#lib.tools.battery.Battery.manage_level">manage_level</a></code></li>
<li><code><a title="lib.tools.battery.Battery.protect" href="#lib.tools.battery.Battery.protect">protect</a></code></li>
<li><code><a title="lib.tools.battery.Battery.refresh" href="#lib.tools.battery.Battery.refresh">refresh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lib.tools.battery.BatteryConfig" href="#lib.tools.battery.BatteryConfig">BatteryConfig</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>