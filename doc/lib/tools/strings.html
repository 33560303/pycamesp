<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>lib.tools.strings API documentation</title>
<meta name="description" content="Strings utilities" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lib.tools.strings</code></h1>
</header>
<section id="section-intro">
<p>Strings utilities</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Distributed under MIT License
# Copyright (c) 2021 Remi BERTHOLET
# pylint:disable=consider-using-f-string
&#34;&#34;&#34; Strings utilities &#34;&#34;&#34;
import binascii
import time


def size_to_string(size, largeur=6):
        &#34;&#34;&#34; Convert a size in a string with k, m, g, t...&#34;&#34;&#34;
        return size_to_bytes(size, largeur).decode(&#34;utf8&#34;)

def size_to_bytes(size, largeur=6):
        &#34;&#34;&#34; Convert a size in a bytes with k, m, g, t...&#34;&#34;&#34;
        if size &gt; 1073741824*1024:
                return  b&#34;%*.2fT&#34;%(largeur, size / (1073741824.*1024.))
        elif size &gt; 1073741824:
                return  b&#34;%*.2fG&#34;%(largeur, size / 1073741824.)
        elif size &gt; 1048576:
                return b&#34;%*.2fM&#34;%(largeur, size / 1048576.)
        elif size &gt; 1024:
                return b&#34;%*.2fK&#34;%(largeur, size / 1024.)
        else:
                return b&#34;%*dB&#34;%(largeur, size)

def tobytes(datas, encoding=&#34;utf8&#34;):
        &#34;&#34;&#34; Convert data to bytes &#34;&#34;&#34;
        result = datas
        if type(datas) == type(&#34;&#34;):
                result = datas.encode(encoding)
        elif type(datas) == type([]):
                result = []
                for item in datas:
                        result.append(tobytes(item, encoding))
        elif type(datas) == type((0,0)):
                result = []
                for item in datas:
                        result.append(tobytes(item, encoding))
                result = tuple(result)
        elif type(datas) == type({}):
                result = {}
                for key, value in datas.items():
                        result[tobytes(key,encoding)] = tobytes(value, encoding)
        return result

def tostrings(datas, encoding=&#34;utf8&#34;):
        &#34;&#34;&#34; Convert data to strings &#34;&#34;&#34;
        result = datas
        if type(datas) == type(b&#34;&#34;):
                result = datas.decode(encoding)
        elif type(datas) == type([]):
                result = []
                for item in datas:
                        result.append(tostrings(item, encoding))
        elif type(datas) == type((0,0)):
                result = []
                for item in datas:
                        result.append(tostrings(item, encoding))
                result = tuple(result)
        elif type(datas) == type({}):
                result = {}
                for key, value in datas.items():
                        result[tostrings(key,encoding)] = tostrings(value, encoding)
        return result

def tofilename(filename):
        &#34;&#34;&#34; Replace forbid characters in filename &#34;&#34;&#34;
        filename = tostrings(filename)
        if len(filename) &gt; 0:
                for char in &#34;&lt;&gt;:/\\|?*&#34;:
                        filename = filename.replace(char,&#34;_%d_&#34;%ord(char))
        return filename

def isascii(char):
        &#34;&#34;&#34; Indicates if the char is ascii &#34;&#34;&#34;
        if len(char) == 1:
                if ord(char) &gt;= 0x20 and ord(char) != 0x7F or char == &#34;\t&#34;:
                        return True
        return False

def isupper(char):
        &#34;&#34;&#34; Indicates if the char is upper &#34;&#34;&#34;
        if len(char) == 1:
                if ord(char) &gt;= 0x41 and ord(char) &lt;= 0x5A:
                        return True
        return False

def islower(char):
        &#34;&#34;&#34; Indicates if the char is lower &#34;&#34;&#34;
        if len(char) == 1:
                if ord(char) &gt;= 0x61 and ord(char) &lt; 0x7A:
                        return True
        return False

def isdigit(char):
        &#34;&#34;&#34; Indicates if the char is a digit &#34;&#34;&#34;
        if len(char) == 1:
                if ord(char) &gt;= 0x31 and ord(char) &lt;= 0x39:
                        return True
                return False

def isalpha(char):
        &#34;&#34;&#34; Indicates if the char is alpha &#34;&#34;&#34;
        return isupper(char) or islower(char) or isdigit(char)

def isspace(char):
        &#34;&#34;&#34; Indicates if the char is a space, tabulation or new line &#34;&#34;&#34;
        if char == &#34; &#34; or char == &#34;\t&#34; or char == &#34;\n&#34; or char == &#34;\r&#34;:
                return True
        return False

def ispunctuation(char):
        &#34;&#34;&#34; Indicates if the char is a punctuation &#34;&#34;&#34;
        if  (ord(char) &gt;= 0x21 and ord(char) &lt;= 0x2F) or \
                (ord(char) &gt;= 0x3A and ord(char) &lt;= 0x40) or \
                (ord(char) &gt;= 0x5B and ord(char) &lt;= 0x60) or \
                (ord(char) &gt;= 0x7B and ord(char) &lt;= 0x7E):
                return True
        else:
                return False

def get_length_utf8(key):
        &#34;&#34;&#34; Get the length utf8 string &#34;&#34;&#34;
        if len(key) &gt; 0:
                char = key[0]
                if char &lt;= 0x7F:
                        return 1
                elif char &gt;= 0xC2 and char &lt;= 0xDF:
                        return 2
                elif char &gt;= 0xE0 and char &lt;= 0xEF:
                        return 3
                elif char &gt;= 0xF0 and char &lt;= 0xF4:
                        return 4
                return 1
        else:
                return 0

def is_key_ended(key):
        &#34;&#34;&#34; Indicates if the key completly entered &#34;&#34;&#34;
        if len(key) == 0:
                return False
        else:
                char = key[-1]
                if len(key) == 1:
                        if char == 0x1B:
                                return False
                        elif get_length_utf8(key) == len(key):
                                return True
                elif len(key) == 2:
                        if key[0] == b&#34;\x1B&#34; and key[1] == b&#34;\x1B&#34;:
                                return False
                        elif key[0] == b&#34;\x1B&#34;:
                                if  key[1] == b&#34;[&#34; or key[1] == b&#34;(&#34; or \
                                        key[1] == b&#34;)&#34; or key[1] == b&#34;#&#34; or \
                                        key[1] == b&#34;?&#34; or key[1] == b&#34;O&#34;:
                                        return False
                                else:
                                        return True
                        elif get_length_utf8(key) == len(key):
                                return True
                else:
                        if key[-1] &gt;= ord(&#34;A&#34;) and key[-1] &lt;= ord(&#34;Z&#34;):
                                return True
                        elif key[-1] &gt;= ord(&#34;a&#34;) and key[-1] &lt;= ord(&#34;z&#34;):
                                return True
                        elif key[-1] == b&#34;~&#34;:
                                return True
                        elif key[0] != b&#34;\x1B&#34; and get_length_utf8(key) == len(key):
                                return True
        return False

def dump(buff, withColor=True):
        &#34;&#34;&#34; dump buffer &#34;&#34;&#34;
        if withColor:
                string = &#34;\x1B[7m&#34;
        else:
                string = &#34;&#34;
        if type(buff) == type(b&#34;&#34;) or type(buff) == type(bytearray()):
                for i in buff:
                        if isascii(chr(i)):
                                string += chr(i)
                        else:
                                string += &#34;\\x%02x&#34;%i
        else:
                for i in buff:
                        if isascii(i):
                                string += i
                        else:
                                string += &#34;\\x%02x&#34;%ord(i)
        if withColor:
                string += &#34;\x1B[m&#34;
        return string

def dump_line(data, line = None, width = 0):
        &#34;&#34;&#34; dump a data data in hexadecimal on one line &#34;&#34;&#34;
        size = len(data)
        fill = 0

        # Calculation of the filling length
        if width &gt; size:
                fill = width-size

        # Displaying values in hex
        line.write(binascii.hexlify(data, &#34; &#34;).upper())

        # Filling of vacuum according to the size of the dump
        line.write(b&#39;   &#39;*fill)

        # Display of ASCII codes
        line.write(b&#39; |&#39;)

        for i in data:
                if i &gt;= 0x20 and  i &lt; 0x7F:
                        line.write(i.to_bytes(1,&#34;big&#34;))
                else:
                        line.write(b&#39;.&#39;)

        # Filling of vacuum according to the size of the dump
        line.write(b&#39; &#39;*fill)

        # End of data ascii
        line.write(b&#39;|&#39;)

def compute_hash(string):
        &#34;&#34;&#34; Compute hash
        &gt;&gt;&gt; print(compute_hash(&#34;1234&#34;))
        49307
        &gt;&gt;&gt; print(compute_hash(b&#34;1234&#34;))
        49307
        &#34;&#34;&#34;
        string = tostrings(string)
        hash_ = 63689
        for char in string:
                hash_ = hash_ * 378551 + ord(char)
        return hash_ % 65536

try:
        # pylint: disable=no-name-in-module

        from time import ticks_ms
        def ticks():
                &#34;&#34;&#34; Count tick elapsed from start &#34;&#34;&#34;
                return ticks_ms()
except:
        def ticks():
                &#34;&#34;&#34; Count tick elapsed from start &#34;&#34;&#34;
                return (int)(time.time() * 1000)

def ticks_to_string():
        &#34;&#34;&#34; Create a string with tick in seconds &#34;&#34;&#34;
        tick = ticks()
        return &#34;%d.%03d s&#34;%(tick/1000, tick%1000)

def get_utf8_length(data):
        &#34;&#34;&#34; Get the length of utf8 character &#34;&#34;&#34;
        # 0XXX XXXX one byte
        if data &lt;= 0x7F:
                length = 1
        # 110X XXXX  two length
        else:
                # first byte
                if ((data &amp; 0xE0) == 0xC0):
                        length = 2
                # 1110 XXXX  three bytes length
                elif ((data &amp; 0xF0) == 0xE0):
                        length = 3
                # 1111 0XXX  four bytes length
                elif ((data &amp; 0xF8) == 0xF0):
                        length = 4
                # 1111 10XX  five bytes length
                elif ((data &amp; 0xFC) == 0xF8):
                        length = 5
                # 1111 110X  six bytes length
                elif ((data &amp; 0xFE) == 0xFC):
                        length = 6
                else:
                        # not a valid first byte of a UTF-8 sequence
                        length = -1
        return length</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lib.tools.strings.compute_hash"><code class="name flex">
<span>def <span class="ident">compute_hash</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute hash</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(compute_hash(&quot;1234&quot;))
49307
&gt;&gt;&gt; print(compute_hash(b&quot;1234&quot;))
49307
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_hash(string):
        &#34;&#34;&#34; Compute hash
        &gt;&gt;&gt; print(compute_hash(&#34;1234&#34;))
        49307
        &gt;&gt;&gt; print(compute_hash(b&#34;1234&#34;))
        49307
        &#34;&#34;&#34;
        string = tostrings(string)
        hash_ = 63689
        for char in string:
                hash_ = hash_ * 378551 + ord(char)
        return hash_ % 65536</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>buff, withColor=True)</span>
</code></dt>
<dd>
<div class="desc"><p>dump buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(buff, withColor=True):
        &#34;&#34;&#34; dump buffer &#34;&#34;&#34;
        if withColor:
                string = &#34;\x1B[7m&#34;
        else:
                string = &#34;&#34;
        if type(buff) == type(b&#34;&#34;) or type(buff) == type(bytearray()):
                for i in buff:
                        if isascii(chr(i)):
                                string += chr(i)
                        else:
                                string += &#34;\\x%02x&#34;%i
        else:
                for i in buff:
                        if isascii(i):
                                string += i
                        else:
                                string += &#34;\\x%02x&#34;%ord(i)
        if withColor:
                string += &#34;\x1B[m&#34;
        return string</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.dump_line"><code class="name flex">
<span>def <span class="ident">dump_line</span></span>(<span>data, line=None, width=0)</span>
</code></dt>
<dd>
<div class="desc"><p>dump a data data in hexadecimal on one line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_line(data, line = None, width = 0):
        &#34;&#34;&#34; dump a data data in hexadecimal on one line &#34;&#34;&#34;
        size = len(data)
        fill = 0

        # Calculation of the filling length
        if width &gt; size:
                fill = width-size

        # Displaying values in hex
        line.write(binascii.hexlify(data, &#34; &#34;).upper())

        # Filling of vacuum according to the size of the dump
        line.write(b&#39;   &#39;*fill)

        # Display of ASCII codes
        line.write(b&#39; |&#39;)

        for i in data:
                if i &gt;= 0x20 and  i &lt; 0x7F:
                        line.write(i.to_bytes(1,&#34;big&#34;))
                else:
                        line.write(b&#39;.&#39;)

        # Filling of vacuum according to the size of the dump
        line.write(b&#39; &#39;*fill)

        # End of data ascii
        line.write(b&#39;|&#39;)</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.get_length_utf8"><code class="name flex">
<span>def <span class="ident">get_length_utf8</span></span>(<span>key)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the length utf8 string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_length_utf8(key):
        &#34;&#34;&#34; Get the length utf8 string &#34;&#34;&#34;
        if len(key) &gt; 0:
                char = key[0]
                if char &lt;= 0x7F:
                        return 1
                elif char &gt;= 0xC2 and char &lt;= 0xDF:
                        return 2
                elif char &gt;= 0xE0 and char &lt;= 0xEF:
                        return 3
                elif char &gt;= 0xF0 and char &lt;= 0xF4:
                        return 4
                return 1
        else:
                return 0</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.get_utf8_length"><code class="name flex">
<span>def <span class="ident">get_utf8_length</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the length of utf8 character</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_utf8_length(data):
        &#34;&#34;&#34; Get the length of utf8 character &#34;&#34;&#34;
        # 0XXX XXXX one byte
        if data &lt;= 0x7F:
                length = 1
        # 110X XXXX  two length
        else:
                # first byte
                if ((data &amp; 0xE0) == 0xC0):
                        length = 2
                # 1110 XXXX  three bytes length
                elif ((data &amp; 0xF0) == 0xE0):
                        length = 3
                # 1111 0XXX  four bytes length
                elif ((data &amp; 0xF8) == 0xF0):
                        length = 4
                # 1111 10XX  five bytes length
                elif ((data &amp; 0xFC) == 0xF8):
                        length = 5
                # 1111 110X  six bytes length
                elif ((data &amp; 0xFE) == 0xFC):
                        length = 6
                else:
                        # not a valid first byte of a UTF-8 sequence
                        length = -1
        return length</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.is_key_ended"><code class="name flex">
<span>def <span class="ident">is_key_ended</span></span>(<span>key)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the key completly entered</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_key_ended(key):
        &#34;&#34;&#34; Indicates if the key completly entered &#34;&#34;&#34;
        if len(key) == 0:
                return False
        else:
                char = key[-1]
                if len(key) == 1:
                        if char == 0x1B:
                                return False
                        elif get_length_utf8(key) == len(key):
                                return True
                elif len(key) == 2:
                        if key[0] == b&#34;\x1B&#34; and key[1] == b&#34;\x1B&#34;:
                                return False
                        elif key[0] == b&#34;\x1B&#34;:
                                if  key[1] == b&#34;[&#34; or key[1] == b&#34;(&#34; or \
                                        key[1] == b&#34;)&#34; or key[1] == b&#34;#&#34; or \
                                        key[1] == b&#34;?&#34; or key[1] == b&#34;O&#34;:
                                        return False
                                else:
                                        return True
                        elif get_length_utf8(key) == len(key):
                                return True
                else:
                        if key[-1] &gt;= ord(&#34;A&#34;) and key[-1] &lt;= ord(&#34;Z&#34;):
                                return True
                        elif key[-1] &gt;= ord(&#34;a&#34;) and key[-1] &lt;= ord(&#34;z&#34;):
                                return True
                        elif key[-1] == b&#34;~&#34;:
                                return True
                        elif key[0] != b&#34;\x1B&#34; and get_length_utf8(key) == len(key):
                                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.isalpha"><code class="name flex">
<span>def <span class="ident">isalpha</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the char is alpha</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalpha(char):
        &#34;&#34;&#34; Indicates if the char is alpha &#34;&#34;&#34;
        return isupper(char) or islower(char) or isdigit(char)</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.isascii"><code class="name flex">
<span>def <span class="ident">isascii</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the char is ascii</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isascii(char):
        &#34;&#34;&#34; Indicates if the char is ascii &#34;&#34;&#34;
        if len(char) == 1:
                if ord(char) &gt;= 0x20 and ord(char) != 0x7F or char == &#34;\t&#34;:
                        return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.isdigit"><code class="name flex">
<span>def <span class="ident">isdigit</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the char is a digit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isdigit(char):
        &#34;&#34;&#34; Indicates if the char is a digit &#34;&#34;&#34;
        if len(char) == 1:
                if ord(char) &gt;= 0x31 and ord(char) &lt;= 0x39:
                        return True
                return False</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.islower"><code class="name flex">
<span>def <span class="ident">islower</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the char is lower</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def islower(char):
        &#34;&#34;&#34; Indicates if the char is lower &#34;&#34;&#34;
        if len(char) == 1:
                if ord(char) &gt;= 0x61 and ord(char) &lt; 0x7A:
                        return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.ispunctuation"><code class="name flex">
<span>def <span class="ident">ispunctuation</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the char is a punctuation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ispunctuation(char):
        &#34;&#34;&#34; Indicates if the char is a punctuation &#34;&#34;&#34;
        if  (ord(char) &gt;= 0x21 and ord(char) &lt;= 0x2F) or \
                (ord(char) &gt;= 0x3A and ord(char) &lt;= 0x40) or \
                (ord(char) &gt;= 0x5B and ord(char) &lt;= 0x60) or \
                (ord(char) &gt;= 0x7B and ord(char) &lt;= 0x7E):
                return True
        else:
                return False</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.isspace"><code class="name flex">
<span>def <span class="ident">isspace</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the char is a space, tabulation or new line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isspace(char):
        &#34;&#34;&#34; Indicates if the char is a space, tabulation or new line &#34;&#34;&#34;
        if char == &#34; &#34; or char == &#34;\t&#34; or char == &#34;\n&#34; or char == &#34;\r&#34;:
                return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.isupper"><code class="name flex">
<span>def <span class="ident">isupper</span></span>(<span>char)</span>
</code></dt>
<dd>
<div class="desc"><p>Indicates if the char is upper</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isupper(char):
        &#34;&#34;&#34; Indicates if the char is upper &#34;&#34;&#34;
        if len(char) == 1:
                if ord(char) &gt;= 0x41 and ord(char) &lt;= 0x5A:
                        return True
        return False</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.size_to_bytes"><code class="name flex">
<span>def <span class="ident">size_to_bytes</span></span>(<span>size, largeur=6)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a size in a bytes with k, m, g, t&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_to_bytes(size, largeur=6):
        &#34;&#34;&#34; Convert a size in a bytes with k, m, g, t...&#34;&#34;&#34;
        if size &gt; 1073741824*1024:
                return  b&#34;%*.2fT&#34;%(largeur, size / (1073741824.*1024.))
        elif size &gt; 1073741824:
                return  b&#34;%*.2fG&#34;%(largeur, size / 1073741824.)
        elif size &gt; 1048576:
                return b&#34;%*.2fM&#34;%(largeur, size / 1048576.)
        elif size &gt; 1024:
                return b&#34;%*.2fK&#34;%(largeur, size / 1024.)
        else:
                return b&#34;%*dB&#34;%(largeur, size)</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.size_to_string"><code class="name flex">
<span>def <span class="ident">size_to_string</span></span>(<span>size, largeur=6)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a size in a string with k, m, g, t&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_to_string(size, largeur=6):
        &#34;&#34;&#34; Convert a size in a string with k, m, g, t...&#34;&#34;&#34;
        return size_to_bytes(size, largeur).decode(&#34;utf8&#34;)</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.ticks"><code class="name flex">
<span>def <span class="ident">ticks</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Count tick elapsed from start</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ticks():
        &#34;&#34;&#34; Count tick elapsed from start &#34;&#34;&#34;
        return (int)(time.time() * 1000)</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.ticks_to_string"><code class="name flex">
<span>def <span class="ident">ticks_to_string</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a string with tick in seconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ticks_to_string():
        &#34;&#34;&#34; Create a string with tick in seconds &#34;&#34;&#34;
        tick = ticks()
        return &#34;%d.%03d s&#34;%(tick/1000, tick%1000)</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.tobytes"><code class="name flex">
<span>def <span class="ident">tobytes</span></span>(<span>datas, encoding='utf8')</span>
</code></dt>
<dd>
<div class="desc"><p>Convert data to bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tobytes(datas, encoding=&#34;utf8&#34;):
        &#34;&#34;&#34; Convert data to bytes &#34;&#34;&#34;
        result = datas
        if type(datas) == type(&#34;&#34;):
                result = datas.encode(encoding)
        elif type(datas) == type([]):
                result = []
                for item in datas:
                        result.append(tobytes(item, encoding))
        elif type(datas) == type((0,0)):
                result = []
                for item in datas:
                        result.append(tobytes(item, encoding))
                result = tuple(result)
        elif type(datas) == type({}):
                result = {}
                for key, value in datas.items():
                        result[tobytes(key,encoding)] = tobytes(value, encoding)
        return result</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.tofilename"><code class="name flex">
<span>def <span class="ident">tofilename</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace forbid characters in filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tofilename(filename):
        &#34;&#34;&#34; Replace forbid characters in filename &#34;&#34;&#34;
        filename = tostrings(filename)
        if len(filename) &gt; 0:
                for char in &#34;&lt;&gt;:/\\|?*&#34;:
                        filename = filename.replace(char,&#34;_%d_&#34;%ord(char))
        return filename</code></pre>
</details>
</dd>
<dt id="lib.tools.strings.tostrings"><code class="name flex">
<span>def <span class="ident">tostrings</span></span>(<span>datas, encoding='utf8')</span>
</code></dt>
<dd>
<div class="desc"><p>Convert data to strings</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tostrings(datas, encoding=&#34;utf8&#34;):
        &#34;&#34;&#34; Convert data to strings &#34;&#34;&#34;
        result = datas
        if type(datas) == type(b&#34;&#34;):
                result = datas.decode(encoding)
        elif type(datas) == type([]):
                result = []
                for item in datas:
                        result.append(tostrings(item, encoding))
        elif type(datas) == type((0,0)):
                result = []
                for item in datas:
                        result.append(tostrings(item, encoding))
                result = tuple(result)
        elif type(datas) == type({}):
                result = {}
                for key, value in datas.items():
                        result[tostrings(key,encoding)] = tostrings(value, encoding)
        return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="lib.tools" href="index.html">lib.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="lib.tools.strings.compute_hash" href="#lib.tools.strings.compute_hash">compute_hash</a></code></li>
<li><code><a title="lib.tools.strings.dump" href="#lib.tools.strings.dump">dump</a></code></li>
<li><code><a title="lib.tools.strings.dump_line" href="#lib.tools.strings.dump_line">dump_line</a></code></li>
<li><code><a title="lib.tools.strings.get_length_utf8" href="#lib.tools.strings.get_length_utf8">get_length_utf8</a></code></li>
<li><code><a title="lib.tools.strings.get_utf8_length" href="#lib.tools.strings.get_utf8_length">get_utf8_length</a></code></li>
<li><code><a title="lib.tools.strings.is_key_ended" href="#lib.tools.strings.is_key_ended">is_key_ended</a></code></li>
<li><code><a title="lib.tools.strings.isalpha" href="#lib.tools.strings.isalpha">isalpha</a></code></li>
<li><code><a title="lib.tools.strings.isascii" href="#lib.tools.strings.isascii">isascii</a></code></li>
<li><code><a title="lib.tools.strings.isdigit" href="#lib.tools.strings.isdigit">isdigit</a></code></li>
<li><code><a title="lib.tools.strings.islower" href="#lib.tools.strings.islower">islower</a></code></li>
<li><code><a title="lib.tools.strings.ispunctuation" href="#lib.tools.strings.ispunctuation">ispunctuation</a></code></li>
<li><code><a title="lib.tools.strings.isspace" href="#lib.tools.strings.isspace">isspace</a></code></li>
<li><code><a title="lib.tools.strings.isupper" href="#lib.tools.strings.isupper">isupper</a></code></li>
<li><code><a title="lib.tools.strings.size_to_bytes" href="#lib.tools.strings.size_to_bytes">size_to_bytes</a></code></li>
<li><code><a title="lib.tools.strings.size_to_string" href="#lib.tools.strings.size_to_string">size_to_string</a></code></li>
<li><code><a title="lib.tools.strings.ticks" href="#lib.tools.strings.ticks">ticks</a></code></li>
<li><code><a title="lib.tools.strings.ticks_to_string" href="#lib.tools.strings.ticks_to_string">ticks_to_string</a></code></li>
<li><code><a title="lib.tools.strings.tobytes" href="#lib.tools.strings.tobytes">tobytes</a></code></li>
<li><code><a title="lib.tools.strings.tofilename" href="#lib.tools.strings.tofilename">tofilename</a></code></li>
<li><code><a title="lib.tools.strings.tostrings" href="#lib.tools.strings.tostrings">tostrings</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>